{"ast":null,"code":"!function (t, e) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? e(exports) : \"function\" == typeof define && define.amd ? define([\"exports\"], e) : e((t = \"undefined\" != typeof globalThis ? globalThis : t || self).turf = {});\n}(this, function (t) {\n  \"use strict\";\n\n  var e = 6371008.8,\n    n = {\n      centimeters: 637100880,\n      centimetres: 637100880,\n      degrees: 57.22891354143274,\n      feet: 20902260.511392,\n      inches: 39.37 * e,\n      kilometers: 6371.0088,\n      kilometres: 6371.0088,\n      meters: e,\n      metres: e,\n      miles: 3958.761333810546,\n      millimeters: 6371008800,\n      millimetres: 6371008800,\n      nauticalmiles: e / 1852,\n      radians: 1,\n      yards: 6967335.223679999\n    },\n    r = {\n      centimeters: 100,\n      centimetres: 100,\n      degrees: 1 / 111325,\n      feet: 3.28084,\n      inches: 39.37,\n      kilometers: .001,\n      kilometres: .001,\n      meters: 1,\n      metres: 1,\n      miles: 1 / 1609.344,\n      millimeters: 1e3,\n      millimetres: 1e3,\n      nauticalmiles: 1 / 1852,\n      radians: 1 / e,\n      yards: 1.0936133\n    },\n    i = {\n      acres: 247105e-9,\n      centimeters: 1e4,\n      centimetres: 1e4,\n      feet: 10.763910417,\n      hectares: 1e-4,\n      inches: 1550.003100006,\n      kilometers: 1e-6,\n      kilometres: 1e-6,\n      meters: 1,\n      metres: 1,\n      miles: 386e-9,\n      millimeters: 1e6,\n      millimetres: 1e6,\n      yards: 1.195990046\n    };\n  function o(t, e, n) {\n    void 0 === n && (n = {});\n    var r = {\n      type: \"Feature\"\n    };\n    return (0 === n.id || n.id) && (r.id = n.id), n.bbox && (r.bbox = n.bbox), r.properties = e || {}, r.geometry = t, r;\n  }\n  function s(t, e, n) {\n    switch (t) {\n      case \"Point\":\n        return a(e).geometry;\n      case \"LineString\":\n        return h(e).geometry;\n      case \"Polygon\":\n        return l(e).geometry;\n      case \"MultiPoint\":\n        return d(e).geometry;\n      case \"MultiLineString\":\n        return g(e).geometry;\n      case \"MultiPolygon\":\n        return y(e).geometry;\n      default:\n        throw new Error(t + \" is invalid\");\n    }\n  }\n  function a(t, e, n) {\n    if (void 0 === n && (n = {}), !t) throw new Error(\"coordinates is required\");\n    if (!Array.isArray(t)) throw new Error(\"coordinates must be an Array\");\n    if (t.length < 2) throw new Error(\"coordinates must be at least 2 numbers long\");\n    if (!C(t[0]) || !C(t[1])) throw new Error(\"coordinates must contain numbers\");\n    return o({\n      type: \"Point\",\n      coordinates: t\n    }, e, n);\n  }\n  function u(t, e, n) {\n    return void 0 === n && (n = {}), f(t.map(function (t) {\n      return a(t, e);\n    }), n);\n  }\n  function l(t, e, n) {\n    void 0 === n && (n = {});\n    for (var r = 0, i = t; r < i.length; r++) {\n      var s = i[r];\n      if (s.length < 4) throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n      for (var a = 0; a < s[s.length - 1].length; a++) if (s[s.length - 1][a] !== s[0][a]) throw new Error(\"First and last Position are not equivalent.\");\n    }\n    return o({\n      type: \"Polygon\",\n      coordinates: t\n    }, e, n);\n  }\n  function c(t, e, n) {\n    return void 0 === n && (n = {}), f(t.map(function (t) {\n      return l(t, e);\n    }), n);\n  }\n  function h(t, e, n) {\n    if (void 0 === n && (n = {}), t.length < 2) throw new Error(\"coordinates must be an array of two or more positions\");\n    return o({\n      type: \"LineString\",\n      coordinates: t\n    }, e, n);\n  }\n  function p(t, e, n) {\n    return void 0 === n && (n = {}), f(t.map(function (t) {\n      return h(t, e);\n    }), n);\n  }\n  function f(t, e) {\n    void 0 === e && (e = {});\n    var n = {\n      type: \"FeatureCollection\"\n    };\n    return e.id && (n.id = e.id), e.bbox && (n.bbox = e.bbox), n.features = t, n;\n  }\n  function g(t, e, n) {\n    return void 0 === n && (n = {}), o({\n      type: \"MultiLineString\",\n      coordinates: t\n    }, e, n);\n  }\n  function d(t, e, n) {\n    return void 0 === n && (n = {}), o({\n      type: \"MultiPoint\",\n      coordinates: t\n    }, e, n);\n  }\n  function y(t, e, n) {\n    return void 0 === n && (n = {}), o({\n      type: \"MultiPolygon\",\n      coordinates: t\n    }, e, n);\n  }\n  function v(t, e, n) {\n    return void 0 === n && (n = {}), o({\n      type: \"GeometryCollection\",\n      geometries: t\n    }, e, n);\n  }\n  function _(t, e) {\n    if (void 0 === e && (e = 0), e && !(e >= 0)) throw new Error(\"precision must be a positive number\");\n    var n = Math.pow(10, e || 0);\n    return Math.round(t * n) / n;\n  }\n  function m(t, e) {\n    void 0 === e && (e = \"kilometers\");\n    var r = n[e];\n    if (!r) throw new Error(e + \" units is invalid\");\n    return t * r;\n  }\n  function x(t, e) {\n    void 0 === e && (e = \"kilometers\");\n    var r = n[e];\n    if (!r) throw new Error(e + \" units is invalid\");\n    return t / r;\n  }\n  function E(t, e) {\n    return w(x(t, e));\n  }\n  function b(t) {\n    var e = t % 360;\n    return e < 0 && (e += 360), e;\n  }\n  function w(t) {\n    return 180 * (t % (2 * Math.PI)) / Math.PI;\n  }\n  function I(t) {\n    return t % 360 * Math.PI / 180;\n  }\n  function N(t, e, n) {\n    if (void 0 === e && (e = \"kilometers\"), void 0 === n && (n = \"kilometers\"), !(t >= 0)) throw new Error(\"length must be a positive number\");\n    return m(x(t, e), n);\n  }\n  function S(t, e, n) {\n    if (void 0 === e && (e = \"meters\"), void 0 === n && (n = \"kilometers\"), !(t >= 0)) throw new Error(\"area must be a positive number\");\n    var r = i[e];\n    if (!r) throw new Error(\"invalid original units\");\n    var o = i[n];\n    if (!o) throw new Error(\"invalid final units\");\n    return t / r * o;\n  }\n  function C(t) {\n    return !isNaN(t) && null !== t && !Array.isArray(t);\n  }\n  function P(t) {\n    return !!t && t.constructor === Object;\n  }\n  function M(t) {\n    if (!t) throw new Error(\"bbox is required\");\n    if (!Array.isArray(t)) throw new Error(\"bbox must be an Array\");\n    if (4 !== t.length && 6 !== t.length) throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    t.forEach(function (t) {\n      if (!C(t)) throw new Error(\"bbox must only contain numbers\");\n    });\n  }\n  function L(t) {\n    if (!t) throw new Error(\"id is required\");\n    if (-1 === [\"string\", \"number\"].indexOf(typeof t)) throw new Error(\"id must be a number or a string\");\n  }\n  var O = Object.freeze({\n    __proto__: null,\n    earthRadius: e,\n    factors: n,\n    unitsFactors: r,\n    areaFactors: i,\n    feature: o,\n    geometry: s,\n    point: a,\n    points: u,\n    polygon: l,\n    polygons: c,\n    lineString: h,\n    lineStrings: p,\n    featureCollection: f,\n    multiLineString: g,\n    multiPoint: d,\n    multiPolygon: y,\n    geometryCollection: v,\n    round: _,\n    radiansToLength: m,\n    lengthToRadians: x,\n    lengthToDegrees: E,\n    bearingToAzimuth: b,\n    radiansToDegrees: w,\n    degreesToRadians: I,\n    convertLength: N,\n    convertArea: S,\n    isNumber: C,\n    isObject: P,\n    validateBBox: M,\n    validateId: L\n  });\n  function R(t, e, n) {\n    if (null !== t) for (var r, i, o, s, a, u, l, c, h = 0, p = 0, f = t.type, g = \"FeatureCollection\" === f, d = \"Feature\" === f, y = g ? t.features.length : 1, v = 0; v < y; v++) {\n      a = (c = !!(l = g ? t.features[v].geometry : d ? t.geometry : t) && \"GeometryCollection\" === l.type) ? l.geometries.length : 1;\n      for (var _ = 0; _ < a; _++) {\n        var m = 0,\n          x = 0;\n        if (null !== (s = c ? l.geometries[_] : l)) {\n          u = s.coordinates;\n          var E = s.type;\n          switch (h = !n || \"Polygon\" !== E && \"MultiPolygon\" !== E ? 0 : 1, E) {\n            case null:\n              break;\n            case \"Point\":\n              if (!1 === e(u, p, v, m, x)) return !1;\n              p++, m++;\n              break;\n            case \"LineString\":\n            case \"MultiPoint\":\n              for (r = 0; r < u.length; r++) {\n                if (!1 === e(u[r], p, v, m, x)) return !1;\n                p++, \"MultiPoint\" === E && m++;\n              }\n              \"LineString\" === E && m++;\n              break;\n            case \"Polygon\":\n            case \"MultiLineString\":\n              for (r = 0; r < u.length; r++) {\n                for (i = 0; i < u[r].length - h; i++) {\n                  if (!1 === e(u[r][i], p, v, m, x)) return !1;\n                  p++;\n                }\n                \"MultiLineString\" === E && m++, \"Polygon\" === E && x++;\n              }\n              \"Polygon\" === E && m++;\n              break;\n            case \"MultiPolygon\":\n              for (r = 0; r < u.length; r++) {\n                for (x = 0, i = 0; i < u[r].length; i++) {\n                  for (o = 0; o < u[r][i].length - h; o++) {\n                    if (!1 === e(u[r][i][o], p, v, m, x)) return !1;\n                    p++;\n                  }\n                  x++;\n                }\n                m++;\n              }\n              break;\n            case \"GeometryCollection\":\n              for (r = 0; r < s.geometries.length; r++) if (!1 === R(s.geometries[r], e, n)) return !1;\n              break;\n            default:\n              throw new Error(\"Unknown Geometry Type\");\n          }\n        }\n      }\n    }\n  }\n  function T(t, e, n, r) {\n    var i = n;\n    return R(t, function (t, r, o, s, a) {\n      i = 0 === r && void 0 === n ? t : e(i, t, r, o, s, a);\n    }, r), i;\n  }\n  function A(t, e) {\n    var n;\n    switch (t.type) {\n      case \"FeatureCollection\":\n        for (n = 0; n < t.features.length && !1 !== e(t.features[n].properties, n); n++);\n        break;\n      case \"Feature\":\n        e(t.properties, 0);\n    }\n  }\n  function D(t, e, n) {\n    var r = n;\n    return A(t, function (t, i) {\n      r = 0 === i && void 0 === n ? t : e(r, t, i);\n    }), r;\n  }\n  function F(t, e) {\n    if (\"Feature\" === t.type) e(t, 0);else if (\"FeatureCollection\" === t.type) for (var n = 0; n < t.features.length && !1 !== e(t.features[n], n); n++);\n  }\n  function k(t, e, n) {\n    var r = n;\n    return F(t, function (t, i) {\n      r = 0 === i && void 0 === n ? t : e(r, t, i);\n    }), r;\n  }\n  function G(t) {\n    var e = [];\n    return R(t, function (t) {\n      e.push(t);\n    }), e;\n  }\n  function q(t, e) {\n    var n,\n      r,\n      i,\n      o,\n      s,\n      a,\n      u,\n      l,\n      c,\n      h,\n      p = 0,\n      f = \"FeatureCollection\" === t.type,\n      g = \"Feature\" === t.type,\n      d = f ? t.features.length : 1;\n    for (n = 0; n < d; n++) {\n      for (a = f ? t.features[n].geometry : g ? t.geometry : t, l = f ? t.features[n].properties : g ? t.properties : {}, c = f ? t.features[n].bbox : g ? t.bbox : void 0, h = f ? t.features[n].id : g ? t.id : void 0, s = (u = !!a && \"GeometryCollection\" === a.type) ? a.geometries.length : 1, i = 0; i < s; i++) if (null !== (o = u ? a.geometries[i] : a)) switch (o.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\":\n          if (!1 === e(o, p, l, c, h)) return !1;\n          break;\n        case \"GeometryCollection\":\n          for (r = 0; r < o.geometries.length; r++) if (!1 === e(o.geometries[r], p, l, c, h)) return !1;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      } else if (!1 === e(null, p, l, c, h)) return !1;\n      p++;\n    }\n  }\n  function B(t, e, n) {\n    var r = n;\n    return q(t, function (t, i, o, s, a) {\n      r = 0 === i && void 0 === n ? t : e(r, t, i, o, s, a);\n    }), r;\n  }\n  function z(t, e) {\n    q(t, function (t, n, r, i, s) {\n      var a,\n        u = null === t ? null : t.type;\n      switch (u) {\n        case null:\n        case \"Point\":\n        case \"LineString\":\n        case \"Polygon\":\n          return !1 !== e(o(t, r, {\n            bbox: i,\n            id: s\n          }), n, 0) && void 0;\n      }\n      switch (u) {\n        case \"MultiPoint\":\n          a = \"Point\";\n          break;\n        case \"MultiLineString\":\n          a = \"LineString\";\n          break;\n        case \"MultiPolygon\":\n          a = \"Polygon\";\n      }\n      for (var l = 0; l < t.coordinates.length; l++) {\n        var c = t.coordinates[l];\n        if (!1 === e(o({\n          type: a,\n          coordinates: c\n        }, r), n, l)) return !1;\n      }\n    });\n  }\n  function j(t, e, n) {\n    var r = n;\n    return z(t, function (t, i, o) {\n      r = 0 === i && 0 === o && void 0 === n ? t : e(r, t, i, o);\n    }), r;\n  }\n  function U(t, e) {\n    z(t, function (t, n, r) {\n      var i = 0;\n      if (t.geometry) {\n        var o = t.geometry.type;\n        if (\"Point\" !== o && \"MultiPoint\" !== o) {\n          var s,\n            a = 0,\n            u = 0,\n            l = 0;\n          return !1 !== R(t, function (o, c, p, f, g) {\n            if (void 0 === s || n > a || f > u || g > l) return s = o, a = n, u = f, l = g, void (i = 0);\n            var d = h([s, o], t.properties);\n            if (!1 === e(d, n, r, g, i)) return !1;\n            i++, s = o;\n          }) && void 0;\n        }\n      }\n    });\n  }\n  function V(t, e, n) {\n    var r = n,\n      i = !1;\n    return U(t, function (t, o, s, a, u) {\n      r = !1 === i && void 0 === n ? t : e(r, t, o, s, a, u), i = !0;\n    }), r;\n  }\n  function X(t, e) {\n    if (!t) throw new Error(\"geojson is required\");\n    z(t, function (t, n, r) {\n      if (null !== t.geometry) {\n        var i = t.geometry.type,\n          o = t.geometry.coordinates;\n        switch (i) {\n          case \"LineString\":\n            if (!1 === e(t, n, r, 0, 0)) return !1;\n            break;\n          case \"Polygon\":\n            for (var s = 0; s < o.length; s++) if (!1 === e(h(o[s], t.properties), n, r, s)) return !1;\n        }\n      }\n    });\n  }\n  function Y(t, e, n) {\n    var r = n;\n    return X(t, function (t, i, o, s) {\n      r = 0 === i && void 0 === n ? t : e(r, t, i, o, s);\n    }), r;\n  }\n  function H(t, e) {\n    if (!P(e = e || {})) throw new Error(\"options is invalid\");\n    var n,\n      r = e.featureIndex || 0,\n      i = e.multiFeatureIndex || 0,\n      o = e.geometryIndex || 0,\n      s = e.segmentIndex || 0,\n      a = e.properties;\n    switch (t.type) {\n      case \"FeatureCollection\":\n        r < 0 && (r = t.features.length + r), a = a || t.features[r].properties, n = t.features[r].geometry;\n        break;\n      case \"Feature\":\n        a = a || t.properties, n = t.geometry;\n        break;\n      case \"Point\":\n      case \"MultiPoint\":\n        return null;\n      case \"LineString\":\n      case \"Polygon\":\n      case \"MultiLineString\":\n      case \"MultiPolygon\":\n        n = t;\n        break;\n      default:\n        throw new Error(\"geojson is invalid\");\n    }\n    if (null === n) return null;\n    var u = n.coordinates;\n    switch (n.type) {\n      case \"Point\":\n      case \"MultiPoint\":\n        return null;\n      case \"LineString\":\n        return s < 0 && (s = u.length + s - 1), h([u[s], u[s + 1]], a, e);\n      case \"Polygon\":\n        return o < 0 && (o = u.length + o), s < 0 && (s = u[o].length + s - 1), h([u[o][s], u[o][s + 1]], a, e);\n      case \"MultiLineString\":\n        return i < 0 && (i = u.length + i), s < 0 && (s = u[i].length + s - 1), h([u[i][s], u[i][s + 1]], a, e);\n      case \"MultiPolygon\":\n        return i < 0 && (i = u.length + i), o < 0 && (o = u[i].length + o), s < 0 && (s = u[i][o].length - s - 1), h([u[i][o][s], u[i][o][s + 1]], a, e);\n    }\n    throw new Error(\"geojson is invalid\");\n  }\n  function W(t, e) {\n    if (!P(e = e || {})) throw new Error(\"options is invalid\");\n    var n,\n      r = e.featureIndex || 0,\n      i = e.multiFeatureIndex || 0,\n      o = e.geometryIndex || 0,\n      s = e.coordIndex || 0,\n      u = e.properties;\n    switch (t.type) {\n      case \"FeatureCollection\":\n        r < 0 && (r = t.features.length + r), u = u || t.features[r].properties, n = t.features[r].geometry;\n        break;\n      case \"Feature\":\n        u = u || t.properties, n = t.geometry;\n        break;\n      case \"Point\":\n      case \"MultiPoint\":\n        return null;\n      case \"LineString\":\n      case \"Polygon\":\n      case \"MultiLineString\":\n      case \"MultiPolygon\":\n        n = t;\n        break;\n      default:\n        throw new Error(\"geojson is invalid\");\n    }\n    if (null === n) return null;\n    var l = n.coordinates;\n    switch (n.type) {\n      case \"Point\":\n        return a(l, u, e);\n      case \"MultiPoint\":\n        return i < 0 && (i = l.length + i), a(l[i], u, e);\n      case \"LineString\":\n        return s < 0 && (s = l.length + s), a(l[s], u, e);\n      case \"Polygon\":\n        return o < 0 && (o = l.length + o), s < 0 && (s = l[o].length + s), a(l[o][s], u, e);\n      case \"MultiLineString\":\n        return i < 0 && (i = l.length + i), s < 0 && (s = l[i].length + s), a(l[i][s], u, e);\n      case \"MultiPolygon\":\n        return i < 0 && (i = l.length + i), o < 0 && (o = l[i].length + o), s < 0 && (s = l[i][o].length - s), a(l[i][o][s], u, e);\n    }\n    throw new Error(\"geojson is invalid\");\n  }\n  var J = Object.freeze({\n    __proto__: null,\n    coordAll: G,\n    coordEach: R,\n    coordReduce: T,\n    featureEach: F,\n    featureReduce: k,\n    findPoint: W,\n    findSegment: H,\n    flattenEach: z,\n    flattenReduce: j,\n    geomEach: q,\n    geomReduce: B,\n    lineEach: X,\n    lineReduce: Y,\n    propEach: A,\n    propReduce: D,\n    segmentEach: U,\n    segmentReduce: V\n  });\n  function Z(t) {\n    var e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n    return R(t, function (t) {\n      e[0] > t[0] && (e[0] = t[0]), e[1] > t[1] && (e[1] = t[1]), e[2] < t[0] && (e[2] = t[0]), e[3] < t[1] && (e[3] = t[1]);\n    }), e;\n  }\n  function K(t) {\n    if (!t) throw new Error(\"coord is required\");\n    if (!Array.isArray(t)) {\n      if (\"Feature\" === t.type && null !== t.geometry && \"Point\" === t.geometry.type) return t.geometry.coordinates;\n      if (\"Point\" === t.type) return t.coordinates;\n    }\n    if (Array.isArray(t) && t.length >= 2 && !Array.isArray(t[0]) && !Array.isArray(t[1])) return t;\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n  }\n  function Q(t) {\n    if (Array.isArray(t)) return t;\n    if (\"Feature\" === t.type) {\n      if (null !== t.geometry) return t.geometry.coordinates;\n    } else if (t.coordinates) return t.coordinates;\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n  }\n  function $(t) {\n    if (t.length > 1 && C(t[0]) && C(t[1])) return !0;\n    if (Array.isArray(t[0]) && t[0].length) return $(t[0]);\n    throw new Error(\"coordinates must only contain numbers\");\n  }\n  function tt(t, e, n) {\n    if (!e || !n) throw new Error(\"type and name required\");\n    if (!t || t.type !== e) throw new Error(\"Invalid input to \" + n + \": must be a \" + e + \", given \" + t.type);\n  }\n  function et(t, e, n) {\n    if (!t) throw new Error(\"No feature passed\");\n    if (!n) throw new Error(\".featureOf() requires a name\");\n    if (!t || \"Feature\" !== t.type || !t.geometry) throw new Error(\"Invalid input to \" + n + \", Feature with geometry required\");\n    if (!t.geometry || t.geometry.type !== e) throw new Error(\"Invalid input to \" + n + \": must be a \" + e + \", given \" + t.geometry.type);\n  }\n  function nt(t, e, n) {\n    if (!t) throw new Error(\"No featureCollection passed\");\n    if (!n) throw new Error(\".collectionOf() requires a name\");\n    if (!t || \"FeatureCollection\" !== t.type) throw new Error(\"Invalid input to \" + n + \", FeatureCollection required\");\n    for (var r = 0, i = t.features; r < i.length; r++) {\n      var o = i[r];\n      if (!o || \"Feature\" !== o.type || !o.geometry) throw new Error(\"Invalid input to \" + n + \", Feature with geometry required\");\n      if (!o.geometry || o.geometry.type !== e) throw new Error(\"Invalid input to \" + n + \": must be a \" + e + \", given \" + o.geometry.type);\n    }\n  }\n  function rt(t) {\n    return \"Feature\" === t.type ? t.geometry : t;\n  }\n  function it(t, e) {\n    return \"FeatureCollection\" === t.type ? \"FeatureCollection\" : \"GeometryCollection\" === t.type ? \"GeometryCollection\" : \"Feature\" === t.type && null !== t.geometry ? t.geometry.type : t.type;\n  }\n  Z.default = Z;\n  var ot = Object.freeze({\n      __proto__: null,\n      getCoord: K,\n      getCoords: Q,\n      containsNumber: $,\n      geojsonType: tt,\n      featureOf: et,\n      collectionOf: nt,\n      getGeom: rt,\n      getType: it\n    }),\n    st = Object.getOwnPropertySymbols,\n    at = Object.prototype.hasOwnProperty,\n    ut = Object.prototype.propertyIsEnumerable;\n  /*\n      object-assign\n      (c) Sindre Sorhus\n      @license MIT\n      */\n  function lt(t) {\n    if (null == t) throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n    return Object(t);\n  }\n  var ct = function () {\n      try {\n        if (!Object.assign) return !1;\n        var t = new String(\"abc\");\n        if (t[5] = \"de\", \"5\" === Object.getOwnPropertyNames(t)[0]) return !1;\n        for (var e = {}, n = 0; n < 10; n++) e[\"_\" + String.fromCharCode(n)] = n;\n        if (\"0123456789\" !== Object.getOwnPropertyNames(e).map(function (t) {\n          return e[t];\n        }).join(\"\")) return !1;\n        var r = {};\n        return \"abcdefghijklmnopqrst\".split(\"\").forEach(function (t) {\n          r[t] = t;\n        }), \"abcdefghijklmnopqrst\" === Object.keys(Object.assign({}, r)).join(\"\");\n      } catch (t) {\n        return !1;\n      }\n    }() ? Object.assign : function (t, e) {\n      for (var n, r, i = lt(t), o = 1; o < arguments.length; o++) {\n        for (var s in n = Object(arguments[o])) at.call(n, s) && (i[s] = n[s]);\n        if (st) {\n          r = st(n);\n          for (var a = 0; a < r.length; a++) ut.call(n, r[a]) && (i[r[a]] = n[r[a]]);\n        }\n      }\n      return i;\n    },\n    ht = {\n      successCallback: null,\n      verbose: !1\n    },\n    pt = {};\n  /**\n       * @license GNU Affero General Public License.\n       * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>\n       * v. 1.2.0\n       * https://github.com/RaumZeit/MarchingSquares.js\n       *\n       * MarchingSquaresJS is free software: you can redistribute it and/or modify\n       * it under the terms of the GNU Affero General Public License as published by\n       * the Free Software Foundation, either version 3 of the License, or\n       * (at your option) any later version.\n       *\n       * MarchingSquaresJS is distributed in the hope that it will be useful,\n       * but WITHOUT ANY WARRANTY; without even the implied warranty of\n       * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n       * GNU Affero General Public License for more details.\n       *\n       * As additional permission under GNU Affero General Public License version 3\n       * section 7, third-party projects (personal or commercial) may distribute,\n       * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the\n       * requirement that said third-party project for that reason alone becomes\n       * subject to any requirement of the GNU Affero General Public License version 3.\n       * Any modifications to MarchingSquaresJS, however, must be shared with the public\n       * and made available.\n       *\n       * In summary this:\n       * - allows you to use MarchingSquaresJS at no cost\n       * - allows you to use MarchingSquaresJS for both personal and commercial purposes\n       * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any\n       *   license as long as this license notice is included\n       * - enables you to keep the source code of your program that uses MarchingSquaresJS\n       *   undisclosed\n       * - forces you to share any modifications you have made to MarchingSquaresJS,\n       *   e.g. bug-fixes\n       *\n       * You should have received a copy of the GNU Affero General Public License\n       * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.\n       */\n  function ft(t, e, n) {\n    n = n || {};\n    for (var r = Object.keys(ht), i = 0; i < r.length; i++) {\n      var o = r[i],\n        s = n[o];\n      s = null != s ? s : ht[o], pt[o] = s;\n    }\n    pt.verbose && console.log(\"MarchingSquaresJS-isoContours: computing isocontour for \" + e);\n    var a = function (t) {\n      var e = [],\n        n = 0,\n        r = 1e-7;\n      return t.cells.forEach(function (i, o) {\n        i.forEach(function (i, s) {\n          if (void 0 !== i && 5 !== (f = i).cval && 10 !== f.cval && !dt(i)) {\n            var a = function (t, e, n) {\n                var r,\n                  i,\n                  o = t.length,\n                  s = [],\n                  a = [0, 0, 1, 1, 0, 0, 0, 0, -1, 0, 1, 1, -1, 0, -1, 0],\n                  u = [0, -1, 0, 0, 1, 1, 1, 1, 0, -1, 0, 0, 0, -1, 0, 0],\n                  l = [\"none\", \"left\", \"bottom\", \"left\", \"right\", \"none\", \"bottom\", \"left\", \"top\", \"top\", \"none\", \"top\", \"right\", \"right\", \"bottom\", \"none\"],\n                  c = [\"none\", \"bottom\", \"right\", \"right\", \"top\", \"top\", \"top\", \"top\", \"left\", \"bottom\", \"right\", \"right\", \"left\", \"bottom\", \"left\", \"none\"],\n                  h = t[e][n],\n                  p = h.cval,\n                  f = l[p],\n                  g = vt(h, f);\n                s.push([n + g[0], e + g[1]]), f = c[p], g = vt(h, f), s.push([n + g[0], e + g[1]]), yt(h);\n                var d = n + a[p],\n                  y = e + u[p],\n                  v = p;\n                for (; d >= 0 && y >= 0 && y < o && (d != n || y != e) && void 0 !== (h = t[y][d]);) {\n                  if (0 === (p = h.cval) || 15 === p) return {\n                    path: s,\n                    info: \"mergeable\"\n                  };\n                  f = c[p], r = a[p], i = u[p], 5 !== p && 10 !== p || (5 === p ? h.flipped ? -1 === u[v] ? (f = \"left\", r = -1, i = 0) : (f = \"right\", r = 1, i = 0) : -1 === a[v] && (f = \"bottom\", r = 0, i = -1) : 10 === p && (h.flipped ? -1 === a[v] ? (f = \"top\", r = 0, i = 1) : (f = \"bottom\", r = 0, i = -1) : 1 === u[v] && (f = \"left\", r = -1, i = 0))), g = vt(h, f), s.push([d + g[0], y + g[1]]), yt(h), d += r, y += i, v = p;\n                }\n                return {\n                  path: s,\n                  info: \"closed\"\n                };\n              }(t.cells, o, s),\n              u = !1;\n            if (\"mergeable\" === a.info) for (var l = a.path[a.path.length - 1][0], c = a.path[a.path.length - 1][1], h = n - 1; h >= 0; h--) if (Math.abs(e[h][0][0] - l) <= r && Math.abs(e[h][0][1] - c) <= r) {\n              for (var p = a.path.length - 2; p >= 0; --p) e[h].unshift(a.path[p]);\n              u = !0;\n              break;\n            }\n            u || (e[n++] = a.path);\n          }\n          var f;\n        });\n      }), e;\n    }(function (t, e) {\n      for (var n = t.length - 1, r = t[0].length - 1, i = {\n          rows: n,\n          cols: r,\n          cells: []\n        }, o = 0; o < n; ++o) {\n        i.cells[o] = [];\n        for (var s = 0; s < r; ++s) {\n          var a = 0,\n            u = t[o + 1][s],\n            l = t[o + 1][s + 1],\n            c = t[o][s + 1],\n            h = t[o][s];\n          if (!(isNaN(u) || isNaN(l) || isNaN(c) || isNaN(h))) {\n            a |= u >= e ? 8 : 0, a |= l >= e ? 4 : 0, a |= c >= e ? 2 : 0;\n            var p,\n              f,\n              g,\n              d,\n              y = !1;\n            if (5 === (a |= h >= e ? 1 : 0) || 10 === a) {\n              var v = (u + l + c + h) / 4;\n              5 === a && v < e ? (a = 10, y = !0) : 10 === a && v < e && (a = 5, y = !0);\n            }\n            if (0 !== a && 15 !== a) p = f = g = d = .5, 1 === a ? (g = 1 - gt(e, u, h), f = 1 - gt(e, c, h)) : 2 === a ? (f = gt(e, h, c), d = 1 - gt(e, l, c)) : 3 === a ? (g = 1 - gt(e, u, h), d = 1 - gt(e, l, c)) : 4 === a ? (p = gt(e, u, l), d = gt(e, c, l)) : 5 === a ? (p = gt(e, u, l), d = gt(e, c, l), f = 1 - gt(e, c, h), g = 1 - gt(e, u, h)) : 6 === a ? (f = gt(e, h, c), p = gt(e, u, l)) : 7 === a ? (g = 1 - gt(e, u, h), p = gt(e, u, l)) : 8 === a ? (g = gt(e, h, u), p = 1 - gt(e, l, u)) : 9 === a ? (f = 1 - gt(e, c, h), p = 1 - gt(e, l, u)) : 10 === a ? (p = 1 - gt(e, l, u), d = 1 - gt(e, l, c), f = gt(e, h, c), g = gt(e, h, u)) : 11 === a ? (p = 1 - gt(e, l, u), d = 1 - gt(e, l, c)) : 12 === a ? (g = gt(e, h, u), d = gt(e, c, l)) : 13 === a ? (f = 1 - gt(e, c, h), d = gt(e, c, l)) : 14 === a ? (g = gt(e, h, u), f = gt(e, h, c)) : console.log(\"MarchingSquaresJS-isoContours: Illegal cval detected: \" + a), i.cells[o][s] = {\n              cval: a,\n              flipped: y,\n              top: p,\n              right: d,\n              bottom: f,\n              left: g\n            };\n          }\n        }\n      }\n      return i;\n    }(t, e));\n    return \"function\" == typeof pt.successCallback && pt.successCallback(a), a;\n  }\n  function gt(t, e, n) {\n    return (t - e) / (n - e);\n  }\n  function dt(t) {\n    return 0 === t.cval || 15 === t.cval;\n  }\n  function yt(t) {\n    dt(t) || 5 === t.cval || 10 === t.cval || (t.cval = 15);\n  }\n  function vt(t, e) {\n    return \"top\" === e ? [t.top, 1] : \"bottom\" === e ? [t.bottom, 0] : \"right\" === e ? [1, t.right] : \"left\" === e ? [0, t.left] : void 0;\n  }\n  function _t(t, e) {\n    if (!P(e = e || {})) throw new Error(\"options is invalid\");\n    var n = e.zProperty || \"elevation\",\n      r = e.flip,\n      i = e.flags;\n    nt(t, \"Point\", \"input must contain Points\");\n    for (var o = function (t, e) {\n        var n = {};\n        return F(t, function (t) {\n          var e = Q(t)[1];\n          n[e] || (n[e] = []), n[e].push(t);\n        }), Object.keys(n).map(function (t) {\n          return n[t].sort(function (t, e) {\n            return Q(t)[0] - Q(e)[0];\n          });\n        }).sort(function (t, n) {\n          return e ? Q(t[0])[1] - Q(n[0])[1] : Q(n[0])[1] - Q(t[0])[1];\n        });\n      }(t, r), s = [], a = 0; a < o.length; a++) {\n      for (var u = o[a], l = [], c = 0; c < u.length; c++) {\n        var h = u[c];\n        h.properties[n] ? l.push(h.properties[n]) : l.push(0), !0 === i && (h.properties.matrixPosition = [a, c]);\n      }\n      s.push(l);\n    }\n    return s;\n  }\n  var mt = Et,\n    xt = Et;\n  function Et(t, e, n, r, i) {\n    bt(t, e, n || 0, r || t.length - 1, i || It);\n  }\n  function bt(t, e, n, r, i) {\n    for (; r > n;) {\n      if (r - n > 600) {\n        var o = r - n + 1,\n          s = e - n + 1,\n          a = Math.log(o),\n          u = .5 * Math.exp(2 * a / 3),\n          l = .5 * Math.sqrt(a * u * (o - u) / o) * (s - o / 2 < 0 ? -1 : 1);\n        bt(t, e, Math.max(n, Math.floor(e - s * u / o + l)), Math.min(r, Math.floor(e + (o - s) * u / o + l)), i);\n      }\n      var c = t[e],\n        h = n,\n        p = r;\n      for (wt(t, n, e), i(t[r], c) > 0 && wt(t, n, r); h < p;) {\n        for (wt(t, h, p), h++, p--; i(t[h], c) < 0;) h++;\n        for (; i(t[p], c) > 0;) p--;\n      }\n      0 === i(t[n], c) ? wt(t, n, p) : wt(t, ++p, r), p <= e && (n = p + 1), e <= p && (r = p - 1);\n    }\n  }\n  function wt(t, e, n) {\n    var r = t[e];\n    t[e] = t[n], t[n] = r;\n  }\n  function It(t, e) {\n    return t < e ? -1 : t > e ? 1 : 0;\n  }\n  mt.default = xt;\n  var Nt = Ct,\n    St = Ct;\n  function Ct(t, e) {\n    if (!(this instanceof Ct)) return new Ct(t, e);\n    this._maxEntries = Math.max(4, t || 9), this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)), e && this._initFormat(e), this.clear();\n  }\n  function Pt(t, e, n) {\n    if (!n) return e.indexOf(t);\n    for (var r = 0; r < e.length; r++) if (n(t, e[r])) return r;\n    return -1;\n  }\n  function Mt(t, e) {\n    Lt(t, 0, t.children.length, e, t);\n  }\n  function Lt(t, e, n, r, i) {\n    i || (i = Gt(null)), i.minX = 1 / 0, i.minY = 1 / 0, i.maxX = -1 / 0, i.maxY = -1 / 0;\n    for (var o, s = e; s < n; s++) o = t.children[s], Ot(i, t.leaf ? r(o) : o);\n    return i;\n  }\n  function Ot(t, e) {\n    return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t;\n  }\n  function Rt(t, e) {\n    return t.minX - e.minX;\n  }\n  function Tt(t, e) {\n    return t.minY - e.minY;\n  }\n  function At(t) {\n    return (t.maxX - t.minX) * (t.maxY - t.minY);\n  }\n  function Dt(t) {\n    return t.maxX - t.minX + (t.maxY - t.minY);\n  }\n  function Ft(t, e) {\n    return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY;\n  }\n  function kt(t, e) {\n    return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY;\n  }\n  function Gt(t) {\n    return {\n      children: t,\n      height: 1,\n      leaf: !0,\n      minX: 1 / 0,\n      minY: 1 / 0,\n      maxX: -1 / 0,\n      maxY: -1 / 0\n    };\n  }\n  function qt(t, e, n, r, i) {\n    for (var o, s = [e, n]; s.length;) (n = s.pop()) - (e = s.pop()) <= r || (o = e + Math.ceil((n - e) / r / 2) * r, mt(t, o, e, n, i), s.push(e, o, o, n));\n  }\n  function Bt(t) {\n    var e = {\n      exports: {}\n    };\n    return t(e, e.exports), e.exports;\n  }\n  Ct.prototype = {\n    all: function all() {\n      return this._all(this.data, []);\n    },\n    search: function search(t) {\n      var e = this.data,\n        n = [],\n        r = this.toBBox;\n      if (!kt(t, e)) return n;\n      for (var i, o, s, a, u = []; e;) {\n        for (i = 0, o = e.children.length; i < o; i++) s = e.children[i], kt(t, a = e.leaf ? r(s) : s) && (e.leaf ? n.push(s) : Ft(t, a) ? this._all(s, n) : u.push(s));\n        e = u.pop();\n      }\n      return n;\n    },\n    collides: function collides(t) {\n      var e = this.data,\n        n = this.toBBox;\n      if (!kt(t, e)) return !1;\n      for (var r, i, o, s, a = []; e;) {\n        for (r = 0, i = e.children.length; r < i; r++) if (o = e.children[r], kt(t, s = e.leaf ? n(o) : o)) {\n          if (e.leaf || Ft(t, s)) return !0;\n          a.push(o);\n        }\n        e = a.pop();\n      }\n      return !1;\n    },\n    load: function load(t) {\n      if (!t || !t.length) return this;\n      if (t.length < this._minEntries) {\n        for (var e = 0, n = t.length; e < n; e++) this.insert(t[e]);\n        return this;\n      }\n      var r = this._build(t.slice(), 0, t.length - 1, 0);\n      if (this.data.children.length) {\n        if (this.data.height === r.height) this._splitRoot(this.data, r);else {\n          if (this.data.height < r.height) {\n            var i = this.data;\n            this.data = r, r = i;\n          }\n          this._insert(r, this.data.height - r.height - 1, !0);\n        }\n      } else this.data = r;\n      return this;\n    },\n    insert: function insert(t) {\n      return t && this._insert(t, this.data.height - 1), this;\n    },\n    clear: function clear() {\n      return this.data = Gt([]), this;\n    },\n    remove: function remove(t, e) {\n      if (!t) return this;\n      for (var n, r, i, o, s = this.data, a = this.toBBox(t), u = [], l = []; s || u.length;) {\n        if (s || (s = u.pop(), r = u[u.length - 1], n = l.pop(), o = !0), s.leaf && -1 !== (i = Pt(t, s.children, e))) return s.children.splice(i, 1), u.push(s), this._condense(u), this;\n        o || s.leaf || !Ft(s, a) ? r ? (n++, s = r.children[n], o = !1) : s = null : (u.push(s), l.push(n), n = 0, r = s, s = s.children[0]);\n      }\n      return this;\n    },\n    toBBox: function toBBox(t) {\n      return t;\n    },\n    compareMinX: Rt,\n    compareMinY: Tt,\n    toJSON: function toJSON() {\n      return this.data;\n    },\n    fromJSON: function fromJSON(t) {\n      return this.data = t, this;\n    },\n    _all: function _all(t, e) {\n      for (var n = []; t;) t.leaf ? e.push.apply(e, t.children) : n.push.apply(n, t.children), t = n.pop();\n      return e;\n    },\n    _build: function _build(t, e, n, r) {\n      var i,\n        o = n - e + 1,\n        s = this._maxEntries;\n      if (o <= s) return Mt(i = Gt(t.slice(e, n + 1)), this.toBBox), i;\n      r || (r = Math.ceil(Math.log(o) / Math.log(s)), s = Math.ceil(o / Math.pow(s, r - 1))), (i = Gt([])).leaf = !1, i.height = r;\n      var a,\n        u,\n        l,\n        c,\n        h = Math.ceil(o / s),\n        p = h * Math.ceil(Math.sqrt(s));\n      for (qt(t, e, n, p, this.compareMinX), a = e; a <= n; a += p) for (qt(t, a, l = Math.min(a + p - 1, n), h, this.compareMinY), u = a; u <= l; u += h) c = Math.min(u + h - 1, l), i.children.push(this._build(t, u, c, r - 1));\n      return Mt(i, this.toBBox), i;\n    },\n    _chooseSubtree: function _chooseSubtree(t, e, n, r) {\n      for (var i, o, s, a, u, l, c, h, p, f; r.push(e), !e.leaf && r.length - 1 !== n;) {\n        for (c = h = 1 / 0, i = 0, o = e.children.length; i < o; i++) u = At(s = e.children[i]), p = t, f = s, (l = (Math.max(f.maxX, p.maxX) - Math.min(f.minX, p.minX)) * (Math.max(f.maxY, p.maxY) - Math.min(f.minY, p.minY)) - u) < h ? (h = l, c = u < c ? u : c, a = s) : l === h && u < c && (c = u, a = s);\n        e = a || e.children[0];\n      }\n      return e;\n    },\n    _insert: function _insert(t, e, n) {\n      var r = this.toBBox,\n        i = n ? t : r(t),\n        o = [],\n        s = this._chooseSubtree(i, this.data, e, o);\n      for (s.children.push(t), Ot(s, i); e >= 0 && o[e].children.length > this._maxEntries;) this._split(o, e), e--;\n      this._adjustParentBBoxes(i, o, e);\n    },\n    _split: function _split(t, e) {\n      var n = t[e],\n        r = n.children.length,\n        i = this._minEntries;\n      this._chooseSplitAxis(n, i, r);\n      var o = this._chooseSplitIndex(n, i, r),\n        s = Gt(n.children.splice(o, n.children.length - o));\n      s.height = n.height, s.leaf = n.leaf, Mt(n, this.toBBox), Mt(s, this.toBBox), e ? t[e - 1].children.push(s) : this._splitRoot(n, s);\n    },\n    _splitRoot: function _splitRoot(t, e) {\n      this.data = Gt([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, Mt(this.data, this.toBBox);\n    },\n    _chooseSplitIndex: function _chooseSplitIndex(t, e, n) {\n      var r, i, o, s, a, u, l, c, h, p, f, g, d, y;\n      for (u = l = 1 / 0, r = e; r <= n - e; r++) i = Lt(t, 0, r, this.toBBox), o = Lt(t, r, n, this.toBBox), h = i, p = o, f = void 0, g = void 0, d = void 0, y = void 0, f = Math.max(h.minX, p.minX), g = Math.max(h.minY, p.minY), d = Math.min(h.maxX, p.maxX), y = Math.min(h.maxY, p.maxY), s = Math.max(0, d - f) * Math.max(0, y - g), a = At(i) + At(o), s < u ? (u = s, c = r, l = a < l ? a : l) : s === u && a < l && (l = a, c = r);\n      return c;\n    },\n    _chooseSplitAxis: function _chooseSplitAxis(t, e, n) {\n      var r = t.leaf ? this.compareMinX : Rt,\n        i = t.leaf ? this.compareMinY : Tt;\n      this._allDistMargin(t, e, n, r) < this._allDistMargin(t, e, n, i) && t.children.sort(r);\n    },\n    _allDistMargin: function _allDistMargin(t, e, n, r) {\n      t.children.sort(r);\n      var i,\n        o,\n        s = this.toBBox,\n        a = Lt(t, 0, e, s),\n        u = Lt(t, n - e, n, s),\n        l = Dt(a) + Dt(u);\n      for (i = e; i < n - e; i++) o = t.children[i], Ot(a, t.leaf ? s(o) : o), l += Dt(a);\n      for (i = n - e - 1; i >= e; i--) o = t.children[i], Ot(u, t.leaf ? s(o) : o), l += Dt(u);\n      return l;\n    },\n    _adjustParentBBoxes: function _adjustParentBBoxes(t, e, n) {\n      for (var r = n; r >= 0; r--) Ot(e[r], t);\n    },\n    _condense: function _condense(t) {\n      for (var e, n = t.length - 1; n >= 0; n--) 0 === t[n].children.length ? n > 0 ? (e = t[n - 1].children).splice(e.indexOf(t[n]), 1) : this.clear() : Mt(t[n], this.toBBox);\n    },\n    _initFormat: function _initFormat(t) {\n      var e = [\"return a\", \" - b\", \";\"];\n      this.compareMinX = new Function(\"a\", \"b\", e.join(t[0])), this.compareMinY = new Function(\"a\", \"b\", e.join(t[1])), this.toBBox = new Function(\"a\", \"return {minX: a\" + t[0] + \", minY: a\" + t[1] + \", maxX: a\" + t[2] + \", maxY: a\" + t[3] + \"};\");\n    }\n  }, Nt.default = St;\n  var zt = function zt(t, e, n) {\n      var r = t * e,\n        i = jt * t,\n        o = i - (i - t),\n        s = t - o,\n        a = jt * e,\n        u = a - (a - e),\n        l = e - u,\n        c = s * l - (r - o * u - s * u - o * l);\n      if (n) return n[0] = c, n[1] = r, n;\n      return [c, r];\n    },\n    jt = +(Math.pow(2, 27) + 1);\n  var Ut = function Ut(t, e) {\n    var n = 0 | t.length,\n      r = 0 | e.length;\n    if (1 === n && 1 === r) return function (t, e) {\n      var n = t + e,\n        r = n - t,\n        i = t - (n - r) + (e - r);\n      if (i) return [i, n];\n      return [n];\n    }(t[0], e[0]);\n    var i,\n      o,\n      s = new Array(n + r),\n      a = 0,\n      u = 0,\n      l = 0,\n      c = Math.abs,\n      h = t[u],\n      p = c(h),\n      f = e[l],\n      g = c(f);\n    p < g ? (o = h, (u += 1) < n && (h = t[u], p = c(h))) : (o = f, (l += 1) < r && (f = e[l], g = c(f)));\n    u < n && p < g || l >= r ? (i = h, (u += 1) < n && (h = t[u], p = c(h))) : (i = f, (l += 1) < r && (f = e[l], g = c(f)));\n    var d,\n      y,\n      v = i + o,\n      _ = v - i,\n      m = o - _,\n      x = m,\n      E = v;\n    for (; u < n && l < r;) p < g ? (i = h, (u += 1) < n && (h = t[u], p = c(h))) : (i = f, (l += 1) < r && (f = e[l], g = c(f))), (m = (o = x) - (_ = (v = i + o) - i)) && (s[a++] = m), x = E - ((d = E + v) - (y = d - E)) + (v - y), E = d;\n    for (; u < n;) (m = (o = x) - (_ = (v = (i = h) + o) - i)) && (s[a++] = m), x = E - ((d = E + v) - (y = d - E)) + (v - y), E = d, (u += 1) < n && (h = t[u]);\n    for (; l < r;) (m = (o = x) - (_ = (v = (i = f) + o) - i)) && (s[a++] = m), x = E - ((d = E + v) - (y = d - E)) + (v - y), E = d, (l += 1) < r && (f = e[l]);\n    x && (s[a++] = x);\n    E && (s[a++] = E);\n    a || (s[a++] = 0);\n    return s.length = a, s;\n  };\n  var Vt = function Vt(t, e, n) {\n    var r = t + e,\n      i = r - t,\n      o = e - i,\n      s = t - (r - i);\n    if (n) return n[0] = s + o, n[1] = r, n;\n    return [s + o, r];\n  };\n  var Xt = function Xt(t, e) {\n    var n = t.length;\n    if (1 === n) {\n      var r = zt(t[0], e);\n      return r[0] ? r : [r[1]];\n    }\n    var i = new Array(2 * n),\n      o = [.1, .1],\n      s = [.1, .1],\n      a = 0;\n    zt(t[0], e, o), o[0] && (i[a++] = o[0]);\n    for (var u = 1; u < n; ++u) {\n      zt(t[u], e, s);\n      var l = o[1];\n      Vt(l, s[0], o), o[0] && (i[a++] = o[0]);\n      var c = s[1],\n        h = o[1],\n        p = c + h,\n        f = h - (p - c);\n      o[1] = p, f && (i[a++] = f);\n    }\n    o[1] && (i[a++] = o[1]);\n    0 === a && (i[a++] = 0);\n    return i.length = a, i;\n  };\n  var Yt = function Yt(t, e) {\n    var n = 0 | t.length,\n      r = 0 | e.length;\n    if (1 === n && 1 === r) return function (t, e) {\n      var n = t + e,\n        r = n - t,\n        i = t - (n - r) + (e - r);\n      if (i) return [i, n];\n      return [n];\n    }(t[0], -e[0]);\n    var i,\n      o,\n      s = new Array(n + r),\n      a = 0,\n      u = 0,\n      l = 0,\n      c = Math.abs,\n      h = t[u],\n      p = c(h),\n      f = -e[l],\n      g = c(f);\n    p < g ? (o = h, (u += 1) < n && (h = t[u], p = c(h))) : (o = f, (l += 1) < r && (f = -e[l], g = c(f)));\n    u < n && p < g || l >= r ? (i = h, (u += 1) < n && (h = t[u], p = c(h))) : (i = f, (l += 1) < r && (f = -e[l], g = c(f)));\n    var d,\n      y,\n      v = i + o,\n      _ = v - i,\n      m = o - _,\n      x = m,\n      E = v;\n    for (; u < n && l < r;) p < g ? (i = h, (u += 1) < n && (h = t[u], p = c(h))) : (i = f, (l += 1) < r && (f = -e[l], g = c(f))), (m = (o = x) - (_ = (v = i + o) - i)) && (s[a++] = m), x = E - ((d = E + v) - (y = d - E)) + (v - y), E = d;\n    for (; u < n;) (m = (o = x) - (_ = (v = (i = h) + o) - i)) && (s[a++] = m), x = E - ((d = E + v) - (y = d - E)) + (v - y), E = d, (u += 1) < n && (h = t[u]);\n    for (; l < r;) (m = (o = x) - (_ = (v = (i = f) + o) - i)) && (s[a++] = m), x = E - ((d = E + v) - (y = d - E)) + (v - y), E = d, (l += 1) < r && (f = -e[l]);\n    x && (s[a++] = x);\n    E && (s[a++] = E);\n    a || (s[a++] = 0);\n    return s.length = a, s;\n  };\n  var Ht = Bt(function (t) {\n      function e(t, e) {\n        for (var n = new Array(t.length - 1), r = 1; r < t.length; ++r) for (var i = n[r - 1] = new Array(t.length - 1), o = 0, s = 0; o < t.length; ++o) o !== e && (i[s++] = t[r][o]);\n        return n;\n      }\n      function n(t) {\n        if (1 === t.length) return t[0];\n        if (2 === t.length) return [\"sum(\", t[0], \",\", t[1], \")\"].join(\"\");\n        var e = t.length >> 1;\n        return [\"sum(\", n(t.slice(0, e)), \",\", n(t.slice(e)), \")\"].join(\"\");\n      }\n      function r(t) {\n        if (2 === t.length) return [[\"sum(prod(\", t[0][0], \",\", t[1][1], \"),prod(-\", t[0][1], \",\", t[1][0], \"))\"].join(\"\")];\n        for (var i = [], o = 0; o < t.length; ++o) i.push([\"scale(\", n(r(e(t, o))), \",\", (s = o, 1 & s ? \"-\" : \"\"), t[0][o], \")\"].join(\"\"));\n        return i;\n        var s;\n      }\n      function i(t) {\n        for (var i = [], o = [], s = function (t) {\n            for (var e = new Array(t), n = 0; n < t; ++n) {\n              e[n] = new Array(t);\n              for (var r = 0; r < t; ++r) e[n][r] = [\"m\", r, \"[\", t - n - 1, \"]\"].join(\"\");\n            }\n            return e;\n          }(t), a = [], u = 0; u < t; ++u) 0 == (1 & u) ? i.push.apply(i, r(e(s, u))) : o.push.apply(o, r(e(s, u))), a.push(\"m\" + u);\n        var l = n(i),\n          c = n(o),\n          h = \"orientation\" + t + \"Exact\",\n          p = [\"function \", h, \"(\", a.join(), \"){var p=\", l, \",n=\", c, \",d=sub(p,n);return d[d.length-1];};return \", h].join(\"\");\n        return new Function(\"sum\", \"prod\", \"scale\", \"sub\", p)(Ut, zt, Xt, Yt);\n      }\n      var o = i(3),\n        s = i(4),\n        a = [function () {\n          return 0;\n        }, function () {\n          return 0;\n        }, function (t, e) {\n          return e[0] - t[0];\n        }, function (t, e, n) {\n          var r,\n            i = (t[1] - n[1]) * (e[0] - n[0]),\n            s = (t[0] - n[0]) * (e[1] - n[1]),\n            a = i - s;\n          if (i > 0) {\n            if (s <= 0) return a;\n            r = i + s;\n          } else {\n            if (!(i < 0)) return a;\n            if (s >= 0) return a;\n            r = -(i + s);\n          }\n          var u = 33306690738754716e-32 * r;\n          return a >= u || a <= -u ? a : o(t, e, n);\n        }, function (t, e, n, r) {\n          var i = t[0] - r[0],\n            o = e[0] - r[0],\n            a = n[0] - r[0],\n            u = t[1] - r[1],\n            l = e[1] - r[1],\n            c = n[1] - r[1],\n            h = t[2] - r[2],\n            p = e[2] - r[2],\n            f = n[2] - r[2],\n            g = o * c,\n            d = a * l,\n            y = a * u,\n            v = i * c,\n            _ = i * l,\n            m = o * u,\n            x = h * (g - d) + p * (y - v) + f * (_ - m),\n            E = 7771561172376103e-31 * ((Math.abs(g) + Math.abs(d)) * Math.abs(h) + (Math.abs(y) + Math.abs(v)) * Math.abs(p) + (Math.abs(_) + Math.abs(m)) * Math.abs(f));\n          return x > E || -x > E ? x : s(t, e, n, r);\n        }];\n      function u(t) {\n        var e = a[t.length];\n        return e || (e = a[t.length] = i(t.length)), e.apply(void 0, t);\n      }\n      !function () {\n        for (; a.length <= 5;) a.push(i(a.length));\n        for (var e = [], n = [\"slow\"], r = 0; r <= 5; ++r) e.push(\"a\" + r), n.push(\"o\" + r);\n        var o = [\"function getOrientation(\", e.join(), \"){switch(arguments.length){case 0:case 1:return 0;\"];\n        for (r = 2; r <= 5; ++r) o.push(\"case \", r, \":return o\", r, \"(\", e.slice(0, r).join(), \");\");\n        o.push(\"}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i]};return slow(s);}return getOrientation\"), n.push(o.join(\"\"));\n        var s = Function.apply(void 0, n);\n        for (t.exports = s.apply(void 0, [u].concat(a)), r = 0; r <= 5; ++r) t.exports[r] = a[r];\n      }();\n    }),\n    Wt = function Wt(t) {\n      var e = t.length;\n      if (e < 3) {\n        for (var n = new Array(e), r = 0; r < e; ++r) n[r] = r;\n        return 2 === e && t[0][0] === t[1][0] && t[0][1] === t[1][1] ? [0] : n;\n      }\n      var i = new Array(e);\n      for (r = 0; r < e; ++r) i[r] = r;\n      i.sort(function (e, n) {\n        var r = t[e][0] - t[n][0];\n        return r || t[e][1] - t[n][1];\n      });\n      var o = [i[0], i[1]],\n        s = [i[0], i[1]];\n      for (r = 2; r < e; ++r) {\n        for (var a = i[r], u = t[a], l = o.length; l > 1 && Jt(t[o[l - 2]], t[o[l - 1]], u) <= 0;) l -= 1, o.pop();\n        for (o.push(a), l = s.length; l > 1 && Jt(t[s[l - 2]], t[s[l - 1]], u) >= 0;) l -= 1, s.pop();\n        s.push(a);\n      }\n      n = new Array(s.length + o.length - 2);\n      for (var c = 0, h = (r = 0, o.length); r < h; ++r) n[c++] = o[r];\n      for (var p = s.length - 2; p > 0; --p) n[c++] = s[p];\n      return n;\n    },\n    Jt = Ht[3];\n  var Zt = Qt,\n    Kt = Qt;\n  function Qt(t, e) {\n    if (!(this instanceof Qt)) return new Qt(t, e);\n    if (this.data = t || [], this.length = this.data.length, this.compare = e || $t, this.length > 0) for (var n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);\n  }\n  function $t(t, e) {\n    return t < e ? -1 : t > e ? 1 : 0;\n  }\n  Qt.prototype = {\n    push: function push(t) {\n      this.data.push(t), this.length++, this._up(this.length - 1);\n    },\n    pop: function pop() {\n      if (0 !== this.length) {\n        var t = this.data[0];\n        return this.length--, this.length > 0 && (this.data[0] = this.data[this.length], this._down(0)), this.data.pop(), t;\n      }\n    },\n    peek: function peek() {\n      return this.data[0];\n    },\n    _up: function _up(t) {\n      for (var e = this.data, n = this.compare, r = e[t]; t > 0;) {\n        var i = t - 1 >> 1,\n          o = e[i];\n        if (n(r, o) >= 0) break;\n        e[t] = o, t = i;\n      }\n      e[t] = r;\n    },\n    _down: function _down(t) {\n      for (var e = this.data, n = this.compare, r = this.length >> 1, i = e[t]; t < r;) {\n        var o = 1 + (t << 1),\n          s = o + 1,\n          a = e[o];\n        if (s < this.length && n(e[s], a) < 0 && (o = s, a = e[s]), n(a, i) >= 0) break;\n        e[t] = a, t = o;\n      }\n      e[t] = i;\n    }\n  }, Zt.default = Kt;\n  var te = function te(t, e) {\n      for (var n = t[0], r = t[1], i = !1, o = 0, s = e.length - 1; o < e.length; s = o++) {\n        var a = e[o][0],\n          u = e[o][1],\n          l = e[s][0],\n          c = e[s][1];\n        u > r != c > r && n < (l - a) * (r - u) / (c - u) + a && (i = !i);\n      }\n      return i;\n    },\n    ee = Ht[3],\n    ne = ie,\n    re = ie;\n  function ie(t, e, n) {\n    e = Math.max(0, void 0 === e ? 2 : e), n = n || 0;\n    for (var r, i = function (t) {\n        for (var e = t[0], n = t[0], r = t[0], i = t[0], o = 0; o < t.length; o++) {\n          var s = t[o];\n          s[0] < e[0] && (e = s), s[0] > r[0] && (r = s), s[1] < n[1] && (n = s), s[1] > i[1] && (i = s);\n        }\n        var a = [e, n, r, i],\n          u = a.slice();\n        for (o = 0; o < t.length; o++) te(t[o], a) || u.push(t[o]);\n        var l = Wt(u),\n          c = [];\n        for (o = 0; o < l.length; o++) c.push(u[l[o]]);\n        return c;\n      }(t), o = Nt(16, [\"[0]\", \"[1]\", \"[0]\", \"[1]\"]).load(t), s = [], a = 0; a < i.length; a++) {\n      var u = i[a];\n      o.remove(u), r = he(u, r), s.push(r);\n    }\n    var l = Nt(16);\n    for (a = 0; a < s.length; a++) l.insert(ce(s[a]));\n    for (var c = e * e, h = n * n; s.length;) {\n      var p = s.shift(),\n        f = p.p,\n        g = p.next.p,\n        d = pe(f, g);\n      if (!(d < h)) {\n        var y = d / c;\n        (u = oe(o, p.prev.p, f, g, p.next.next.p, y, l)) && Math.min(pe(u, f), pe(u, g)) <= y && (s.push(p), s.push(he(u, p)), o.remove(u), l.remove(p), l.insert(ce(p)), l.insert(ce(p.next)));\n      }\n    }\n    p = r;\n    var v = [];\n    do {\n      v.push(p.p), p = p.next;\n    } while (p !== r);\n    return v.push(p.p), v;\n  }\n  function oe(t, e, n, r, i, o, s) {\n    for (var a = new Zt(null, se), u = t.data; u;) {\n      for (var l = 0; l < u.children.length; l++) {\n        var c = u.children[l],\n          h = u.leaf ? fe(c, n, r) : ae(n, r, c);\n        h > o || a.push({\n          node: c,\n          dist: h\n        });\n      }\n      for (; a.length && !a.peek().node.children;) {\n        var p = a.pop(),\n          f = p.node,\n          g = fe(f, e, n),\n          d = fe(f, r, i);\n        if (p.dist < g && p.dist < d && le(n, f, s) && le(r, f, s)) return f;\n      }\n      (u = a.pop()) && (u = u.node);\n    }\n    return null;\n  }\n  function se(t, e) {\n    return t.dist - e.dist;\n  }\n  function ae(t, e, n) {\n    if (ue(t, n) || ue(e, n)) return 0;\n    var r = ge(t[0], t[1], e[0], e[1], n.minX, n.minY, n.maxX, n.minY);\n    if (0 === r) return 0;\n    var i = ge(t[0], t[1], e[0], e[1], n.minX, n.minY, n.minX, n.maxY);\n    if (0 === i) return 0;\n    var o = ge(t[0], t[1], e[0], e[1], n.maxX, n.minY, n.maxX, n.maxY);\n    if (0 === o) return 0;\n    var s = ge(t[0], t[1], e[0], e[1], n.minX, n.maxY, n.maxX, n.maxY);\n    return 0 === s ? 0 : Math.min(r, i, o, s);\n  }\n  function ue(t, e) {\n    return t[0] >= e.minX && t[0] <= e.maxX && t[1] >= e.minY && t[1] <= e.maxY;\n  }\n  function le(t, e, n) {\n    for (var r, i, o, s, a = Math.min(t[0], e[0]), u = Math.min(t[1], e[1]), l = Math.max(t[0], e[0]), c = Math.max(t[1], e[1]), h = n.search({\n        minX: a,\n        minY: u,\n        maxX: l,\n        maxY: c\n      }), p = 0; p < h.length; p++) if (r = h[p].p, i = h[p].next.p, o = t, r !== (s = e) && i !== o && ee(r, i, o) > 0 != ee(r, i, s) > 0 && ee(o, s, r) > 0 != ee(o, s, i) > 0) return !1;\n    return !0;\n  }\n  function ce(t) {\n    var e = t.p,\n      n = t.next.p;\n    return t.minX = Math.min(e[0], n[0]), t.minY = Math.min(e[1], n[1]), t.maxX = Math.max(e[0], n[0]), t.maxY = Math.max(e[1], n[1]), t;\n  }\n  function he(t, e) {\n    var n = {\n      p: t,\n      prev: null,\n      next: null,\n      minX: 0,\n      minY: 0,\n      maxX: 0,\n      maxY: 0\n    };\n    return e ? (n.next = e.next, n.prev = e, e.next.prev = n, e.next = n) : (n.prev = n, n.next = n), n;\n  }\n  function pe(t, e) {\n    var n = t[0] - e[0],\n      r = t[1] - e[1];\n    return n * n + r * r;\n  }\n  function fe(t, e, n) {\n    var r = e[0],\n      i = e[1],\n      o = n[0] - r,\n      s = n[1] - i;\n    if (0 !== o || 0 !== s) {\n      var a = ((t[0] - r) * o + (t[1] - i) * s) / (o * o + s * s);\n      a > 1 ? (r = n[0], i = n[1]) : a > 0 && (r += o * a, i += s * a);\n    }\n    return (o = t[0] - r) * o + (s = t[1] - i) * s;\n  }\n  function ge(t, e, n, r, i, o, s, a) {\n    var u,\n      l,\n      c,\n      h,\n      p = n - t,\n      f = r - e,\n      g = s - i,\n      d = a - o,\n      y = t - i,\n      v = e - o,\n      _ = p * p + f * f,\n      m = p * g + f * d,\n      x = g * g + d * d,\n      E = p * y + f * v,\n      b = g * y + d * v,\n      w = _ * x - m * m,\n      I = w,\n      N = w;\n    0 === w ? (l = 0, I = 1, h = b, N = x) : (h = _ * b - m * E, (l = m * b - x * E) < 0 ? (l = 0, h = b, N = x) : l > I && (l = I, h = b + m, N = x)), h < 0 ? (h = 0, -E < 0 ? l = 0 : -E > _ ? l = I : (l = -E, I = _)) : h > N && (h = N, -E + m < 0 ? l = 0 : -E + m > _ ? l = I : (l = -E + m, I = _));\n    var S = (1 - (c = 0 === h ? 0 : h / N)) * i + c * s - ((1 - (u = 0 === l ? 0 : l / I)) * t + u * n),\n      C = (1 - c) * o + c * a - ((1 - u) * e + u * r);\n    return S * S + C * C;\n  }\n  function de(t, e) {\n    void 0 === e && (e = {}), e.concavity = e.concavity || 1 / 0;\n    var n = [];\n    if (R(t, function (t) {\n      n.push([t[0], t[1]]);\n    }), !n.length) return null;\n    var r = ne(n, e.concavity);\n    return r.length > 3 ? l([r]) : null;\n  }\n  function ye(t, e, n) {\n    if (void 0 === n && (n = {}), !t) throw new Error(\"point is required\");\n    if (!e) throw new Error(\"polygon is required\");\n    var r = K(t),\n      i = rt(e),\n      o = i.type,\n      s = e.bbox,\n      a = i.coordinates;\n    if (s && !1 === function (t, e) {\n      return e[0] <= t[0] && e[1] <= t[1] && e[2] >= t[0] && e[3] >= t[1];\n    }(r, s)) return !1;\n    \"Polygon\" === o && (a = [a]);\n    for (var u = !1, l = 0; l < a.length && !u; l++) if (ve(r, a[l][0], n.ignoreBoundary)) {\n      for (var c = !1, h = 1; h < a[l].length && !c;) ve(r, a[l][h], !n.ignoreBoundary) && (c = !0), h++;\n      c || (u = !0);\n    }\n    return u;\n  }\n  function ve(t, e, n) {\n    var r = !1;\n    e[0][0] === e[e.length - 1][0] && e[0][1] === e[e.length - 1][1] && (e = e.slice(0, e.length - 1));\n    for (var i = 0, o = e.length - 1; i < e.length; o = i++) {\n      var s = e[i][0],\n        a = e[i][1],\n        u = e[o][0],\n        l = e[o][1];\n      if (t[1] * (s - u) + a * (u - t[0]) + l * (t[0] - s) == 0 && (s - t[0]) * (u - t[0]) <= 0 && (a - t[1]) * (l - t[1]) <= 0) return !n;\n      a > t[1] != l > t[1] && t[0] < (u - s) * (t[1] - a) / (l - a) + s && (r = !r);\n    }\n    return r;\n  }\n  function _e(t, e) {\n    var n = [];\n    return F(t, function (t) {\n      var r = !1;\n      if (\"Point\" === t.geometry.type) q(e, function (e) {\n        ye(t, e) && (r = !0);\n      }), r && n.push(t);else {\n        if (\"MultiPoint\" !== t.geometry.type) throw new Error(\"Input geometry must be a Point or MultiPoint\");\n        var i = [];\n        q(e, function (e) {\n          R(t, function (t) {\n            ye(t, e) && (r = !0, i.push(t));\n          });\n        }), r && n.push(d(i));\n      }\n    }), f(n);\n  }\n  function me(t, e, n) {\n    void 0 === n && (n = {});\n    var r = K(t),\n      i = K(e),\n      o = I(i[1] - r[1]),\n      s = I(i[0] - r[0]),\n      a = I(r[1]),\n      u = I(i[1]),\n      l = Math.pow(Math.sin(o / 2), 2) + Math.pow(Math.sin(s / 2), 2) * Math.cos(a) * Math.cos(u);\n    return m(2 * Math.atan2(Math.sqrt(l), Math.sqrt(1 - l)), n.units);\n  }\n  function xe(t, e) {\n    var n = !1;\n    return f(function (t) {\n      if (t.length < 3) return [];\n      t.sort(be);\n      var e,\n        n,\n        r,\n        i,\n        o,\n        s,\n        a = t.length - 1,\n        u = t[a].x,\n        l = t[0].x,\n        c = t[a].y,\n        h = c,\n        p = 1e-12;\n      for (; a--;) t[a].y < c && (c = t[a].y), t[a].y > h && (h = t[a].y);\n      var f,\n        g = l - u,\n        d = h - c,\n        y = g > d ? g : d,\n        v = .5 * (l + u),\n        _ = .5 * (h + c),\n        m = [new Ee({\n          __sentinel: !0,\n          x: v - 20 * y,\n          y: _ - y\n        }, {\n          __sentinel: !0,\n          x: v,\n          y: _ + 20 * y\n        }, {\n          __sentinel: !0,\n          x: v + 20 * y,\n          y: _ - y\n        })],\n        x = [],\n        E = [];\n      a = t.length;\n      for (; a--;) {\n        for (E.length = 0, f = m.length; f--;) (g = t[a].x - m[f].x) > 0 && g * g > m[f].r ? (x.push(m[f]), m.splice(f, 1)) : g * g + (d = t[a].y - m[f].y) * d > m[f].r || (E.push(m[f].a, m[f].b, m[f].b, m[f].c, m[f].c, m[f].a), m.splice(f, 1));\n        for (we(E), f = E.length; f;) n = E[--f], e = E[--f], r = t[a], i = n.x - e.x, o = n.y - e.y, s = 2 * (i * (r.y - n.y) - o * (r.x - n.x)), Math.abs(s) > p && m.push(new Ee(e, n, r));\n      }\n      Array.prototype.push.apply(x, m), a = x.length;\n      for (; a--;) (x[a].a.__sentinel || x[a].b.__sentinel || x[a].c.__sentinel) && x.splice(a, 1);\n      return x;\n    }(t.features.map(function (t) {\n      var r = {\n        x: t.geometry.coordinates[0],\n        y: t.geometry.coordinates[1]\n      };\n      return e ? r.z = t.properties[e] : 3 === t.geometry.coordinates.length && (n = !0, r.z = t.geometry.coordinates[2]), r;\n    })).map(function (t) {\n      var e = [t.a.x, t.a.y],\n        r = [t.b.x, t.b.y],\n        i = [t.c.x, t.c.y],\n        o = {};\n      return n ? (e.push(t.a.z), r.push(t.b.z), i.push(t.c.z)) : o = {\n        a: t.a.z,\n        b: t.b.z,\n        c: t.c.z\n      }, l([[e, r, i, e]], o);\n    }));\n  }\n  ne.default = re;\n  var Ee = function Ee(t, e, n) {\n    this.a = t, this.b = e, this.c = n;\n    var r,\n      i,\n      o = e.x - t.x,\n      s = e.y - t.y,\n      a = n.x - t.x,\n      u = n.y - t.y,\n      l = o * (t.x + e.x) + s * (t.y + e.y),\n      c = a * (t.x + n.x) + u * (t.y + n.y),\n      h = 2 * (o * (n.y - e.y) - s * (n.x - e.x));\n    this.x = (u * l - s * c) / h, this.y = (o * c - a * l) / h, r = this.x - t.x, i = this.y - t.y, this.r = r * r + i * i;\n  };\n  function be(t, e) {\n    return e.x - t.x;\n  }\n  function we(t) {\n    var e,\n      n,\n      r,\n      i,\n      o,\n      s = t.length;\n    t: for (; s;) for (n = t[--s], e = t[--s], r = s; r;) if (o = t[--r], e === (i = t[--r]) && n === o || e === o && n === i) {\n      t.splice(s, 2), t.splice(r, 2), s -= 2;\n      continue t;\n    }\n  }\n  function Ie(t) {\n    if (!t) throw new Error(\"geojson is required\");\n    switch (t.type) {\n      case \"Feature\":\n        return Ne(t);\n      case \"FeatureCollection\":\n        return function (t) {\n          var e = {\n            type: \"FeatureCollection\"\n          };\n          return Object.keys(t).forEach(function (n) {\n            switch (n) {\n              case \"type\":\n              case \"features\":\n                return;\n              default:\n                e[n] = t[n];\n            }\n          }), e.features = t.features.map(function (t) {\n            return Ne(t);\n          }), e;\n        }(t);\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n      case \"MultiPoint\":\n      case \"MultiLineString\":\n      case \"MultiPolygon\":\n      case \"GeometryCollection\":\n        return Ce(t);\n      default:\n        throw new Error(\"unknown GeoJSON type\");\n    }\n  }\n  function Ne(t) {\n    var e = {\n      type: \"Feature\"\n    };\n    return Object.keys(t).forEach(function (n) {\n      switch (n) {\n        case \"type\":\n        case \"properties\":\n        case \"geometry\":\n          return;\n        default:\n          e[n] = t[n];\n      }\n    }), e.properties = Se(t.properties), e.geometry = Ce(t.geometry), e;\n  }\n  function Se(t) {\n    var e = {};\n    return t ? (Object.keys(t).forEach(function (n) {\n      var r = t[n];\n      \"object\" == typeof r ? null === r ? e[n] = null : Array.isArray(r) ? e[n] = r.map(function (t) {\n        return t;\n      }) : e[n] = Se(r) : e[n] = r;\n    }), e) : e;\n  }\n  function Ce(t) {\n    var e = {\n      type: t.type\n    };\n    return t.bbox && (e.bbox = t.bbox), \"GeometryCollection\" === t.type ? (e.geometries = t.geometries.map(function (t) {\n      return Ce(t);\n    }), e) : (e.coordinates = Pe(t.coordinates), e);\n  }\n  function Pe(t) {\n    var e = t;\n    return \"object\" != typeof e[0] ? e.slice() : e.map(function (t) {\n      return Pe(t);\n    });\n  }\n  function Me(t, e) {\n    if (void 0 === e && (e = {}), !P(e = e || {})) throw new Error(\"options is invalid\");\n    var n = e.mutate;\n    if (\"FeatureCollection\" !== it(t)) throw new Error(\"geojson must be a FeatureCollection\");\n    if (!t.features.length) throw new Error(\"geojson is empty\");\n    !1 !== n && void 0 !== n || (t = Ie(t));\n    var r = [],\n      i = Y(t, function (t, e) {\n        var n = function (t, e) {\n          var n,\n            r = t.geometry.coordinates,\n            i = e.geometry.coordinates,\n            o = Le(r[0]),\n            s = Le(r[r.length - 1]),\n            a = Le(i[0]),\n            u = Le(i[i.length - 1]);\n          if (o === u) n = i.concat(r.slice(1));else if (a === s) n = r.concat(i.slice(1));else if (o === a) n = r.slice(1).reverse().concat(i);else {\n            if (s !== u) return null;\n            n = r.concat(i.reverse().slice(1));\n          }\n          return h(n);\n        }(t, e);\n        return n || (r.push(t), e);\n      });\n    return i && r.push(i), r.length ? 1 === r.length ? r[0] : g(r.map(function (t) {\n      return t.coordinates;\n    })) : null;\n  }\n  function Le(t) {\n    return t[0].toString() + \",\" + t[1].toString();\n  }\n  function Oe(t) {\n    return t;\n  }\n  function Re(t, e) {\n    var n = function (t) {\n        if (null == t) return Oe;\n        var e,\n          n,\n          r = t.scale[0],\n          i = t.scale[1],\n          o = t.translate[0],\n          s = t.translate[1];\n        return function (t, a) {\n          a || (e = n = 0);\n          var u = 2,\n            l = t.length,\n            c = new Array(l);\n          for (c[0] = (e += t[0]) * r + o, c[1] = (n += t[1]) * i + s; u < l;) c[u] = t[u], ++u;\n          return c;\n        };\n      }(t.transform),\n      r = t.arcs;\n    function i(t, e) {\n      e.length && e.pop();\n      for (var i = r[t < 0 ? ~t : t], o = 0, s = i.length; o < s; ++o) e.push(n(i[o], o));\n      t < 0 && function (t, e) {\n        for (var n, r = t.length, i = r - e; i < --r;) n = t[i], t[i++] = t[r], t[r] = n;\n      }(e, s);\n    }\n    function o(t) {\n      return n(t);\n    }\n    function s(t) {\n      for (var e = [], n = 0, r = t.length; n < r; ++n) i(t[n], e);\n      return e.length < 2 && e.push(e[0]), e;\n    }\n    function a(t) {\n      for (var e = s(t); e.length < 4;) e.push(e[0]);\n      return e;\n    }\n    function u(t) {\n      return t.map(a);\n    }\n    return function t(e) {\n      var n,\n        r = e.type;\n      switch (r) {\n        case \"GeometryCollection\":\n          return {\n            type: r,\n            geometries: e.geometries.map(t)\n          };\n        case \"Point\":\n          n = o(e.coordinates);\n          break;\n        case \"MultiPoint\":\n          n = e.coordinates.map(o);\n          break;\n        case \"LineString\":\n          n = s(e.arcs);\n          break;\n        case \"MultiLineString\":\n          n = e.arcs.map(s);\n          break;\n        case \"Polygon\":\n          n = u(e.arcs);\n          break;\n        case \"MultiPolygon\":\n          n = e.arcs.map(u);\n          break;\n        default:\n          return null;\n      }\n      return {\n        type: r,\n        coordinates: n\n      };\n    }(e);\n  }\n  function Te(t, e) {\n    var n = {},\n      r = {},\n      i = {},\n      o = [],\n      s = -1;\n    function a(t, e) {\n      for (var r in t) {\n        var i = t[r];\n        delete e[i.start], delete i.start, delete i.end, i.forEach(function (t) {\n          n[t < 0 ? ~t : t] = 1;\n        }), o.push(i);\n      }\n    }\n    return e.forEach(function (n, r) {\n      var i,\n        o = t.arcs[n < 0 ? ~n : n];\n      o.length < 3 && !o[1][0] && !o[1][1] && (i = e[++s], e[s] = n, e[r] = i);\n    }), e.forEach(function (e) {\n      var n,\n        o,\n        s = function (e) {\n          var n,\n            r = t.arcs[e < 0 ? ~e : e],\n            i = r[0];\n          t.transform ? (n = [0, 0], r.forEach(function (t) {\n            n[0] += t[0], n[1] += t[1];\n          })) : n = r[r.length - 1];\n          return e < 0 ? [n, i] : [i, n];\n        }(e),\n        a = s[0],\n        u = s[1];\n      if (n = i[a]) {\n        if (delete i[n.end], n.push(e), n.end = u, o = r[u]) {\n          delete r[o.start];\n          var l = o === n ? n : n.concat(o);\n          r[l.start = n.start] = i[l.end = o.end] = l;\n        } else r[n.start] = i[n.end] = n;\n      } else if (n = r[u]) {\n        if (delete r[n.start], n.unshift(e), n.start = a, o = i[a]) {\n          delete i[o.end];\n          var c = o === n ? n : o.concat(n);\n          r[c.start = o.start] = i[c.end = n.end] = c;\n        } else r[n.start] = i[n.end] = n;\n      } else r[(n = [e]).start = a] = i[n.end = u] = n;\n    }), a(i, r), a(r, i), e.forEach(function (t) {\n      n[t < 0 ? ~t : t] || o.push([t]);\n    }), o;\n  }\n  function Ae(t, e) {\n    var n = {},\n      r = [],\n      i = [];\n    function o(t) {\n      t.forEach(function (e) {\n        e.forEach(function (e) {\n          (n[e = e < 0 ? ~e : e] || (n[e] = [])).push(t);\n        });\n      }), r.push(t);\n    }\n    function s(e) {\n      return function (t) {\n        for (var e, n = -1, r = t.length, i = t[r - 1], o = 0; ++n < r;) e = i, i = t[n], o += e[0] * i[1] - e[1] * i[0];\n        return Math.abs(o);\n      }(Re(t, {\n        type: \"Polygon\",\n        arcs: [e]\n      }).coordinates[0]);\n    }\n    return e.forEach(function t(e) {\n      switch (e.type) {\n        case \"GeometryCollection\":\n          e.geometries.forEach(t);\n          break;\n        case \"Polygon\":\n          o(e.arcs);\n          break;\n        case \"MultiPolygon\":\n          e.arcs.forEach(o);\n      }\n    }), r.forEach(function (t) {\n      if (!t._) {\n        var e = [],\n          r = [t];\n        for (t._ = 1, i.push(e); t = r.pop();) e.push(t), t.forEach(function (t) {\n          t.forEach(function (t) {\n            n[t < 0 ? ~t : t].forEach(function (t) {\n              t._ || (t._ = 1, r.push(t));\n            });\n          });\n        });\n      }\n    }), r.forEach(function (t) {\n      delete t._;\n    }), {\n      type: \"MultiPolygon\",\n      arcs: i.map(function (e) {\n        var r,\n          i = [];\n        if (e.forEach(function (t) {\n          t.forEach(function (t) {\n            t.forEach(function (t) {\n              n[t < 0 ? ~t : t].length < 2 && i.push(t);\n            });\n          });\n        }), (r = (i = Te(t, i)).length) > 1) for (var o, a, u = 1, l = s(i[0]); u < r; ++u) (o = s(i[u])) > l && (a = i[0], i[0] = i[u], i[u] = a, l = o);\n        return i;\n      }).filter(function (t) {\n        return t.length > 0;\n      })\n    };\n  }\n  var De = Object.prototype.hasOwnProperty;\n  function Fe(t, e, n, r, i, o) {\n    3 === arguments.length && (r = o = Array, i = null);\n    for (var s = new r(t = 1 << Math.max(4, Math.ceil(Math.log(t) / Math.LN2))), a = new o(t), u = t - 1, l = 0; l < t; ++l) s[l] = i;\n    function c(r, o) {\n      for (var l = e(r) & u, c = s[l], h = 0; c != i;) {\n        if (n(c, r)) return a[l] = o;\n        if (++h >= t) throw new Error(\"full hashmap\");\n        c = s[l = l + 1 & u];\n      }\n      return s[l] = r, a[l] = o, o;\n    }\n    function h(r, o) {\n      for (var l = e(r) & u, c = s[l], h = 0; c != i;) {\n        if (n(c, r)) return a[l];\n        if (++h >= t) throw new Error(\"full hashmap\");\n        c = s[l = l + 1 & u];\n      }\n      return s[l] = r, a[l] = o, o;\n    }\n    function p(r, o) {\n      for (var l = e(r) & u, c = s[l], h = 0; c != i;) {\n        if (n(c, r)) return a[l];\n        if (++h >= t) break;\n        c = s[l = l + 1 & u];\n      }\n      return o;\n    }\n    function f() {\n      for (var t = [], e = 0, n = s.length; e < n; ++e) {\n        var r = s[e];\n        r != i && t.push(r);\n      }\n      return t;\n    }\n    return {\n      set: c,\n      maybeSet: h,\n      get: p,\n      keys: f\n    };\n  }\n  function ke(t, e) {\n    return t[0] === e[0] && t[1] === e[1];\n  }\n  var Ge = new ArrayBuffer(16),\n    qe = new Float64Array(Ge),\n    Be = new Uint32Array(Ge);\n  function ze(t) {\n    qe[0] = t[0], qe[1] = t[1];\n    var e = Be[0] ^ Be[1];\n    return 2147483647 & (e = e << 5 ^ e >> 7 ^ Be[2] ^ Be[3]);\n  }\n  function je(t) {\n    var e,\n      n,\n      r,\n      i,\n      o = t.coordinates,\n      s = t.lines,\n      a = t.rings,\n      u = function () {\n        for (var t = Fe(1.4 * o.length, E, b, Int32Array, -1, Int32Array), e = new Int32Array(o.length), n = 0, r = o.length; n < r; ++n) e[n] = t.maybeSet(n, n);\n        return e;\n      }(),\n      l = new Int32Array(o.length),\n      c = new Int32Array(o.length),\n      h = new Int32Array(o.length),\n      p = new Int8Array(o.length),\n      f = 0;\n    for (e = 0, n = o.length; e < n; ++e) l[e] = c[e] = h[e] = -1;\n    for (e = 0, n = s.length; e < n; ++e) {\n      var g = s[e],\n        d = g[0],\n        y = g[1];\n      for (r = u[d], i = u[++d], ++f, p[r] = 1; ++d <= y;) x(e, r, r = i, i = u[d]);\n      ++f, p[i] = 1;\n    }\n    for (e = 0, n = o.length; e < n; ++e) l[e] = -1;\n    for (e = 0, n = a.length; e < n; ++e) {\n      var v = a[e],\n        _ = v[0] + 1,\n        m = v[1];\n      for (x(e, u[m - 1], r = u[_ - 1], i = u[_]); ++_ <= m;) x(e, r, r = i, i = u[_]);\n    }\n    function x(t, e, n, r) {\n      if (l[n] !== t) {\n        l[n] = t;\n        var i = c[n];\n        if (i >= 0) {\n          var o = h[n];\n          i === e && o === r || i === r && o === e || (++f, p[n] = 1);\n        } else c[n] = e, h[n] = r;\n      }\n    }\n    function E(t) {\n      return ze(o[t]);\n    }\n    function b(t, e) {\n      return ke(o[t], o[e]);\n    }\n    l = c = h = null;\n    var w,\n      I = function (t, e, n, r, i) {\n        3 === arguments.length && (r = Array, i = null);\n        for (var o = new r(t = 1 << Math.max(4, Math.ceil(Math.log(t) / Math.LN2))), s = t - 1, a = 0; a < t; ++a) o[a] = i;\n        function u(r) {\n          for (var a = e(r) & s, u = o[a], l = 0; u != i;) {\n            if (n(u, r)) return !0;\n            if (++l >= t) throw new Error(\"full hashset\");\n            u = o[a = a + 1 & s];\n          }\n          return o[a] = r, !0;\n        }\n        function l(r) {\n          for (var a = e(r) & s, u = o[a], l = 0; u != i;) {\n            if (n(u, r)) return !0;\n            if (++l >= t) break;\n            u = o[a = a + 1 & s];\n          }\n          return !1;\n        }\n        function c() {\n          for (var t = [], e = 0, n = o.length; e < n; ++e) {\n            var r = o[e];\n            r != i && t.push(r);\n          }\n          return t;\n        }\n        return {\n          add: u,\n          has: l,\n          values: c\n        };\n      }(1.4 * f, ze, ke);\n    for (e = 0, n = o.length; e < n; ++e) p[w = u[e]] && I.add(o[w]);\n    return I;\n  }\n  function Ue(t, e, n, r) {\n    Ve(t, e, n), Ve(t, e, e + r), Ve(t, e + r, n);\n  }\n  function Ve(t, e, n) {\n    for (var r, i = e + (n-- - e >> 1); e < i; ++e, --n) r = t[e], t[e] = t[n], t[n] = r;\n  }\n  function Xe(t) {\n    var e,\n      n,\n      r = {};\n    for (e in t) r[e] = null == (n = t[e]) ? {\n      type: null\n    } : (\"FeatureCollection\" === n.type ? Ye : \"Feature\" === n.type ? He : We)(n);\n    return r;\n  }\n  function Ye(t) {\n    var e = {\n      type: \"GeometryCollection\",\n      geometries: t.features.map(He)\n    };\n    return null != t.bbox && (e.bbox = t.bbox), e;\n  }\n  function He(t) {\n    var e,\n      n = We(t.geometry);\n    for (e in null != t.id && (n.id = t.id), null != t.bbox && (n.bbox = t.bbox), t.properties) {\n      n.properties = t.properties;\n      break;\n    }\n    return n;\n  }\n  function We(t) {\n    if (null == t) return {\n      type: null\n    };\n    var e = \"GeometryCollection\" === t.type ? {\n      type: \"GeometryCollection\",\n      geometries: t.geometries.map(We)\n    } : \"Point\" === t.type || \"MultiPoint\" === t.type ? {\n      type: t.type,\n      coordinates: t.coordinates\n    } : {\n      type: t.type,\n      arcs: t.coordinates\n    };\n    return null != t.bbox && (e.bbox = t.bbox), e;\n  }\n  function Je(t, e) {\n    var n = function (t) {\n        var e = 1 / 0,\n          n = 1 / 0,\n          r = -1 / 0,\n          i = -1 / 0;\n        function o(t) {\n          null != t && De.call(s, t.type) && s[t.type](t);\n        }\n        var s = {\n          GeometryCollection: function GeometryCollection(t) {\n            t.geometries.forEach(o);\n          },\n          Point: function Point(t) {\n            a(t.coordinates);\n          },\n          MultiPoint: function MultiPoint(t) {\n            t.coordinates.forEach(a);\n          },\n          LineString: function LineString(t) {\n            u(t.arcs);\n          },\n          MultiLineString: function MultiLineString(t) {\n            t.arcs.forEach(u);\n          },\n          Polygon: function Polygon(t) {\n            t.arcs.forEach(u);\n          },\n          MultiPolygon: function MultiPolygon(t) {\n            t.arcs.forEach(l);\n          }\n        };\n        function a(t) {\n          var o = t[0],\n            s = t[1];\n          o < e && (e = o), o > r && (r = o), s < n && (n = s), s > i && (i = s);\n        }\n        function u(t) {\n          t.forEach(a);\n        }\n        function l(t) {\n          t.forEach(u);\n        }\n        for (var c in t) o(t[c]);\n        return r >= e && i >= n ? [e, n, r, i] : void 0;\n      }(t = Xe(t)),\n      r = e > 0 && n && function (t, e, n) {\n        var r = e[0],\n          i = e[1],\n          o = e[2],\n          s = e[3],\n          a = o - r ? (n - 1) / (o - r) : 1,\n          u = s - i ? (n - 1) / (s - i) : 1;\n        function l(t) {\n          return [Math.round((t[0] - r) * a), Math.round((t[1] - i) * u)];\n        }\n        function c(t, e) {\n          for (var n, o, s, l, c, h = -1, p = 0, f = t.length, g = new Array(f); ++h < f;) n = t[h], l = Math.round((n[0] - r) * a), c = Math.round((n[1] - i) * u), l === o && c === s || (g[p++] = [o = l, s = c]);\n          for (g.length = p; p < e;) p = g.push([g[0][0], g[0][1]]);\n          return g;\n        }\n        function h(t) {\n          return c(t, 2);\n        }\n        function p(t) {\n          return c(t, 4);\n        }\n        function f(t) {\n          return t.map(p);\n        }\n        function g(t) {\n          null != t && De.call(d, t.type) && d[t.type](t);\n        }\n        var d = {\n          GeometryCollection: function GeometryCollection(t) {\n            t.geometries.forEach(g);\n          },\n          Point: function Point(t) {\n            t.coordinates = l(t.coordinates);\n          },\n          MultiPoint: function MultiPoint(t) {\n            t.coordinates = t.coordinates.map(l);\n          },\n          LineString: function LineString(t) {\n            t.arcs = h(t.arcs);\n          },\n          MultiLineString: function MultiLineString(t) {\n            t.arcs = t.arcs.map(h);\n          },\n          Polygon: function Polygon(t) {\n            t.arcs = f(t.arcs);\n          },\n          MultiPolygon: function MultiPolygon(t) {\n            t.arcs = t.arcs.map(f);\n          }\n        };\n        for (var y in t) g(t[y]);\n        return {\n          scale: [1 / a, 1 / u],\n          translate: [r, i]\n        };\n      }(t, n, e),\n      i = function (t) {\n        var e,\n          n,\n          r,\n          i,\n          o = t.coordinates,\n          s = t.lines,\n          a = t.rings,\n          u = s.length + a.length;\n        for (delete t.lines, delete t.rings, r = 0, i = s.length; r < i; ++r) for (e = s[r]; e = e.next;) ++u;\n        for (r = 0, i = a.length; r < i; ++r) for (n = a[r]; n = n.next;) ++u;\n        var l = Fe(2 * u * 1.4, ze, ke),\n          c = t.arcs = [];\n        for (r = 0, i = s.length; r < i; ++r) {\n          e = s[r];\n          do {\n            h(e);\n          } while (e = e.next);\n        }\n        for (r = 0, i = a.length; r < i; ++r) if ((n = a[r]).next) do {\n          h(n);\n        } while (n = n.next);else p(n);\n        function h(t) {\n          var e, n, r, i, s, a, u, h;\n          if (r = l.get(e = o[t[0]])) for (u = 0, h = r.length; u < h; ++u) if (f(i = r[u], t)) return t[0] = i[0], void (t[1] = i[1]);\n          if (s = l.get(n = o[t[1]])) for (u = 0, h = s.length; u < h; ++u) if (g(a = s[u], t)) return t[1] = a[0], void (t[0] = a[1]);\n          r ? r.push(t) : l.set(e, [t]), s ? s.push(t) : l.set(n, [t]), c.push(t);\n        }\n        function p(t) {\n          var e, n, r, i, s;\n          if (n = l.get(o[t[0]])) for (i = 0, s = n.length; i < s; ++i) {\n            if (d(r = n[i], t)) return t[0] = r[0], void (t[1] = r[1]);\n            if (y(r, t)) return t[0] = r[1], void (t[1] = r[0]);\n          }\n          if (n = l.get(e = o[t[0] + v(t)])) for (i = 0, s = n.length; i < s; ++i) {\n            if (d(r = n[i], t)) return t[0] = r[0], void (t[1] = r[1]);\n            if (y(r, t)) return t[0] = r[1], void (t[1] = r[0]);\n          }\n          n ? n.push(t) : l.set(e, [t]), c.push(t);\n        }\n        function f(t, e) {\n          var n = t[0],\n            r = e[0],\n            i = t[1];\n          if (n - i != r - e[1]) return !1;\n          for (; n <= i; ++n, ++r) if (!ke(o[n], o[r])) return !1;\n          return !0;\n        }\n        function g(t, e) {\n          var n = t[0],\n            r = e[0],\n            i = t[1],\n            s = e[1];\n          if (n - i != r - s) return !1;\n          for (; n <= i; ++n, --s) if (!ke(o[n], o[s])) return !1;\n          return !0;\n        }\n        function d(t, e) {\n          var n = t[0],\n            r = e[0],\n            i = t[1] - n;\n          if (i !== e[1] - r) return !1;\n          for (var s = v(t), a = v(e), u = 0; u < i; ++u) if (!ke(o[n + (u + s) % i], o[r + (u + a) % i])) return !1;\n          return !0;\n        }\n        function y(t, e) {\n          var n = t[0],\n            r = e[0],\n            i = t[1],\n            s = e[1],\n            a = i - n;\n          if (a !== s - r) return !1;\n          for (var u = v(t), l = a - v(e), c = 0; c < a; ++c) if (!ke(o[n + (c + u) % a], o[s - (c + l) % a])) return !1;\n          return !0;\n        }\n        function v(t) {\n          for (var e = t[0], n = t[1], r = e, i = r, s = o[r]; ++r < n;) {\n            var a = o[r];\n            (a[0] < s[0] || a[0] === s[0] && a[1] < s[1]) && (i = r, s = a);\n          }\n          return i - e;\n        }\n        return t;\n      }(function (t) {\n        var e,\n          n,\n          r,\n          i = je(t),\n          o = t.coordinates,\n          s = t.lines,\n          a = t.rings;\n        for (n = 0, r = s.length; n < r; ++n) for (var u = s[n], l = u[0], c = u[1]; ++l < c;) i.has(o[l]) && (e = {\n          0: l,\n          1: u[1]\n        }, u[1] = l, u = u.next = e);\n        for (n = 0, r = a.length; n < r; ++n) for (var h = a[n], p = h[0], f = p, g = h[1], d = i.has(o[p]); ++f < g;) i.has(o[f]) && (d ? (e = {\n          0: f,\n          1: h[1]\n        }, h[1] = f, h = h.next = e) : (Ue(o, p, g, g - f), o[g] = o[p], d = !0, f = p));\n        return t;\n      }(function (t) {\n        var e = -1,\n          n = [],\n          r = [],\n          i = [];\n        function o(t) {\n          t && De.call(s, t.type) && s[t.type](t);\n        }\n        var s = {\n          GeometryCollection: function GeometryCollection(t) {\n            t.geometries.forEach(o);\n          },\n          LineString: function LineString(t) {\n            t.arcs = a(t.arcs);\n          },\n          MultiLineString: function MultiLineString(t) {\n            t.arcs = t.arcs.map(a);\n          },\n          Polygon: function Polygon(t) {\n            t.arcs = t.arcs.map(u);\n          },\n          MultiPolygon: function MultiPolygon(t) {\n            t.arcs = t.arcs.map(l);\n          }\n        };\n        function a(t) {\n          for (var r = 0, o = t.length; r < o; ++r) i[++e] = t[r];\n          var s = {\n            0: e - o + 1,\n            1: e\n          };\n          return n.push(s), s;\n        }\n        function u(t) {\n          for (var n = 0, o = t.length; n < o; ++n) i[++e] = t[n];\n          var s = {\n            0: e - o + 1,\n            1: e\n          };\n          return r.push(s), s;\n        }\n        function l(t) {\n          return t.map(u);\n        }\n        for (var c in t) o(t[c]);\n        return {\n          type: \"Topology\",\n          coordinates: i,\n          lines: n,\n          rings: r,\n          objects: t\n        };\n      }(t))),\n      o = i.coordinates,\n      s = Fe(1.4 * i.arcs.length, Ze, Ke);\n    function a(t) {\n      t && De.call(u, t.type) && u[t.type](t);\n    }\n    t = i.objects, i.bbox = n, i.arcs = i.arcs.map(function (t, e) {\n      return s.set(t, e), o.slice(t[0], t[1] + 1);\n    }), delete i.coordinates, o = null;\n    var u = {\n      GeometryCollection: function GeometryCollection(t) {\n        t.geometries.forEach(a);\n      },\n      LineString: function LineString(t) {\n        t.arcs = l(t.arcs);\n      },\n      MultiLineString: function MultiLineString(t) {\n        t.arcs = t.arcs.map(l);\n      },\n      Polygon: function Polygon(t) {\n        t.arcs = t.arcs.map(l);\n      },\n      MultiPolygon: function MultiPolygon(t) {\n        t.arcs = t.arcs.map(c);\n      }\n    };\n    function l(t) {\n      var e = [];\n      do {\n        var n = s.get(t);\n        e.push(t[0] < t[1] ? n : ~n);\n      } while (t = t.next);\n      return e;\n    }\n    function c(t) {\n      return t.map(l);\n    }\n    for (var h in t) a(t[h]);\n    return r && (i.transform = r, i.arcs = function (t) {\n      for (var e = -1, n = t.length; ++e < n;) {\n        for (var r, i, o = t[e], s = 0, a = 1, u = o.length, l = o[0], c = l[0], h = l[1]; ++s < u;) r = (l = o[s])[0], i = l[1], r === c && i === h || (o[a++] = [r - c, i - h], c = r, h = i);\n        1 === a && (o[a++] = [0, 0]), o.length = a;\n      }\n      return t;\n    }(i.arcs)), i;\n  }\n  function Ze(t) {\n    var e,\n      n = t[0],\n      r = t[1];\n    return r < n && (e = n, n = r, r = e), n + 31 * r;\n  }\n  function Ke(t, e) {\n    var n,\n      r = t[0],\n      i = t[1],\n      o = e[0],\n      s = e[1];\n    return i < r && (n = r, r = i, i = n), s < o && (n = o, o = s, s = n), r === o && i === s;\n  }\n  function Qe(t, e) {\n    if (void 0 === e && (e = {}), \"FeatureCollection\" !== it(t)) throw new Error(\"geojson must be a FeatureCollection\");\n    if (!t.features.length) throw new Error(\"geojson is empty\");\n    !1 !== e.mutate && void 0 !== e.mutate || (t = Ie(t));\n    var n = [];\n    z(t, function (t) {\n      n.push(t.geometry);\n    });\n    var r = Je({\n      geoms: v(n).geometry\n    });\n    return function (t) {\n      return Re(t, Ae.apply(this, arguments));\n    }(r, r.objects.geoms.geometries);\n  }\n  function $e(t, e) {\n    if (void 0 === e && (e = {}), !P(e = e || {})) throw new Error(\"options is invalid\");\n    var n = e.mutate;\n    if (\"FeatureCollection\" !== it(t)) throw new Error(\"geojson must be a FeatureCollection\");\n    if (!t.features.length) throw new Error(\"geojson is empty\");\n    !1 !== n && void 0 !== n || (t = Ie(t));\n    var r = function (t) {\n      var e = {};\n      z(t, function (t) {\n        e[t.geometry.type] = !0;\n      });\n      var n = Object.keys(e);\n      if (1 === n.length) return n[0];\n      return null;\n    }(t);\n    if (!r) throw new Error(\"geojson must be homogenous\");\n    var i = t;\n    switch (r) {\n      case \"LineString\":\n        return Me(i, e);\n      case \"Polygon\":\n        return Qe(i, e);\n      default:\n        throw new Error(r + \" is not supported\");\n    }\n  }\n  function tn(t, e) {\n    void 0 === e && (e = {});\n    var n = \"object\" == typeof e ? e.mutate : e;\n    if (!t) throw new Error(\"geojson is required\");\n    var r = it(t),\n      i = [];\n    switch (r) {\n      case \"LineString\":\n        i = en(t);\n        break;\n      case \"MultiLineString\":\n      case \"Polygon\":\n        Q(t).forEach(function (t) {\n          i.push(en(t));\n        });\n        break;\n      case \"MultiPolygon\":\n        Q(t).forEach(function (t) {\n          var e = [];\n          t.forEach(function (t) {\n            e.push(en(t));\n          }), i.push(e);\n        });\n        break;\n      case \"Point\":\n        return t;\n      case \"MultiPoint\":\n        var s = {};\n        Q(t).forEach(function (t) {\n          var e = t.join(\"-\");\n          Object.prototype.hasOwnProperty.call(s, e) || (i.push(t), s[e] = !0);\n        });\n        break;\n      default:\n        throw new Error(r + \" geometry not supported\");\n    }\n    return t.coordinates ? !0 === n ? (t.coordinates = i, t) : {\n      type: r,\n      coordinates: i\n    } : !0 === n ? (t.geometry.coordinates = i, t) : o({\n      type: r,\n      coordinates: i\n    }, t.properties, {\n      bbox: t.bbox,\n      id: t.id\n    });\n  }\n  function en(t) {\n    var e = Q(t);\n    if (2 === e.length && !nn(e[0], e[1])) return e;\n    var n = [],\n      r = e.length - 1,\n      i = n.length;\n    n.push(e[0]);\n    for (var o = 1; o < r; o++) {\n      var s = n[n.length - 1];\n      e[o][0] === s[0] && e[o][1] === s[1] || (n.push(e[o]), (i = n.length) > 2 && rn(n[i - 3], n[i - 1], n[i - 2]) && n.splice(n.length - 2, 1));\n    }\n    if (n.push(e[e.length - 1]), i = n.length, nn(e[0], e[e.length - 1]) && i < 4) throw new Error(\"invalid polygon\");\n    return rn(n[i - 3], n[i - 1], n[i - 2]) && n.splice(n.length - 2, 1), n;\n  }\n  function nn(t, e) {\n    return t[0] === e[0] && t[1] === e[1];\n  }\n  function rn(t, e, n) {\n    var r = n[0],\n      i = n[1],\n      o = t[0],\n      s = t[1],\n      a = e[0],\n      u = e[1],\n      l = a - o,\n      c = u - s;\n    return 0 === (r - o) * c - (i - s) * l && (Math.abs(l) >= Math.abs(c) ? l > 0 ? o <= r && r <= a : a <= r && r <= o : c > 0 ? s <= i && i <= u : u <= i && i <= s);\n  }\n  function on(t, e, n) {\n    var r = e.x,\n      i = e.y,\n      o = n.x - r,\n      s = n.y - i;\n    if (0 !== o || 0 !== s) {\n      var a = ((t.x - r) * o + (t.y - i) * s) / (o * o + s * s);\n      a > 1 ? (r = n.x, i = n.y) : a > 0 && (r += o * a, i += s * a);\n    }\n    return (o = t.x - r) * o + (s = t.y - i) * s;\n  }\n  function sn(t, e, n, r, i) {\n    for (var o, s = r, a = e + 1; a < n; a++) {\n      var u = on(t[a], t[e], t[n]);\n      u > s && (o = a, s = u);\n    }\n    s > r && (o - e > 1 && sn(t, e, o, r, i), i.push(t[o]), n - o > 1 && sn(t, o, n, r, i));\n  }\n  function an(t, e) {\n    var n = t.length - 1,\n      r = [t[0]];\n    return sn(t, 0, n, e, r), r.push(t[n]), r;\n  }\n  function un(t, e, n) {\n    if (t.length <= 2) return t;\n    var r = void 0 !== e ? e * e : 1;\n    return t = an(t = n ? t : function (t, e) {\n      for (var n, r, i, o, s, a = t[0], u = [a], l = 1, c = t.length; l < c; l++) n = t[l], i = a, o = void 0, s = void 0, o = (r = n).x - i.x, s = r.y - i.y, o * o + s * s > e && (u.push(n), a = n);\n      return a !== n && u.push(n), u;\n    }(t, r), r);\n  }\n  function ln(t, e, n) {\n    return un(t.map(function (t) {\n      return {\n        x: t[0],\n        y: t[1],\n        z: t[2]\n      };\n    }), e, n).map(function (t) {\n      return t.z ? [t.x, t.y, t.z] : [t.x, t.y];\n    });\n  }\n  function cn(t, e, n) {\n    return t.map(function (t) {\n      var r = t.map(function (t) {\n        return {\n          x: t[0],\n          y: t[1]\n        };\n      });\n      if (r.length < 4) throw new Error(\"invalid polygon\");\n      for (var i = un(r, e, n).map(function (t) {\n        return [t.x, t.y];\n      }); !hn(i);) i = un(r, e -= .01 * e, n).map(function (t) {\n        return [t.x, t.y];\n      });\n      return i[i.length - 1][0] === i[0][0] && i[i.length - 1][1] === i[0][1] || i.push(i[0]), i;\n    });\n  }\n  function hn(t) {\n    return !(t.length < 3) && !(3 === t.length && t[2][0] === t[0][0] && t[2][1] === t[0][1]);\n  }\n  var pn = function () {\n    function t(t) {\n      this.points = t.points || [], this.duration = t.duration || 1e4, this.sharpness = t.sharpness || .85, this.centers = [], this.controls = [], this.stepLength = t.stepLength || 60, this.length = this.points.length, this.delay = 0;\n      for (var e = 0; e < this.length; e++) this.points[e].z = this.points[e].z || 0;\n      for (e = 0; e < this.length - 1; e++) {\n        var n = this.points[e],\n          r = this.points[e + 1];\n        this.centers.push({\n          x: (n.x + r.x) / 2,\n          y: (n.y + r.y) / 2,\n          z: (n.z + r.z) / 2\n        });\n      }\n      this.controls.push([this.points[0], this.points[0]]);\n      for (e = 0; e < this.centers.length - 1; e++) {\n        var i = this.points[e + 1].x - (this.centers[e].x + this.centers[e + 1].x) / 2,\n          o = this.points[e + 1].y - (this.centers[e].y + this.centers[e + 1].y) / 2,\n          s = this.points[e + 1].z - (this.centers[e].y + this.centers[e + 1].z) / 2;\n        this.controls.push([{\n          x: (1 - this.sharpness) * this.points[e + 1].x + this.sharpness * (this.centers[e].x + i),\n          y: (1 - this.sharpness) * this.points[e + 1].y + this.sharpness * (this.centers[e].y + o),\n          z: (1 - this.sharpness) * this.points[e + 1].z + this.sharpness * (this.centers[e].z + s)\n        }, {\n          x: (1 - this.sharpness) * this.points[e + 1].x + this.sharpness * (this.centers[e + 1].x + i),\n          y: (1 - this.sharpness) * this.points[e + 1].y + this.sharpness * (this.centers[e + 1].y + o),\n          z: (1 - this.sharpness) * this.points[e + 1].z + this.sharpness * (this.centers[e + 1].z + s)\n        }]);\n      }\n      return this.controls.push([this.points[this.length - 1], this.points[this.length - 1]]), this.steps = this.cacheSteps(this.stepLength), this;\n    }\n    return t.prototype.cacheSteps = function (t) {\n      var e = [],\n        n = this.pos(0);\n      e.push(0);\n      for (var r = 0; r < this.duration; r += 10) {\n        var i = this.pos(r);\n        Math.sqrt((i.x - n.x) * (i.x - n.x) + (i.y - n.y) * (i.y - n.y) + (i.z - n.z) * (i.z - n.z)) > t && (e.push(r), n = i);\n      }\n      return e;\n    }, t.prototype.vector = function (t) {\n      var e = this.pos(t + 10),\n        n = this.pos(t - 10);\n      return {\n        angle: 180 * Math.atan2(e.y - n.y, e.x - n.x) / 3.14,\n        speed: Math.sqrt((n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y) + (n.z - e.z) * (n.z - e.z))\n      };\n    }, t.prototype.pos = function (t) {\n      var e = t - this.delay;\n      e < 0 && (e = 0), e > this.duration && (e = this.duration - 1);\n      var n = e / this.duration;\n      if (n >= 1) return this.points[this.length - 1];\n      var r = Math.floor((this.points.length - 1) * n);\n      return function (t, e, n, r, i) {\n        var o = function (t) {\n          var e = t * t;\n          return [e * t, 3 * e * (1 - t), 3 * t * (1 - t) * (1 - t), (1 - t) * (1 - t) * (1 - t)];\n        }(t);\n        return {\n          x: i.x * o[0] + r.x * o[1] + n.x * o[2] + e.x * o[3],\n          y: i.y * o[0] + r.y * o[1] + n.y * o[2] + e.y * o[3],\n          z: i.z * o[0] + r.z * o[1] + n.z * o[2] + e.z * o[3]\n        };\n      }((this.length - 1) * n - r, this.points[r], this.controls[r][1], this.controls[r + 1][0], this.points[r + 1]);\n    }, t;\n  }();\n  function fn(t, e) {\n    void 0 === e && (e = {});\n    for (var n = e.resolution || 1e4, r = e.sharpness || .85, i = [], o = rt(t).coordinates.map(function (t) {\n        return {\n          x: t[0],\n          y: t[1]\n        };\n      }), s = new pn({\n        duration: n,\n        points: o,\n        sharpness: r\n      }), a = function a(t) {\n        var e = s.pos(t);\n        Math.floor(t / 100) % 2 == 0 && i.push([e.x, e.y]);\n      }, u = 0; u < s.duration; u += 10) a(u);\n    return a(s.duration), h(i, e.properties);\n  }\n  function gn(t, e) {\n    void 0 === e && (e = {});\n    var n = Number(t[0]),\n      r = Number(t[1]),\n      i = Number(t[2]),\n      o = Number(t[3]);\n    if (6 === t.length) throw new Error(\"@turf/bbox-polygon does not support BBox with 6 positions\");\n    var s = [n, r];\n    return l([[s, [i, r], [i, o], [n, o], s]], e.properties, {\n      bbox: t,\n      id: e.id\n    });\n  }\n  function dn(t) {\n    return gn(Z(t));\n  }\n  function yn(t) {\n    var e = t[0],\n      n = t[1],\n      r = t[2],\n      i = t[3];\n    if (me(t.slice(0, 2), [r, n]) >= me(t.slice(0, 2), [e, i])) {\n      var o = (n + i) / 2;\n      return [e, o - (r - e) / 2, r, o + (r - e) / 2];\n    }\n    var s = (e + r) / 2;\n    return [s - (i - n) / 2, n, s + (i - n) / 2, i];\n  }\n  function vn(t, e, n, r) {\n    void 0 === r && (r = {});\n    var i = K(t),\n      o = I(i[0]),\n      s = I(i[1]),\n      u = I(n),\n      l = x(e, r.units),\n      c = Math.asin(Math.sin(s) * Math.cos(l) + Math.cos(s) * Math.sin(l) * Math.cos(u));\n    return a([w(o + Math.atan2(Math.sin(u) * Math.sin(l) * Math.cos(s), Math.cos(l) - Math.sin(s) * Math.sin(c))), w(c)], r.properties);\n  }\n  function _n(t, e, n) {\n    void 0 === n && (n = {});\n    for (var r = n.steps || 64, i = n.properties ? n.properties : !Array.isArray(t) && \"Feature\" === t.type && t.properties ? t.properties : {}, o = [], s = 0; s < r; s++) o.push(vn(t, e, -360 * s / r, n).geometry.coordinates);\n    return o.push(o[0]), l([o], i);\n  }\n  function mn(t, e, n) {\n    if (void 0 === n && (n = {}), !0 === n.final) return function (t, e) {\n      var n = mn(e, t);\n      return n = (n + 180) % 360;\n    }(t, e);\n    var r = K(t),\n      i = K(e),\n      o = I(r[0]),\n      s = I(i[0]),\n      a = I(r[1]),\n      u = I(i[1]),\n      l = Math.sin(s - o) * Math.cos(u),\n      c = Math.cos(a) * Math.sin(u) - Math.sin(a) * Math.cos(u) * Math.cos(s - o);\n    return w(Math.atan2(l, c));\n  }\n  function xn(t, e) {\n    void 0 === e && (e = {});\n    var n = Z(t);\n    return a([(n[0] + n[2]) / 2, (n[1] + n[3]) / 2], e.properties, e);\n  }\n  function En(t, e) {\n    void 0 === e && (e = {});\n    var n = 0,\n      r = 0,\n      i = 0;\n    return R(t, function (t) {\n      n += t[0], r += t[1], i++;\n    }, !0), a([n / i, r / i], e.properties);\n  }\n  function bn(t) {\n    var e = [];\n    return \"FeatureCollection\" === t.type ? F(t, function (t) {\n      R(t, function (n) {\n        e.push(a(n, t.properties));\n      });\n    }) : R(t, function (n) {\n      e.push(a(n, t.properties));\n    }), f(e);\n  }\n  var wn = Nn,\n    In = Nn;\n  function Nn(t, e, n) {\n    n = n || 2;\n    var r,\n      i,\n      o,\n      s,\n      a,\n      u,\n      l,\n      c = e && e.length,\n      h = c ? e[0] * n : t.length,\n      p = Sn(t, 0, h, n, !0),\n      f = [];\n    if (!p) return f;\n    if (c && (p = function (t, e, n, r) {\n      var i,\n        o,\n        s,\n        a = [];\n      for (i = 0, o = e.length; i < o; i++) (s = Sn(t, e[i] * r, i < o - 1 ? e[i + 1] * r : t.length, r, !1)) === s.next && (s.steiner = !0), a.push(Fn(s));\n      for (a.sort(Tn), i = 0; i < a.length; i++) An(a[i], n), n = Cn(n, n.next);\n      return n;\n    }(t, e, p, n)), t.length > 80 * n) {\n      r = o = t[0], i = s = t[1];\n      for (var g = n; g < h; g += n) (a = t[g]) < r && (r = a), (u = t[g + 1]) < i && (i = u), a > o && (o = a), u > s && (s = u);\n      l = 0 !== (l = Math.max(o - r, s - i)) ? 1 / l : 0;\n    }\n    return Pn(p, f, n, r, i, l), f;\n  }\n  function Sn(t, e, n, r, i) {\n    var o, s;\n    if (i === Hn(t, e, n, r) > 0) for (o = e; o < n; o += r) s = Vn(o, t[o], t[o + 1], s);else for (o = n - r; o >= e; o -= r) s = Vn(o, t[o], t[o + 1], s);\n    return s && Bn(s, s.next) && (Xn(s), s = s.next), s;\n  }\n  function Cn(t, e) {\n    if (!t) return t;\n    e || (e = t);\n    var n,\n      r = t;\n    do {\n      if (n = !1, r.steiner || !Bn(r, r.next) && 0 !== qn(r.prev, r, r.next)) r = r.next;else {\n        if (Xn(r), (r = e = r.prev) === r.next) break;\n        n = !0;\n      }\n    } while (n || r !== e);\n    return e;\n  }\n  function Pn(t, e, n, r, i, o, s) {\n    if (t) {\n      !s && o && function (t, e, n, r) {\n        var i = t;\n        do {\n          null === i.z && (i.z = Dn(i.x, i.y, e, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;\n        } while (i !== t);\n        i.prevZ.nextZ = null, i.prevZ = null, function (t) {\n          var e,\n            n,\n            r,\n            i,\n            o,\n            s,\n            a,\n            u,\n            l = 1;\n          do {\n            for (n = t, t = null, o = null, s = 0; n;) {\n              for (s++, r = n, a = 0, e = 0; e < l && (a++, r = r.nextZ); e++);\n              for (u = l; a > 0 || u > 0 && r;) 0 !== a && (0 === u || !r || n.z <= r.z) ? (i = n, n = n.nextZ, a--) : (i = r, r = r.nextZ, u--), o ? o.nextZ = i : t = i, i.prevZ = o, o = i;\n              n = r;\n            }\n            o.nextZ = null, l *= 2;\n          } while (s > 1);\n        }(i);\n      }(t, r, i, o);\n      for (var a, u, l = t; t.prev !== t.next;) if (a = t.prev, u = t.next, o ? Ln(t, r, i, o) : Mn(t)) e.push(a.i / n), e.push(t.i / n), e.push(u.i / n), Xn(t), t = u.next, l = u.next;else if ((t = u) === l) {\n        s ? 1 === s ? Pn(t = On(t, e, n), e, n, r, i, o, 2) : 2 === s && Rn(t, e, n, r, i, o) : Pn(Cn(t), e, n, r, i, o, 1);\n        break;\n      }\n    }\n  }\n  function Mn(t) {\n    var e = t.prev,\n      n = t,\n      r = t.next;\n    if (qn(e, n, r) >= 0) return !1;\n    for (var i = t.next.next; i !== t.prev;) {\n      if (kn(e.x, e.y, n.x, n.y, r.x, r.y, i.x, i.y) && qn(i.prev, i, i.next) >= 0) return !1;\n      i = i.next;\n    }\n    return !0;\n  }\n  function Ln(t, e, n, r) {\n    var i = t.prev,\n      o = t,\n      s = t.next;\n    if (qn(i, o, s) >= 0) return !1;\n    for (var a = i.x < o.x ? i.x < s.x ? i.x : s.x : o.x < s.x ? o.x : s.x, u = i.y < o.y ? i.y < s.y ? i.y : s.y : o.y < s.y ? o.y : s.y, l = i.x > o.x ? i.x > s.x ? i.x : s.x : o.x > s.x ? o.x : s.x, c = i.y > o.y ? i.y > s.y ? i.y : s.y : o.y > s.y ? o.y : s.y, h = Dn(a, u, e, n, r), p = Dn(l, c, e, n, r), f = t.prevZ, g = t.nextZ; f && f.z >= h && g && g.z <= p;) {\n      if (f !== t.prev && f !== t.next && kn(i.x, i.y, o.x, o.y, s.x, s.y, f.x, f.y) && qn(f.prev, f, f.next) >= 0) return !1;\n      if (f = f.prevZ, g !== t.prev && g !== t.next && kn(i.x, i.y, o.x, o.y, s.x, s.y, g.x, g.y) && qn(g.prev, g, g.next) >= 0) return !1;\n      g = g.nextZ;\n    }\n    for (; f && f.z >= h;) {\n      if (f !== t.prev && f !== t.next && kn(i.x, i.y, o.x, o.y, s.x, s.y, f.x, f.y) && qn(f.prev, f, f.next) >= 0) return !1;\n      f = f.prevZ;\n    }\n    for (; g && g.z <= p;) {\n      if (g !== t.prev && g !== t.next && kn(i.x, i.y, o.x, o.y, s.x, s.y, g.x, g.y) && qn(g.prev, g, g.next) >= 0) return !1;\n      g = g.nextZ;\n    }\n    return !0;\n  }\n  function On(t, e, n) {\n    var r = t;\n    do {\n      var i = r.prev,\n        o = r.next.next;\n      !Bn(i, o) && zn(i, r, r.next, o) && jn(i, o) && jn(o, i) && (e.push(i.i / n), e.push(r.i / n), e.push(o.i / n), Xn(r), Xn(r.next), r = t = o), r = r.next;\n    } while (r !== t);\n    return r;\n  }\n  function Rn(t, e, n, r, i, o) {\n    var s = t;\n    do {\n      for (var a = s.next.next; a !== s.prev;) {\n        if (s.i !== a.i && Gn(s, a)) {\n          var u = Un(s, a);\n          return s = Cn(s, s.next), u = Cn(u, u.next), Pn(s, e, n, r, i, o), void Pn(u, e, n, r, i, o);\n        }\n        a = a.next;\n      }\n      s = s.next;\n    } while (s !== t);\n  }\n  function Tn(t, e) {\n    return t.x - e.x;\n  }\n  function An(t, e) {\n    if (e = function (t, e) {\n      var n,\n        r = e,\n        i = t.x,\n        o = t.y,\n        s = -1 / 0;\n      do {\n        if (o <= r.y && o >= r.next.y && r.next.y !== r.y) {\n          var a = r.x + (o - r.y) * (r.next.x - r.x) / (r.next.y - r.y);\n          if (a <= i && a > s) {\n            if (s = a, a === i) {\n              if (o === r.y) return r;\n              if (o === r.next.y) return r.next;\n            }\n            n = r.x < r.next.x ? r : r.next;\n          }\n        }\n        r = r.next;\n      } while (r !== e);\n      if (!n) return null;\n      if (i === s) return n.prev;\n      var u,\n        l = n,\n        c = n.x,\n        h = n.y,\n        p = 1 / 0;\n      r = n.next;\n      for (; r !== l;) i >= r.x && r.x >= c && i !== r.x && kn(o < h ? i : s, o, c, h, o < h ? s : i, o, r.x, r.y) && ((u = Math.abs(o - r.y) / (i - r.x)) < p || u === p && r.x > n.x) && jn(r, t) && (n = r, p = u), r = r.next;\n      return n;\n    }(t, e)) {\n      var n = Un(e, t);\n      Cn(n, n.next);\n    }\n  }\n  function Dn(t, e, n, r, i) {\n    return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;\n  }\n  function Fn(t) {\n    var e = t,\n      n = t;\n    do {\n      e.x < n.x && (n = e), e = e.next;\n    } while (e !== t);\n    return n;\n  }\n  function kn(t, e, n, r, i, o, s, a) {\n    return (i - s) * (e - a) - (t - s) * (o - a) >= 0 && (t - s) * (r - a) - (n - s) * (e - a) >= 0 && (n - s) * (o - a) - (i - s) * (r - a) >= 0;\n  }\n  function Gn(t, e) {\n    return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) {\n      var n = t;\n      do {\n        if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && zn(n, n.next, t, e)) return !0;\n        n = n.next;\n      } while (n !== t);\n      return !1;\n    }(t, e) && jn(t, e) && jn(e, t) && function (t, e) {\n      var n = t,\n        r = !1,\n        i = (t.x + e.x) / 2,\n        o = (t.y + e.y) / 2;\n      do {\n        n.y > o != n.next.y > o && n.next.y !== n.y && i < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next;\n      } while (n !== t);\n      return r;\n    }(t, e);\n  }\n  function qn(t, e, n) {\n    return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);\n  }\n  function Bn(t, e) {\n    return t.x === e.x && t.y === e.y;\n  }\n  function zn(t, e, n, r) {\n    return !!(Bn(t, e) && Bn(n, r) || Bn(t, r) && Bn(n, e)) || qn(t, e, n) > 0 != qn(t, e, r) > 0 && qn(n, r, t) > 0 != qn(n, r, e) > 0;\n  }\n  function jn(t, e) {\n    return qn(t.prev, t, t.next) < 0 ? qn(t, e, t.next) >= 0 && qn(t, t.prev, e) >= 0 : qn(t, e, t.prev) < 0 || qn(t, t.next, e) < 0;\n  }\n  function Un(t, e) {\n    var n = new Yn(t.i, t.x, t.y),\n      r = new Yn(e.i, e.x, e.y),\n      i = t.next,\n      o = e.prev;\n    return t.next = e, e.prev = t, n.next = i, i.prev = n, r.next = n, n.prev = r, o.next = r, r.prev = o, r;\n  }\n  function Vn(t, e, n, r) {\n    var i = new Yn(t, e, n);\n    return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i;\n  }\n  function Xn(t) {\n    t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);\n  }\n  function Yn(t, e, n) {\n    this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;\n  }\n  function Hn(t, e, n, r) {\n    for (var i = 0, o = e, s = n - r; o < n; o += r) i += (t[s] - t[o]) * (t[o + 1] + t[s + 1]), s = o;\n    return i;\n  }\n  function Wn(t) {\n    var e = function (t) {\n        for (var e = t[0][0].length, n = {\n            vertices: [],\n            holes: [],\n            dimensions: e\n          }, r = 0, i = 0; i < t.length; i++) {\n          for (var o = 0; o < t[i].length; o++) for (var s = 0; s < e; s++) n.vertices.push(t[i][o][s]);\n          i > 0 && (r += t[i - 1].length, n.holes.push(r));\n        }\n        return n;\n      }(t),\n      n = wn(e.vertices, e.holes, 2),\n      r = [],\n      i = [];\n    n.forEach(function (t, r) {\n      var o = n[r];\n      i.push([e.vertices[2 * o], e.vertices[2 * o + 1]]);\n    });\n    for (var o = 0; o < i.length; o += 3) {\n      var s = i.slice(o, o + 3);\n      s.push(i[o]), r.push(l([s]));\n    }\n    return r;\n  }\n  function Jn(t, e) {\n    if (!t) throw new Error(\"targetPoint is required\");\n    if (!e) throw new Error(\"points is required\");\n    var n,\n      r = 1 / 0,\n      i = 0;\n    return F(e, function (e, n) {\n      var o = me(t, e);\n      o < r && (i = n, r = o);\n    }), (n = Ie(e.features[i])).properties.featureIndex = i, n.properties.distanceToPoint = r, n;\n  }\n  function Zn(t) {\n    if (!t) throw new Error(\"geojson is required\");\n    var e = [];\n    return z(t, function (t) {\n      !function (t, e) {\n        var n = [],\n          r = t.geometry;\n        if (null !== r) {\n          switch (r.type) {\n            case \"Polygon\":\n              n = Q(r);\n              break;\n            case \"LineString\":\n              n = [Q(r)];\n          }\n          n.forEach(function (n) {\n            (function (t, e) {\n              var n = [];\n              return t.reduce(function (t, r) {\n                var i = h([t, r], e);\n                return i.bbox = function (t, e) {\n                  var n = t[0],\n                    r = t[1],\n                    i = e[0],\n                    o = e[1];\n                  return [n < i ? n : i, r < o ? r : o, n > i ? n : i, r > o ? r : o];\n                }(t, r), n.push(i), r;\n              }), n;\n            })(n, t.properties).forEach(function (t) {\n              t.id = e.length, e.push(t);\n            });\n          });\n        }\n      }(t, e);\n    }), f(e);\n  }\n  Nn.deviation = function (t, e, n, r) {\n    var i = e && e.length,\n      o = i ? e[0] * n : t.length,\n      s = Math.abs(Hn(t, 0, o, n));\n    if (i) for (var a = 0, u = e.length; a < u; a++) {\n      var l = e[a] * n,\n        c = a < u - 1 ? e[a + 1] * n : t.length;\n      s -= Math.abs(Hn(t, l, c, n));\n    }\n    var h = 0;\n    for (a = 0; a < r.length; a += 3) {\n      var p = r[a] * n,\n        f = r[a + 1] * n,\n        g = r[a + 2] * n;\n      h += Math.abs((t[p] - t[g]) * (t[f + 1] - t[p + 1]) - (t[p] - t[f]) * (t[g + 1] - t[p + 1]));\n    }\n    return 0 === s && 0 === h ? 0 : Math.abs((h - s) / s);\n  }, Nn.flatten = function (t) {\n    for (var e = t[0][0].length, n = {\n        vertices: [],\n        holes: [],\n        dimensions: e\n      }, r = 0, i = 0; i < t.length; i++) {\n      for (var o = 0; o < t[i].length; o++) for (var s = 0; s < e; s++) n.vertices.push(t[i][o][s]);\n      i > 0 && (r += t[i - 1].length, n.holes.push(r));\n    }\n    return n;\n  }, wn.default = In;\n  var Kn = Bt(function (t, e) {\n    function n(t, e, n) {\n      void 0 === n && (n = {});\n      var r = {\n        type: \"Feature\"\n      };\n      return (0 === n.id || n.id) && (r.id = n.id), n.bbox && (r.bbox = n.bbox), r.properties = e || {}, r.geometry = t, r;\n    }\n    function r(t, e, r) {\n      if (void 0 === r && (r = {}), !t) throw new Error(\"coordinates is required\");\n      if (!Array.isArray(t)) throw new Error(\"coordinates must be an Array\");\n      if (t.length < 2) throw new Error(\"coordinates must be at least 2 numbers long\");\n      if (!f(t[0]) || !f(t[1])) throw new Error(\"coordinates must contain numbers\");\n      return n({\n        type: \"Point\",\n        coordinates: t\n      }, e, r);\n    }\n    function i(t, e, r) {\n      void 0 === r && (r = {});\n      for (var i = 0, o = t; i < o.length; i++) {\n        var s = o[i];\n        if (s.length < 4) throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        for (var a = 0; a < s[s.length - 1].length; a++) if (s[s.length - 1][a] !== s[0][a]) throw new Error(\"First and last Position are not equivalent.\");\n      }\n      return n({\n        type: \"Polygon\",\n        coordinates: t\n      }, e, r);\n    }\n    function o(t, e, r) {\n      if (void 0 === r && (r = {}), t.length < 2) throw new Error(\"coordinates must be an array of two or more positions\");\n      return n({\n        type: \"LineString\",\n        coordinates: t\n      }, e, r);\n    }\n    function s(t, e) {\n      void 0 === e && (e = {});\n      var n = {\n        type: \"FeatureCollection\"\n      };\n      return e.id && (n.id = e.id), e.bbox && (n.bbox = e.bbox), n.features = t, n;\n    }\n    function a(t, e, r) {\n      return void 0 === r && (r = {}), n({\n        type: \"MultiLineString\",\n        coordinates: t\n      }, e, r);\n    }\n    function u(t, e, r) {\n      return void 0 === r && (r = {}), n({\n        type: \"MultiPoint\",\n        coordinates: t\n      }, e, r);\n    }\n    function l(t, e, r) {\n      return void 0 === r && (r = {}), n({\n        type: \"MultiPolygon\",\n        coordinates: t\n      }, e, r);\n    }\n    function c(t, n) {\n      void 0 === n && (n = \"kilometers\");\n      var r = e.factors[n];\n      if (!r) throw new Error(n + \" units is invalid\");\n      return t * r;\n    }\n    function h(t, n) {\n      void 0 === n && (n = \"kilometers\");\n      var r = e.factors[n];\n      if (!r) throw new Error(n + \" units is invalid\");\n      return t / r;\n    }\n    function p(t) {\n      return 180 * (t % (2 * Math.PI)) / Math.PI;\n    }\n    function f(t) {\n      return !isNaN(t) && null !== t && !Array.isArray(t);\n    }\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.earthRadius = 6371008.8, e.factors = {\n      centimeters: 100 * e.earthRadius,\n      centimetres: 100 * e.earthRadius,\n      degrees: e.earthRadius / 111325,\n      feet: 3.28084 * e.earthRadius,\n      inches: 39.37 * e.earthRadius,\n      kilometers: e.earthRadius / 1e3,\n      kilometres: e.earthRadius / 1e3,\n      meters: e.earthRadius,\n      metres: e.earthRadius,\n      miles: e.earthRadius / 1609.344,\n      millimeters: 1e3 * e.earthRadius,\n      millimetres: 1e3 * e.earthRadius,\n      nauticalmiles: e.earthRadius / 1852,\n      radians: 1,\n      yards: 1.0936 * e.earthRadius\n    }, e.unitsFactors = {\n      centimeters: 100,\n      centimetres: 100,\n      degrees: 1 / 111325,\n      feet: 3.28084,\n      inches: 39.37,\n      kilometers: .001,\n      kilometres: .001,\n      meters: 1,\n      metres: 1,\n      miles: 1 / 1609.344,\n      millimeters: 1e3,\n      millimetres: 1e3,\n      nauticalmiles: 1 / 1852,\n      radians: 1 / e.earthRadius,\n      yards: 1.0936133\n    }, e.areaFactors = {\n      acres: 247105e-9,\n      centimeters: 1e4,\n      centimetres: 1e4,\n      feet: 10.763910417,\n      hectares: 1e-4,\n      inches: 1550.003100006,\n      kilometers: 1e-6,\n      kilometres: 1e-6,\n      meters: 1,\n      metres: 1,\n      miles: 386e-9,\n      millimeters: 1e6,\n      millimetres: 1e6,\n      yards: 1.195990046\n    }, e.feature = n, e.geometry = function (t, e, n) {\n      switch (t) {\n        case \"Point\":\n          return r(e).geometry;\n        case \"LineString\":\n          return o(e).geometry;\n        case \"Polygon\":\n          return i(e).geometry;\n        case \"MultiPoint\":\n          return u(e).geometry;\n        case \"MultiLineString\":\n          return a(e).geometry;\n        case \"MultiPolygon\":\n          return l(e).geometry;\n        default:\n          throw new Error(t + \" is invalid\");\n      }\n    }, e.point = r, e.points = function (t, e, n) {\n      return void 0 === n && (n = {}), s(t.map(function (t) {\n        return r(t, e);\n      }), n);\n    }, e.polygon = i, e.polygons = function (t, e, n) {\n      return void 0 === n && (n = {}), s(t.map(function (t) {\n        return i(t, e);\n      }), n);\n    }, e.lineString = o, e.lineStrings = function (t, e, n) {\n      return void 0 === n && (n = {}), s(t.map(function (t) {\n        return o(t, e);\n      }), n);\n    }, e.featureCollection = s, e.multiLineString = a, e.multiPoint = u, e.multiPolygon = l, e.geometryCollection = function (t, e, r) {\n      return void 0 === r && (r = {}), n({\n        type: \"GeometryCollection\",\n        geometries: t\n      }, e, r);\n    }, e.round = function (t, e) {\n      if (void 0 === e && (e = 0), e && !(e >= 0)) throw new Error(\"precision must be a positive number\");\n      var n = Math.pow(10, e || 0);\n      return Math.round(t * n) / n;\n    }, e.radiansToLength = c, e.lengthToRadians = h, e.lengthToDegrees = function (t, e) {\n      return p(h(t, e));\n    }, e.bearingToAzimuth = function (t) {\n      var e = t % 360;\n      return e < 0 && (e += 360), e;\n    }, e.radiansToDegrees = p, e.degreesToRadians = function (t) {\n      return t % 360 * Math.PI / 180;\n    }, e.convertLength = function (t, e, n) {\n      if (void 0 === e && (e = \"kilometers\"), void 0 === n && (n = \"kilometers\"), !(t >= 0)) throw new Error(\"length must be a positive number\");\n      return c(h(t, e), n);\n    }, e.convertArea = function (t, n, r) {\n      if (void 0 === n && (n = \"meters\"), void 0 === r && (r = \"kilometers\"), !(t >= 0)) throw new Error(\"area must be a positive number\");\n      var i = e.areaFactors[n];\n      if (!i) throw new Error(\"invalid original units\");\n      var o = e.areaFactors[r];\n      if (!o) throw new Error(\"invalid final units\");\n      return t / i * o;\n    }, e.isNumber = f, e.isObject = function (t) {\n      return !!t && t.constructor === Object;\n    }, e.validateBBox = function (t) {\n      if (!t) throw new Error(\"bbox is required\");\n      if (!Array.isArray(t)) throw new Error(\"bbox must be an Array\");\n      if (4 !== t.length && 6 !== t.length) throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n      t.forEach(function (t) {\n        if (!f(t)) throw new Error(\"bbox must only contain numbers\");\n      });\n    }, e.validateId = function (t) {\n      if (!t) throw new Error(\"id is required\");\n      if (-1 === [\"string\", \"number\"].indexOf(typeof t)) throw new Error(\"id must be a number or a string\");\n    };\n  });\n  function Qn(t, e, n) {\n    if (null !== t) for (var r, i, o, s, a, u, l, c, h = 0, p = 0, f = t.type, g = \"FeatureCollection\" === f, d = \"Feature\" === f, y = g ? t.features.length : 1, v = 0; v < y; v++) {\n      a = (c = !!(l = g ? t.features[v].geometry : d ? t.geometry : t) && \"GeometryCollection\" === l.type) ? l.geometries.length : 1;\n      for (var _ = 0; _ < a; _++) {\n        var m = 0,\n          x = 0;\n        if (null !== (s = c ? l.geometries[_] : l)) {\n          u = s.coordinates;\n          var E = s.type;\n          switch (h = !n || \"Polygon\" !== E && \"MultiPolygon\" !== E ? 0 : 1, E) {\n            case null:\n              break;\n            case \"Point\":\n              if (!1 === e(u, p, v, m, x)) return !1;\n              p++, m++;\n              break;\n            case \"LineString\":\n            case \"MultiPoint\":\n              for (r = 0; r < u.length; r++) {\n                if (!1 === e(u[r], p, v, m, x)) return !1;\n                p++, \"MultiPoint\" === E && m++;\n              }\n              \"LineString\" === E && m++;\n              break;\n            case \"Polygon\":\n            case \"MultiLineString\":\n              for (r = 0; r < u.length; r++) {\n                for (i = 0; i < u[r].length - h; i++) {\n                  if (!1 === e(u[r][i], p, v, m, x)) return !1;\n                  p++;\n                }\n                \"MultiLineString\" === E && m++, \"Polygon\" === E && x++;\n              }\n              \"Polygon\" === E && m++;\n              break;\n            case \"MultiPolygon\":\n              for (r = 0; r < u.length; r++) {\n                for (x = 0, i = 0; i < u[r].length; i++) {\n                  for (o = 0; o < u[r][i].length - h; o++) {\n                    if (!1 === e(u[r][i][o], p, v, m, x)) return !1;\n                    p++;\n                  }\n                  x++;\n                }\n                m++;\n              }\n              break;\n            case \"GeometryCollection\":\n              for (r = 0; r < s.geometries.length; r++) if (!1 === Qn(s.geometries[r], e, n)) return !1;\n              break;\n            default:\n              throw new Error(\"Unknown Geometry Type\");\n          }\n        }\n      }\n    }\n  }\n  function $n(t, e) {\n    var n;\n    switch (t.type) {\n      case \"FeatureCollection\":\n        for (n = 0; n < t.features.length && !1 !== e(t.features[n].properties, n); n++);\n        break;\n      case \"Feature\":\n        e(t.properties, 0);\n    }\n  }\n  function tr(t, e) {\n    if (\"Feature\" === t.type) e(t, 0);else if (\"FeatureCollection\" === t.type) for (var n = 0; n < t.features.length && !1 !== e(t.features[n], n); n++);\n  }\n  function er(t, e) {\n    var n,\n      r,\n      i,\n      o,\n      s,\n      a,\n      u,\n      l,\n      c,\n      h,\n      p = 0,\n      f = \"FeatureCollection\" === t.type,\n      g = \"Feature\" === t.type,\n      d = f ? t.features.length : 1;\n    for (n = 0; n < d; n++) {\n      for (a = f ? t.features[n].geometry : g ? t.geometry : t, l = f ? t.features[n].properties : g ? t.properties : {}, c = f ? t.features[n].bbox : g ? t.bbox : void 0, h = f ? t.features[n].id : g ? t.id : void 0, s = (u = !!a && \"GeometryCollection\" === a.type) ? a.geometries.length : 1, i = 0; i < s; i++) if (null !== (o = u ? a.geometries[i] : a)) switch (o.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\":\n          if (!1 === e(o, p, l, c, h)) return !1;\n          break;\n        case \"GeometryCollection\":\n          for (r = 0; r < o.geometries.length; r++) if (!1 === e(o.geometries[r], p, l, c, h)) return !1;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      } else if (!1 === e(null, p, l, c, h)) return !1;\n      p++;\n    }\n  }\n  function nr(t, e) {\n    er(t, function (t, n, r, i, o) {\n      var s,\n        a = null === t ? null : t.type;\n      switch (a) {\n        case null:\n        case \"Point\":\n        case \"LineString\":\n        case \"Polygon\":\n          return !1 !== e(Kn.feature(t, r, {\n            bbox: i,\n            id: o\n          }), n, 0) && void 0;\n      }\n      switch (a) {\n        case \"MultiPoint\":\n          s = \"Point\";\n          break;\n        case \"MultiLineString\":\n          s = \"LineString\";\n          break;\n        case \"MultiPolygon\":\n          s = \"Polygon\";\n      }\n      for (var u = 0; u < t.coordinates.length; u++) {\n        var l = {\n          type: s,\n          coordinates: t.coordinates[u]\n        };\n        if (!1 === e(Kn.feature(l, r), n, u)) return !1;\n      }\n    });\n  }\n  function rr(t, e) {\n    nr(t, function (t, n, r) {\n      var i = 0;\n      if (t.geometry) {\n        var o = t.geometry.type;\n        if (\"Point\" !== o && \"MultiPoint\" !== o) {\n          var s,\n            a = 0,\n            u = 0,\n            l = 0;\n          return !1 !== Qn(t, function (o, c, h, p, f) {\n            if (void 0 === s || n > a || p > u || f > l) return s = o, a = n, u = p, l = f, void (i = 0);\n            var g = Kn.lineString([s, o], t.properties);\n            if (!1 === e(g, n, r, f, i)) return !1;\n            i++, s = o;\n          }) && void 0;\n        }\n      }\n    });\n  }\n  function ir(t, e) {\n    if (!t) throw new Error(\"geojson is required\");\n    nr(t, function (t, n, r) {\n      if (null !== t.geometry) {\n        var i = t.geometry.type,\n          o = t.geometry.coordinates;\n        switch (i) {\n          case \"LineString\":\n            if (!1 === e(t, n, r, 0, 0)) return !1;\n            break;\n          case \"Polygon\":\n            for (var s = 0; s < o.length; s++) if (!1 === e(Kn.lineString(o[s], t.properties), n, r, s)) return !1;\n        }\n      }\n    });\n  }\n  var or = function or(t) {\n      var e = [];\n      return Qn(t, function (t) {\n        e.push(t);\n      }), e;\n    },\n    sr = Qn,\n    ar = function ar(t, e, n, r) {\n      var i = n;\n      return Qn(t, function (t, r, o, s, a) {\n        i = 0 === r && void 0 === n ? t : e(i, t, r, o, s, a);\n      }, r), i;\n    },\n    ur = tr,\n    lr = function lr(t, e, n) {\n      var r = n;\n      return tr(t, function (t, i) {\n        r = 0 === i && void 0 === n ? t : e(r, t, i);\n      }), r;\n    },\n    cr = function cr(t, e) {\n      if (e = e || {}, !Kn.isObject(e)) throw new Error(\"options is invalid\");\n      var n,\n        r = e.featureIndex || 0,\n        i = e.multiFeatureIndex || 0,\n        o = e.geometryIndex || 0,\n        s = e.coordIndex || 0,\n        a = e.properties;\n      switch (t.type) {\n        case \"FeatureCollection\":\n          r < 0 && (r = t.features.length + r), a = a || t.features[r].properties, n = t.features[r].geometry;\n          break;\n        case \"Feature\":\n          a = a || t.properties, n = t.geometry;\n          break;\n        case \"Point\":\n        case \"MultiPoint\":\n          return null;\n        case \"LineString\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\":\n          n = t;\n          break;\n        default:\n          throw new Error(\"geojson is invalid\");\n      }\n      if (null === n) return null;\n      var u = n.coordinates;\n      switch (n.type) {\n        case \"Point\":\n          return Kn.point(u, a, e);\n        case \"MultiPoint\":\n          return i < 0 && (i = u.length + i), Kn.point(u[i], a, e);\n        case \"LineString\":\n          return s < 0 && (s = u.length + s), Kn.point(u[s], a, e);\n        case \"Polygon\":\n          return o < 0 && (o = u.length + o), s < 0 && (s = u[o].length + s), Kn.point(u[o][s], a, e);\n        case \"MultiLineString\":\n          return i < 0 && (i = u.length + i), s < 0 && (s = u[i].length + s), Kn.point(u[i][s], a, e);\n        case \"MultiPolygon\":\n          return i < 0 && (i = u.length + i), o < 0 && (o = u[i].length + o), s < 0 && (s = u[i][o].length - s), Kn.point(u[i][o][s], a, e);\n      }\n      throw new Error(\"geojson is invalid\");\n    },\n    hr = function hr(t, e) {\n      if (e = e || {}, !Kn.isObject(e)) throw new Error(\"options is invalid\");\n      var n,\n        r = e.featureIndex || 0,\n        i = e.multiFeatureIndex || 0,\n        o = e.geometryIndex || 0,\n        s = e.segmentIndex || 0,\n        a = e.properties;\n      switch (t.type) {\n        case \"FeatureCollection\":\n          r < 0 && (r = t.features.length + r), a = a || t.features[r].properties, n = t.features[r].geometry;\n          break;\n        case \"Feature\":\n          a = a || t.properties, n = t.geometry;\n          break;\n        case \"Point\":\n        case \"MultiPoint\":\n          return null;\n        case \"LineString\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\":\n          n = t;\n          break;\n        default:\n          throw new Error(\"geojson is invalid\");\n      }\n      if (null === n) return null;\n      var u = n.coordinates;\n      switch (n.type) {\n        case \"Point\":\n        case \"MultiPoint\":\n          return null;\n        case \"LineString\":\n          return s < 0 && (s = u.length + s - 1), Kn.lineString([u[s], u[s + 1]], a, e);\n        case \"Polygon\":\n          return o < 0 && (o = u.length + o), s < 0 && (s = u[o].length + s - 1), Kn.lineString([u[o][s], u[o][s + 1]], a, e);\n        case \"MultiLineString\":\n          return i < 0 && (i = u.length + i), s < 0 && (s = u[i].length + s - 1), Kn.lineString([u[i][s], u[i][s + 1]], a, e);\n        case \"MultiPolygon\":\n          return i < 0 && (i = u.length + i), o < 0 && (o = u[i].length + o), s < 0 && (s = u[i][o].length - s - 1), Kn.lineString([u[i][o][s], u[i][o][s + 1]], a, e);\n      }\n      throw new Error(\"geojson is invalid\");\n    },\n    pr = nr,\n    fr = function fr(t, e, n) {\n      var r = n;\n      return nr(t, function (t, i, o) {\n        r = 0 === i && 0 === o && void 0 === n ? t : e(r, t, i, o);\n      }), r;\n    },\n    gr = er,\n    dr = function dr(t, e, n) {\n      var r = n;\n      return er(t, function (t, i, o, s, a) {\n        r = 0 === i && void 0 === n ? t : e(r, t, i, o, s, a);\n      }), r;\n    },\n    yr = ir,\n    vr = function vr(t, e, n) {\n      var r = n;\n      return ir(t, function (t, i, o, s) {\n        r = 0 === i && void 0 === n ? t : e(r, t, i, o, s);\n      }), r;\n    },\n    _r = $n,\n    mr = function mr(t, e, n) {\n      var r = n;\n      return $n(t, function (t, i) {\n        r = 0 === i && void 0 === n ? t : e(r, t, i);\n      }), r;\n    },\n    xr = rr,\n    Er = function Er(t, e, n) {\n      var r = n,\n        i = !1;\n      return rr(t, function (t, o, s, a, u) {\n        r = !1 === i && void 0 === n ? t : e(r, t, o, s, a, u), i = !0;\n      }), r;\n    },\n    br = Object.defineProperty({\n      coordAll: or,\n      coordEach: sr,\n      coordReduce: ar,\n      featureEach: ur,\n      featureReduce: lr,\n      findPoint: cr,\n      findSegment: hr,\n      flattenEach: pr,\n      flattenReduce: fr,\n      geomEach: gr,\n      geomReduce: dr,\n      lineEach: yr,\n      lineReduce: vr,\n      propEach: _r,\n      propReduce: mr,\n      segmentEach: xr,\n      segmentReduce: Er\n    }, \"__esModule\", {\n      value: !0\n    });\n  function wr(t) {\n    var e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n    return br.coordEach(t, function (t) {\n      e[0] > t[0] && (e[0] = t[0]), e[1] > t[1] && (e[1] = t[1]), e[2] < t[0] && (e[2] = t[0]), e[3] < t[1] && (e[3] = t[1]);\n    }), e;\n  }\n  wr.default = wr;\n  var Ir = wr,\n    Nr = Object.defineProperty({\n      default: Ir\n    }, \"__esModule\", {\n      value: !0\n    }).default,\n    Sr = br.featureEach,\n    Cr = (br.coordEach, Kn.polygon, Kn.featureCollection);\n  function Pr(t) {\n    var e = Nt(t);\n    return e.insert = function (t) {\n      if (\"Feature\" !== t.type) throw new Error(\"invalid feature\");\n      return t.bbox = t.bbox ? t.bbox : Nr(t), Nt.prototype.insert.call(this, t);\n    }, e.load = function (t) {\n      var e = [];\n      return Array.isArray(t) ? t.forEach(function (t) {\n        if (\"Feature\" !== t.type) throw new Error(\"invalid features\");\n        t.bbox = t.bbox ? t.bbox : Nr(t), e.push(t);\n      }) : Sr(t, function (t) {\n        if (\"Feature\" !== t.type) throw new Error(\"invalid features\");\n        t.bbox = t.bbox ? t.bbox : Nr(t), e.push(t);\n      }), Nt.prototype.load.call(this, e);\n    }, e.remove = function (t, e) {\n      if (\"Feature\" !== t.type) throw new Error(\"invalid feature\");\n      return t.bbox = t.bbox ? t.bbox : Nr(t), Nt.prototype.remove.call(this, t, e);\n    }, e.clear = function () {\n      return Nt.prototype.clear.call(this);\n    }, e.search = function (t) {\n      var e = Nt.prototype.search.call(this, this.toBBox(t));\n      return Cr(e);\n    }, e.collides = function (t) {\n      return Nt.prototype.collides.call(this, this.toBBox(t));\n    }, e.all = function () {\n      var t = Nt.prototype.all.call(this);\n      return Cr(t);\n    }, e.toJSON = function () {\n      return Nt.prototype.toJSON.call(this);\n    }, e.fromJSON = function (t) {\n      return Nt.prototype.fromJSON.call(this, t);\n    }, e.toBBox = function (t) {\n      var e;\n      if (t.bbox) e = t.bbox;else if (Array.isArray(t) && 4 === t.length) e = t;else if (Array.isArray(t) && 6 === t.length) e = [t[0], t[1], t[3], t[4]];else if (\"Feature\" === t.type) e = Nr(t);else {\n        if (\"FeatureCollection\" !== t.type) throw new Error(\"invalid geojson\");\n        e = Nr(t);\n      }\n      return {\n        minX: e[0],\n        minY: e[1],\n        maxX: e[2],\n        maxY: e[3]\n      };\n    }, e;\n  }\n  var Mr = Pr,\n    Lr = Pr;\n  function Or(t, e) {\n    var n = {},\n      r = [];\n    if (\"LineString\" === t.type && (t = o(t)), \"LineString\" === e.type && (e = o(e)), \"Feature\" === t.type && \"Feature\" === e.type && null !== t.geometry && null !== e.geometry && \"LineString\" === t.geometry.type && \"LineString\" === e.geometry.type && 2 === t.geometry.coordinates.length && 2 === e.geometry.coordinates.length) {\n      var i = Rr(t, e);\n      return i && r.push(i), f(r);\n    }\n    var s = Mr();\n    return s.load(Zn(e)), F(Zn(t), function (t) {\n      F(s.search(t), function (e) {\n        var i = Rr(t, e);\n        if (i) {\n          var o = Q(i).join(\",\");\n          n[o] || (n[o] = !0, r.push(i));\n        }\n      });\n    }), f(r);\n  }\n  function Rr(t, e) {\n    var n = Q(t),\n      r = Q(e);\n    if (2 !== n.length) throw new Error(\"<intersects> line1 must only contain 2 coordinates\");\n    if (2 !== r.length) throw new Error(\"<intersects> line2 must only contain 2 coordinates\");\n    var i = n[0][0],\n      o = n[0][1],\n      s = n[1][0],\n      u = n[1][1],\n      l = r[0][0],\n      c = r[0][1],\n      h = r[1][0],\n      p = r[1][1],\n      f = (p - c) * (s - i) - (h - l) * (u - o),\n      g = (h - l) * (o - c) - (p - c) * (i - l),\n      d = (s - i) * (o - c) - (u - o) * (i - l);\n    if (0 === f) return null;\n    var y = g / f,\n      v = d / f;\n    return y >= 0 && y <= 1 && v >= 0 && v <= 1 ? a([i + y * (s - i), o + y * (u - o)]) : null;\n  }\n  function Tr(t, e, n) {\n    void 0 === n && (n = {});\n    var r = a([1 / 0, 1 / 0], {\n        dist: 1 / 0\n      }),\n      i = 0;\n    return z(t, function (t) {\n      for (var o = Q(t), s = 0; s < o.length - 1; s++) {\n        var u = a(o[s]);\n        u.properties.dist = me(e, u, n);\n        var l = a(o[s + 1]);\n        l.properties.dist = me(e, l, n);\n        var c = me(u, l, n),\n          p = Math.max(u.properties.dist, l.properties.dist),\n          f = mn(u, l),\n          g = vn(e, p, f + 90, n),\n          d = vn(e, p, f - 90, n),\n          y = Or(h([g.geometry.coordinates, d.geometry.coordinates]), h([u.geometry.coordinates, l.geometry.coordinates])),\n          v = null;\n        y.features.length > 0 && ((v = y.features[0]).properties.dist = me(e, v, n), v.properties.location = i + me(u, v, n)), u.properties.dist < r.properties.dist && ((r = u).properties.index = s, r.properties.location = i), l.properties.dist < r.properties.dist && ((r = l).properties.index = s + 1, r.properties.location = i + c), v && v.properties.dist < r.properties.dist && ((r = v).properties.index = s), i += c;\n      }\n    }), r;\n  }\n  function Ar(t, n, r) {\n    void 0 === r && (r = {});\n    var i = K(t),\n      o = K(n);\n    return o[0] += o[0] - i[0] > 180 ? -360 : i[0] - o[0] > 180 ? 360 : 0, N(function (t, n, r) {\n      var i = r = void 0 === r ? e : Number(r),\n        o = t[1] * Math.PI / 180,\n        s = n[1] * Math.PI / 180,\n        a = s - o,\n        u = Math.abs(n[0] - t[0]) * Math.PI / 180;\n      u > Math.PI && (u -= 2 * Math.PI);\n      var l = Math.log(Math.tan(s / 2 + Math.PI / 4) / Math.tan(o / 2 + Math.PI / 4)),\n        c = Math.abs(l) > 1e-11 ? a / l : Math.cos(o);\n      return Math.sqrt(a * a + c * c * u * u) * i;\n    }(i, o), \"meters\", r.units);\n  }\n  function Dr(t, e, n) {\n    if (void 0 === n && (n = {}), n.method || (n.method = \"geodesic\"), n.units || (n.units = \"kilometers\"), !t) throw new Error(\"pt is required\");\n    if (Array.isArray(t) ? t = a(t) : \"Point\" === t.type ? t = o(t) : et(t, \"Point\", \"point\"), !e) throw new Error(\"line is required\");\n    Array.isArray(e) ? e = h(e) : \"LineString\" === e.type ? e = o(e) : et(e, \"LineString\", \"line\");\n    var r = 1 / 0,\n      i = t.geometry.coordinates;\n    return U(e, function (t) {\n      var e = t.geometry.coordinates[0],\n        o = t.geometry.coordinates[1],\n        s = function (t, e, n, r) {\n          var i = [n[0] - e[0], n[1] - e[1]],\n            o = Fr([t[0] - e[0], t[1] - e[1]], i);\n          if (o <= 0) return kr(t, e, {\n            method: r.method,\n            units: \"degrees\"\n          });\n          var s = Fr(i, i);\n          if (s <= o) return kr(t, n, {\n            method: r.method,\n            units: \"degrees\"\n          });\n          var a = o / s,\n            u = [e[0] + a * i[0], e[1] + a * i[1]];\n          return kr(t, u, {\n            method: r.method,\n            units: \"degrees\"\n          });\n        }(i, e, o, n);\n      s < r && (r = s);\n    }), N(r, \"degrees\", n.units);\n  }\n  function Fr(t, e) {\n    return t[0] * e[0] + t[1] * e[1];\n  }\n  function kr(t, e, n) {\n    return \"planar\" === n.method ? Ar(t, e, n) : me(t, e, n);\n  }\n  function Gr(t, e, n, r, i, o, s, a) {\n    var u,\n      l,\n      c,\n      h,\n      p = {\n        x: null,\n        y: null,\n        onLine1: !1,\n        onLine2: !1\n      };\n    return 0 === (u = (a - o) * (n - t) - (s - i) * (r - e)) ? null !== p.x && null !== p.y && p : (h = (n - t) * (l = e - o) - (r - e) * (c = t - i), l = ((s - i) * l - (a - o) * c) / u, c = h / u, p.x = t + l * (n - t), p.y = e + l * (r - e), l >= 0 && l <= 1 && (p.onLine1 = !0), c >= 0 && c <= 1 && (p.onLine2 = !0), !(!p.onLine1 || !p.onLine2) && [p.x, p.y]);\n  }\n  function qr(t) {\n    for (var e = function (t) {\n        if (\"FeatureCollection\" !== t.type) return \"Feature\" !== t.type ? f([o(t)]) : f([t]);\n        return t;\n      }(t), n = xn(e), r = !1, i = 0; !r && i < e.features.length;) {\n      var s,\n        u = e.features[i].geometry,\n        l = !1;\n      if (\"Point\" === u.type) n.geometry.coordinates[0] === u.coordinates[0] && n.geometry.coordinates[1] === u.coordinates[1] && (r = !0);else if (\"MultiPoint\" === u.type) {\n        var c = !1;\n        for (s = 0; !c && s < u.coordinates.length;) n.geometry.coordinates[0] === u.coordinates[s][0] && n.geometry.coordinates[1] === u.coordinates[s][1] && (r = !0, c = !0), s++;\n      } else if (\"LineString\" === u.type) for (s = 0; !l && s < u.coordinates.length - 1;) Br(n.geometry.coordinates[0], n.geometry.coordinates[1], u.coordinates[s][0], u.coordinates[s][1], u.coordinates[s + 1][0], u.coordinates[s + 1][1]) && (l = !0, r = !0), s++;else if (\"MultiLineString\" === u.type) for (var h = 0; h < u.coordinates.length;) {\n        l = !1, s = 0;\n        for (var p = u.coordinates[h]; !l && s < p.length - 1;) Br(n.geometry.coordinates[0], n.geometry.coordinates[1], p[s][0], p[s][1], p[s + 1][0], p[s + 1][1]) && (l = !0, r = !0), s++;\n        h++;\n      } else \"Polygon\" !== u.type && \"MultiPolygon\" !== u.type || ye(n, u) && (r = !0);\n      i++;\n    }\n    if (r) return n;\n    var g = f([]);\n    for (i = 0; i < e.features.length; i++) g.features = g.features.concat(bn(e.features[i]).features);\n    return a(Jn(n, g).geometry.coordinates);\n  }\n  function Br(t, e, n, r, i, o) {\n    return Math.sqrt((i - n) * (i - n) + (o - r) * (o - r)) === Math.sqrt((t - n) * (t - n) + (e - r) * (e - r)) + Math.sqrt((i - t) * (i - t) + (o - e) * (o - e));\n  }\n  Mr.default = Lr;\n  var zr = 6378137;\n  function jr(t) {\n    return B(t, function (t, e) {\n      return t + function (t) {\n        var e,\n          n = 0;\n        switch (t.type) {\n          case \"Polygon\":\n            return Ur(t.coordinates);\n          case \"MultiPolygon\":\n            for (e = 0; e < t.coordinates.length; e++) n += Ur(t.coordinates[e]);\n            return n;\n          case \"Point\":\n          case \"MultiPoint\":\n          case \"LineString\":\n          case \"MultiLineString\":\n            return 0;\n        }\n        return 0;\n      }(e);\n    }, 0);\n  }\n  function Ur(t) {\n    var e = 0;\n    if (t && t.length > 0) {\n      e += Math.abs(Vr(t[0]));\n      for (var n = 1; n < t.length; n++) e -= Math.abs(Vr(t[n]));\n    }\n    return e;\n  }\n  function Vr(t) {\n    var e,\n      n,\n      r,\n      i,\n      o,\n      s,\n      a = 0,\n      u = t.length;\n    if (u > 2) {\n      for (s = 0; s < u; s++) s === u - 2 ? (r = u - 2, i = u - 1, o = 0) : s === u - 1 ? (r = u - 1, i = 0, o = 1) : (r = s, i = s + 1, o = s + 2), e = t[r], n = t[i], a += (Xr(t[o][0]) - Xr(e[0])) * Math.sin(Xr(n[1]));\n      a = a * zr * zr / 2;\n    }\n    return a;\n  }\n  function Xr(t) {\n    return t * Math.PI / 180;\n  }\n  function Yr(t, e) {\n    return void 0 === e && (e = {}), V(t, function (t, n) {\n      var r = n.geometry.coordinates;\n      return t + me(r[0], r[1], e);\n    }, 0);\n  }\n  function Hr(t, e, n, r) {\n    if (!P(r = r || {})) throw new Error(\"options is invalid\");\n    var i,\n      o = [];\n    if (\"Feature\" === t.type) i = t.geometry.coordinates;else {\n      if (\"LineString\" !== t.type) throw new Error(\"input must be a LineString Feature or Geometry\");\n      i = t.coordinates;\n    }\n    for (var s, a, u, l = i.length, c = 0, p = 0; p < i.length && !(e >= c && p === i.length - 1); p++) {\n      if (c > e && 0 === o.length) {\n        if (!(s = e - c)) return o.push(i[p]), h(o);\n        a = mn(i[p], i[p - 1]) - 180, u = vn(i[p], s, a, r), o.push(u.geometry.coordinates);\n      }\n      if (c >= n) return (s = n - c) ? (a = mn(i[p], i[p - 1]) - 180, u = vn(i[p], s, a, r), o.push(u.geometry.coordinates), h(o)) : (o.push(i[p]), h(o));\n      if (c >= e && o.push(i[p]), p === i.length - 1) return h(o);\n      c += me(i[p], i[p + 1], r);\n    }\n    if (c < e && i.length === l) throw new Error(\"Start position is beyond line\");\n    var f = i[i.length - 1];\n    return h([f, f]);\n  }\n  function Wr(t, e, n) {\n    void 0 === n && (n = {});\n    for (var r = K(t), i = Q(e), o = 0; o < i.length - 1; o++) {\n      var s = !1;\n      if (n.ignoreEndVertices && (0 === o && (s = \"start\"), o === i.length - 2 && (s = \"end\"), 0 === o && o + 1 === i.length - 1 && (s = \"both\")), Jr(i[o], i[o + 1], r, s, void 0 === n.epsilon ? null : n.epsilon)) return !0;\n    }\n    return !1;\n  }\n  function Jr(t, e, n, r, i) {\n    var o = n[0],\n      s = n[1],\n      a = t[0],\n      u = t[1],\n      l = e[0],\n      c = e[1],\n      h = l - a,\n      p = c - u,\n      f = (n[0] - a) * p - (n[1] - u) * h;\n    if (null !== i) {\n      if (Math.abs(f) > i) return !1;\n    } else if (0 !== f) return !1;\n    return r ? \"start\" === r ? Math.abs(h) >= Math.abs(p) ? h > 0 ? a < o && o <= l : l <= o && o < a : p > 0 ? u < s && s <= c : c <= s && s < u : \"end\" === r ? Math.abs(h) >= Math.abs(p) ? h > 0 ? a <= o && o < l : l < o && o <= a : p > 0 ? u <= s && s < c : c < s && s <= u : \"both\" === r && (Math.abs(h) >= Math.abs(p) ? h > 0 ? a < o && o < l : l < o && o < a : p > 0 ? u < s && s < c : c < s && s < u) : Math.abs(h) >= Math.abs(p) ? h > 0 ? a <= o && o <= l : l <= o && o <= a : p > 0 ? u <= s && s <= c : c <= s && s <= u;\n  }\n  function Zr(t, e) {\n    var n = rt(t),\n      r = rt(e),\n      i = n.type,\n      o = r.type;\n    switch (i) {\n      case \"Point\":\n        switch (o) {\n          case \"MultiPoint\":\n            return function (t, e) {\n              var n,\n                r = !1;\n              for (n = 0; n < e.coordinates.length; n++) if (Qr(e.coordinates[n], t.coordinates)) {\n                r = !0;\n                break;\n              }\n              return r;\n            }(n, r);\n          case \"LineString\":\n            return Wr(n, r, {\n              ignoreEndVertices: !0\n            });\n          case \"Polygon\":\n          case \"MultiPolygon\":\n            return ye(n, r, {\n              ignoreBoundary: !0\n            });\n          default:\n            throw new Error(\"feature2 \" + o + \" geometry not supported\");\n        }\n      case \"MultiPoint\":\n        switch (o) {\n          case \"MultiPoint\":\n            return function (t, e) {\n              for (var n = 0; n < t.coordinates.length; n++) {\n                for (var r = !1, i = 0; i < e.coordinates.length; i++) Qr(t.coordinates[n], e.coordinates[i]) && (r = !0);\n                if (!r) return !1;\n              }\n              return !0;\n            }(n, r);\n          case \"LineString\":\n            return function (t, e) {\n              for (var n = !1, r = 0; r < t.coordinates.length; r++) {\n                if (!Wr(t.coordinates[r], e)) return !1;\n                n || (n = Wr(t.coordinates[r], e, {\n                  ignoreEndVertices: !0\n                }));\n              }\n              return n;\n            }(n, r);\n          case \"Polygon\":\n          case \"MultiPolygon\":\n            return function (t, e) {\n              for (var n = !0, r = !1, i = 0; i < t.coordinates.length; i++) {\n                if (!(r = ye(t.coordinates[1], e))) {\n                  n = !1;\n                  break;\n                }\n                r = ye(t.coordinates[1], e, {\n                  ignoreBoundary: !0\n                });\n              }\n              return n && r;\n            }(n, r);\n          default:\n            throw new Error(\"feature2 \" + o + \" geometry not supported\");\n        }\n      case \"LineString\":\n        switch (o) {\n          case \"LineString\":\n            return function (t, e) {\n              for (var n = 0; n < t.coordinates.length; n++) if (!Wr(t.coordinates[n], e)) return !1;\n              return !0;\n            }(n, r);\n          case \"Polygon\":\n          case \"MultiPolygon\":\n            return function (t, e) {\n              var n = Z(e),\n                r = Z(t);\n              if (!Kr(n, r)) return !1;\n              for (var i = !1, o = 0; o < t.coordinates.length - 1; o++) {\n                if (!ye(t.coordinates[o], e)) return !1;\n                if (i || (i = ye(t.coordinates[o], e, {\n                  ignoreBoundary: !0\n                })), !i) i = ye($r(t.coordinates[o], t.coordinates[o + 1]), e, {\n                  ignoreBoundary: !0\n                });\n              }\n              return i;\n            }(n, r);\n          default:\n            throw new Error(\"feature2 \" + o + \" geometry not supported\");\n        }\n      case \"Polygon\":\n        switch (o) {\n          case \"Polygon\":\n          case \"MultiPolygon\":\n            return function (t, e) {\n              var n = Z(t);\n              if (!Kr(Z(e), n)) return !1;\n              for (var r = 0; r < t.coordinates[0].length; r++) if (!ye(t.coordinates[0][r], e)) return !1;\n              return !0;\n            }(n, r);\n          default:\n            throw new Error(\"feature2 \" + o + \" geometry not supported\");\n        }\n      default:\n        throw new Error(\"feature1 \" + i + \" geometry not supported\");\n    }\n  }\n  function Kr(t, e) {\n    return !(t[0] > e[0]) && !(t[2] < e[2]) && !(t[1] > e[1]) && !(t[3] < e[3]);\n  }\n  function Qr(t, e) {\n    return t[0] === e[0] && t[1] === e[1];\n  }\n  function $r(t, e) {\n    return [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2];\n  }\n  function ti(t, e, n) {\n    void 0 === n && (n = {}), n.mask && !n.units && (n.units = \"kilometers\");\n    for (var r = [], i = t[0], o = t[1], s = t[2], u = t[3], l = e / me([i, o], [s, o], n) * (s - i), c = e / me([i, o], [i, u], n) * (u - o), h = s - i, p = u - o, g = Math.floor(h / l), d = (p - Math.floor(p / c) * c) / 2, y = i + (h - g * l) / 2; y <= s;) {\n      for (var v = o + d; v <= u;) {\n        var _ = a([y, v], n.properties);\n        n.mask ? Zr(_, n.mask) && r.push(_) : r.push(_), v += c;\n      }\n      y += l;\n    }\n    return f(r);\n  }\n  function ei(t, e) {\n    void 0 === e && (e = {});\n    var n = e.precision,\n      r = e.coordinates,\n      i = e.mutate;\n    if (n = null == n || isNaN(n) ? 6 : n, r = null == r || isNaN(r) ? 3 : r, !t) throw new Error(\"<geojson> is required\");\n    if (\"number\" != typeof n) throw new Error(\"<precision> must be a number\");\n    if (\"number\" != typeof r) throw new Error(\"<coordinates> must be a number\");\n    !1 !== i && void 0 !== i || (t = JSON.parse(JSON.stringify(t)));\n    var o = Math.pow(10, n);\n    return R(t, function (t) {\n      !function (t, e, n) {\n        t.length > n && t.splice(n, t.length);\n        for (var r = 0; r < t.length; r++) t[r] = Math.round(t[r] * e) / e;\n      }(t, o, r);\n    }), t;\n  }\n  function ni(t) {\n    if (!t) throw new Error(\"geojson is required\");\n    var e = [];\n    return z(t, function (t) {\n      e.push(t);\n    }), f(e);\n  }\n  function ri(t, e, n) {\n    if (\"Polygon\" !== t.geometry.type) throw new Error(\"The input feature must be a Polygon\");\n    void 0 === n && (n = 1);\n    var r = t.geometry.coordinates,\n      i = [],\n      o = {};\n    if (n) {\n      for (var s = [], a = 0; a < r.length; a++) for (var u = 0; u < r[a].length - 1; u++) s.push(d(a, u));\n      var l = Nt();\n      l.load(s);\n    }\n    for (var c = 0; c < r.length; c++) for (var h = 0; h < r[c].length - 1; h++) {\n      if (n) l.search(d(c, h)).forEach(function (t) {\n        var e = t.ring,\n          n = t.edge;\n        g(c, h, e, n);\n      });else for (var p = 0; p < r.length; p++) for (var f = 0; f < r[p].length - 1; f++) g(c, h, p, f);\n    }\n    return e || (i = {\n      type: \"Feature\",\n      geometry: {\n        type: \"MultiPoint\",\n        coordinates: i\n      }\n    }), i;\n    function g(t, n, s, a) {\n      var u,\n        l,\n        c = r[t][n],\n        h = r[t][n + 1],\n        p = r[s][a],\n        f = r[s][a + 1],\n        g = function (t, e, n, r) {\n          if (ii(t, n) || ii(t, r) || ii(e, n) || ii(r, n)) return null;\n          var i = t[0],\n            o = t[1],\n            s = e[0],\n            a = e[1],\n            u = n[0],\n            l = n[1],\n            c = r[0],\n            h = r[1],\n            p = (i - s) * (l - h) - (o - a) * (u - c);\n          return 0 === p ? null : [((i * a - o * s) * (u - c) - (i - s) * (u * h - l * c)) / p, ((i * a - o * s) * (l - h) - (o - a) * (u * h - l * c)) / p];\n        }(c, h, p, f);\n      if (null !== g && (u = h[0] !== c[0] ? (g[0] - c[0]) / (h[0] - c[0]) : (g[1] - c[1]) / (h[1] - c[1]), l = f[0] !== p[0] ? (g[0] - p[0]) / (f[0] - p[0]) : (g[1] - p[1]) / (f[1] - p[1]), !(u >= 1 || u <= 0 || l >= 1 || l <= 0))) {\n        var d = g,\n          y = !o[d];\n        y && (o[d] = !0), e ? i.push(e(g, t, n, c, h, u, s, a, p, f, l, y)) : i.push(g);\n      }\n    }\n    function d(t, e) {\n      var n,\n        i,\n        o,\n        s,\n        a = r[t][e],\n        u = r[t][e + 1];\n      return a[0] < u[0] ? (n = a[0], i = u[0]) : (n = u[0], i = a[0]), a[1] < u[1] ? (o = a[1], s = u[1]) : (o = u[1], s = a[1]), {\n        minX: n,\n        minY: o,\n        maxX: i,\n        maxY: s,\n        ring: t,\n        edge: e\n      };\n    }\n  }\n  function ii(t, e) {\n    if (!t || !e) return !1;\n    if (t.length !== e.length) return !1;\n    for (var n = 0, r = t.length; n < r; n++) if (t[n] instanceof Array && e[n] instanceof Array) {\n      if (!ii(t[n], e[n])) return !1;\n    } else if (t[n] !== e[n]) return !1;\n    return !0;\n  }\n  function oi(t) {\n    if (\"Feature\" != t.type) throw new Error(\"The input must a geojson object of type Feature\");\n    if (void 0 === t.geometry || null == t.geometry) throw new Error(\"The input must a geojson object with a non-empty geometry\");\n    if (\"Polygon\" != t.geometry.type) throw new Error(\"The input must be a geojson Polygon\");\n    for (var e = t.geometry.coordinates.length, n = [], r = 0; r < e; r++) {\n      var i = t.geometry.coordinates[r];\n      ci(i[0], i[i.length - 1]) || i.push(i[0]), n.push.apply(n, i.slice(0, i.length - 1));\n    }\n    if (!function (t) {\n      for (var e = {}, n = 1, r = 0, i = t.length; r < i; ++r) {\n        if (Object.prototype.hasOwnProperty.call(e, t[r])) {\n          n = 0;\n          break;\n        }\n        e[t[r]] = 1;\n      }\n      return n;\n    }(n)) throw new Error(\"The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)\");\n    var o = n.length,\n      s = ri(t, function (t, e, n, r, i, o, s, a, u, l, c, h) {\n        return [t, e, n, r, i, o, s, a, u, l, c, h];\n      }),\n      a = s.length;\n    if (0 == a) {\n      var u = [];\n      for (r = 0; r < e; r++) u.push(l([t.geometry.coordinates[r]], {\n        parent: -1,\n        winding: li(t.geometry.coordinates[r])\n      }));\n      var c = f(u);\n      return G(), q(), c;\n    }\n    var h = [],\n      p = [];\n    for (r = 0; r < e; r++) {\n      h.push([]);\n      for (var g = 0; g < t.geometry.coordinates[r].length - 1; g++) h[r].push([new si(t.geometry.coordinates[r][hi(g + 1, t.geometry.coordinates[r].length - 1)], 1, [r, g], [r, hi(g + 1, t.geometry.coordinates[r].length - 1)], void 0)]), p.push(new ai(t.geometry.coordinates[r][g], [r, hi(g - 1, t.geometry.coordinates[r].length - 1)], [r, g], void 0, void 0, !1, !0));\n    }\n    for (r = 0; r < a; r++) h[s[r][1]][s[r][2]].push(new si(s[r][0], s[r][5], [s[r][1], s[r][2]], [s[r][6], s[r][7]], void 0)), s[r][11] && p.push(new ai(s[r][0], [s[r][1], s[r][2]], [s[r][6], s[r][7]], void 0, void 0, !0, !0));\n    var d = p.length;\n    for (r = 0; r < h.length; r++) for (g = 0; g < h[r].length; g++) h[r][g].sort(function (t, e) {\n      return t.param < e.param ? -1 : 1;\n    });\n    var y = [];\n    for (r = 0; r < d; r++) y.push({\n      minX: p[r].coord[0],\n      minY: p[r].coord[1],\n      maxX: p[r].coord[0],\n      maxY: p[r].coord[1],\n      index: r\n    });\n    var v = Nt();\n    v.load(y);\n    for (r = 0; r < h.length; r++) for (g = 0; g < h[r].length; g++) for (var _ = 0; _ < h[r][g].length; _++) {\n      x = _ == h[r][g].length - 1 ? h[r][hi(g + 1, t.geometry.coordinates[r].length - 1)][0].coord : h[r][g][_ + 1].coord;\n      var m = v.search({\n        minX: x[0],\n        minY: x[1],\n        maxX: x[0],\n        maxY: x[1]\n      })[0];\n      h[r][g][_].nxtIsectAlongEdgeIn = m.index;\n    }\n    for (r = 0; r < h.length; r++) for (g = 0; g < h[r].length; g++) for (_ = 0; _ < h[r][g].length; _++) {\n      var x = h[r][g][_].coord,\n        E = (m = v.search({\n          minX: x[0],\n          minY: x[1],\n          maxX: x[0],\n          maxY: x[1]\n        })[0]).index;\n      E < o ? p[E].nxtIsectAlongRingAndEdge2 = h[r][g][_].nxtIsectAlongEdgeIn : ci(p[E].ringAndEdge1, h[r][g][_].ringAndEdgeIn) ? p[E].nxtIsectAlongRingAndEdge1 = h[r][g][_].nxtIsectAlongEdgeIn : p[E].nxtIsectAlongRingAndEdge2 = h[r][g][_].nxtIsectAlongEdgeIn;\n    }\n    var b = [];\n    for (r = 0, g = 0; g < e; g++) {\n      var w = r;\n      for (_ = 0; _ < t.geometry.coordinates[g].length - 1; _++) p[r].coord[0] < p[w].coord[0] && (w = r), r++;\n      var I = p[w].nxtIsectAlongRingAndEdge2;\n      for (_ = 0; _ < p.length; _++) if (p[_].nxtIsectAlongRingAndEdge1 == w || p[_].nxtIsectAlongRingAndEdge2 == w) {\n        var N = _;\n        break;\n      }\n      var S = ui([p[N].coord, p[w].coord, p[I].coord], !0) ? 1 : -1;\n      b.push({\n        isect: w,\n        parent: -1,\n        winding: S\n      });\n    }\n    b.sort(function (t, e) {\n      return p[t.isect].coord > p[e.isect].coord ? -1 : 1;\n    });\n    for (u = []; b.length > 0;) {\n      var C = b.pop(),\n        P = C.isect,\n        M = C.parent,\n        L = C.winding,\n        O = u.length,\n        R = [p[P].coord],\n        T = P;\n      if (p[P].ringAndEdge1Walkable) var A = p[P].ringAndEdge1,\n        D = p[P].nxtIsectAlongRingAndEdge1;else A = p[P].ringAndEdge2, D = p[P].nxtIsectAlongRingAndEdge2;\n      for (; !ci(p[P].coord, p[D].coord);) {\n        R.push(p[D].coord);\n        var F = void 0;\n        for (r = 0; r < b.length; r++) if (b[r].isect == D) {\n          F = r;\n          break;\n        }\n        if (null != F && b.splice(F, 1), ci(A, p[D].ringAndEdge1)) {\n          if (A = p[D].ringAndEdge2, p[D].ringAndEdge2Walkable = !1, p[D].ringAndEdge1Walkable) {\n            var k = {\n              isect: D\n            };\n            ui([p[T].coord, p[D].coord, p[p[D].nxtIsectAlongRingAndEdge2].coord], 1 == L) ? (k.parent = M, k.winding = -L) : (k.parent = O, k.winding = L), b.push(k);\n          }\n          T = D, D = p[D].nxtIsectAlongRingAndEdge2;\n        } else {\n          if (A = p[D].ringAndEdge1, p[D].ringAndEdge1Walkable = !1, p[D].ringAndEdge2Walkable) {\n            k = {\n              isect: D\n            };\n            ui([p[T].coord, p[D].coord, p[p[D].nxtIsectAlongRingAndEdge1].coord], 1 == L) ? (k.parent = M, k.winding = -L) : (k.parent = O, k.winding = L), b.push(k);\n          }\n          T = D, D = p[D].nxtIsectAlongRingAndEdge1;\n        }\n      }\n      R.push(p[D].coord), u.push(l([R], {\n        index: O,\n        parent: M,\n        winding: L,\n        netWinding: void 0\n      }));\n    }\n    c = f(u);\n    function G() {\n      for (var t = [], e = 0; e < c.features.length; e++) -1 == c.features[e].properties.parent && t.push(e);\n      if (t.length > 1) for (e = 0; e < t.length; e++) {\n        for (var n = -1, r = 0; r < c.features.length; r++) t[e] != r && ye(c.features[t[e]].geometry.coordinates[0][0], c.features[r], {\n          ignoreBoundary: !0\n        }) && jr(c.features[r]) < Infinity && (n = r);\n        c.features[t[e]].properties.parent = n;\n      }\n    }\n    function q() {\n      for (var t = 0; t < c.features.length; t++) if (-1 == c.features[t].properties.parent) {\n        var e = c.features[t].properties.winding;\n        c.features[t].properties.netWinding = e, B(t, e);\n      }\n    }\n    function B(t, e) {\n      for (var n = 0; n < c.features.length; n++) if (c.features[n].properties.parent == t) {\n        var r = e + c.features[n].properties.winding;\n        c.features[n].properties.netWinding = r, B(n, r);\n      }\n    }\n    return G(), q(), c;\n  }\n  var si = function si(t, e, n, r, i) {\n      this.coord = t, this.param = e, this.ringAndEdgeIn = n, this.ringAndEdgeOut = r, this.nxtIsectAlongEdgeIn = i;\n    },\n    ai = function ai(t, e, n, r, i, o, s) {\n      this.coord = t, this.ringAndEdge1 = e, this.ringAndEdge2 = n, this.nxtIsectAlongRingAndEdge1 = r, this.nxtIsectAlongRingAndEdge2 = i, this.ringAndEdge1Walkable = o, this.ringAndEdge2Walkable = s;\n    };\n  function ui(t, e) {\n    if (void 0 === e && (e = !0), 3 != t.length) throw new Error(\"This function requires an array of three points [x,y]\");\n    return (t[1][0] - t[0][0]) * (t[2][1] - t[0][1]) - (t[1][1] - t[0][1]) * (t[2][0] - t[0][0]) >= 0 == e;\n  }\n  function li(t) {\n    for (var e = 0, n = 0; n < t.length - 1; n++) t[n][0] < t[e][0] && (e = n);\n    if (ui([t[hi(e - 1, t.length - 1)], t[e], t[hi(e + 1, t.length - 1)]], !0)) var r = 1;else r = -1;\n    return r;\n  }\n  function ci(t, e) {\n    if (!t || !e) return !1;\n    if (t.length != e.length) return !1;\n    for (var n = 0, r = t.length; n < r; n++) if (t[n] instanceof Array && e[n] instanceof Array) {\n      if (!ci(t[n], e[n])) return !1;\n    } else if (t[n] != e[n]) return !1;\n    return !0;\n  }\n  function hi(t, e) {\n    return (t % e + e) % e;\n  }\n  var pi = Math.PI / 180,\n    fi = 180 / Math.PI,\n    gi = function gi(t, e) {\n      this.lon = t, this.lat = e, this.x = pi * t, this.y = pi * e;\n    };\n  gi.prototype.view = function () {\n    return String(this.lon).slice(0, 4) + \",\" + String(this.lat).slice(0, 4);\n  }, gi.prototype.antipode = function () {\n    var t = -1 * this.lat,\n      e = this.lon < 0 ? 180 + this.lon : -1 * (180 - this.lon);\n    return new gi(e, t);\n  };\n  var di = function di() {\n    this.coords = [], this.length = 0;\n  };\n  di.prototype.move_to = function (t) {\n    this.length++, this.coords.push(t);\n  };\n  var yi = function yi(t) {\n    this.properties = t || {}, this.geometries = [];\n  };\n  yi.prototype.json = function () {\n    if (this.geometries.length <= 0) return {\n      geometry: {\n        type: \"LineString\",\n        coordinates: null\n      },\n      type: \"Feature\",\n      properties: this.properties\n    };\n    if (1 === this.geometries.length) return {\n      geometry: {\n        type: \"LineString\",\n        coordinates: this.geometries[0].coords\n      },\n      type: \"Feature\",\n      properties: this.properties\n    };\n    for (var t = [], e = 0; e < this.geometries.length; e++) t.push(this.geometries[e].coords);\n    return {\n      geometry: {\n        type: \"MultiLineString\",\n        coordinates: t\n      },\n      type: \"Feature\",\n      properties: this.properties\n    };\n  }, yi.prototype.wkt = function () {\n    for (var t = \"\", e = \"LINESTRING(\", n = function n(t) {\n        e += t[0] + \" \" + t[1] + \",\";\n      }, r = 0; r < this.geometries.length; r++) {\n      if (0 === this.geometries[r].coords.length) return \"LINESTRING(empty)\";\n      this.geometries[r].coords.forEach(n), t += e.substring(0, e.length - 1) + \")\";\n    }\n    return t;\n  };\n  var vi = function vi(t, e, n) {\n    if (!t || void 0 === t.x || void 0 === t.y) throw new Error(\"GreatCircle constructor expects two args: start and end objects with x and y properties\");\n    if (!e || void 0 === e.x || void 0 === e.y) throw new Error(\"GreatCircle constructor expects two args: start and end objects with x and y properties\");\n    this.start = new gi(t.x, t.y), this.end = new gi(e.x, e.y), this.properties = n || {};\n    var r = this.start.x - this.end.x,\n      i = this.start.y - this.end.y,\n      o = Math.pow(Math.sin(i / 2), 2) + Math.cos(this.start.y) * Math.cos(this.end.y) * Math.pow(Math.sin(r / 2), 2);\n    if (this.g = 2 * Math.asin(Math.sqrt(o)), this.g === Math.PI) throw new Error(\"it appears \" + t.view() + \" and \" + e.view() + \" are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite\");\n    if (isNaN(this.g)) throw new Error(\"could not calculate great circle between \" + t + \" and \" + e);\n  };\n  function _i(t, e) {\n    var n = [],\n      r = Mr();\n    return z(e, function (e) {\n      if (n.forEach(function (t, e) {\n        t.id = e;\n      }), n.length) {\n        var i = r.search(e);\n        if (i.features.length) {\n          var o = xi(e, i);\n          n = n.filter(function (t) {\n            return t.id !== o.id;\n          }), r.remove(o), F(mi(o, e), function (t) {\n            n.push(t), r.insert(t);\n          });\n        }\n      } else (n = mi(t, e).features).forEach(function (t) {\n        t.bbox || (t.bbox = yn(Z(t)));\n      }), r.load(f(n));\n    }), f(n);\n  }\n  function mi(t, e) {\n    var n = [],\n      r = Q(t)[0],\n      i = Q(t)[t.geometry.coordinates.length - 1];\n    if (Ei(r, K(e)) || Ei(i, K(e))) return f([t]);\n    var o = Mr(),\n      s = Zn(t);\n    o.load(s);\n    var a = o.search(e);\n    if (!a.features.length) return f([t]);\n    var u = xi(e, a),\n      l = k(s, function (t, r, i) {\n        var o = Q(r)[1],\n          s = K(e);\n        return i === u.id ? (t.push(s), n.push(h(t)), Ei(s, o) ? [s] : [s, o]) : (t.push(o), t);\n      }, [r]);\n    return l.length > 1 && n.push(h(l)), f(n);\n  }\n  function xi(t, e) {\n    if (!e.features.length) throw new Error(\"lines must contain features\");\n    if (1 === e.features.length) return e.features[0];\n    var n,\n      r = 1 / 0;\n    return F(e, function (e) {\n      var i = Tr(e, t).properties.dist;\n      i < r && (n = e, r = i);\n    }), n;\n  }\n  function Ei(t, e) {\n    return t[0] === e[0] && t[1] === e[1];\n  }\n  function bi(t, e, n, r, i) {\n    void 0 === i && (i = {});\n    var o = i.steps || 64,\n      s = wi(n),\n      a = wi(r),\n      u = Array.isArray(t) || \"Feature\" !== t.type ? {} : t.properties;\n    if (s === a) return h(_n(t, e, i).geometry.coordinates[0], u);\n    for (var l = s, c = s < a ? a : a + 360, p = l, f = [], g = 0; p < c;) f.push(vn(t, e, p, i).geometry.coordinates), p = l + 360 * ++g / o;\n    return p > c && f.push(vn(t, e, c, i).geometry.coordinates), h(f, u);\n  }\n  function wi(t) {\n    var e = t % 360;\n    return e < 0 && (e += 360), e;\n  }\n  function Ii(t, e) {\n    void 0 === e && (e = {});\n    var n = rt(t);\n    switch (e.properties || \"Feature\" !== t.type || (e.properties = t.properties), n.type) {\n      case \"Polygon\":\n        return Ni(n, e);\n      case \"MultiPolygon\":\n        return function (t, e) {\n          void 0 === e && (e = {});\n          var n = rt(t).coordinates,\n            r = e.properties ? e.properties : \"Feature\" === t.type ? t.properties : {},\n            i = [];\n          return n.forEach(function (t) {\n            i.push(Si(t, r));\n          }), f(i);\n        }(n, e);\n      default:\n        throw new Error(\"invalid poly\");\n    }\n  }\n  function Ni(t, e) {\n    return void 0 === e && (e = {}), Si(rt(t).coordinates, e.properties ? e.properties : \"Feature\" === t.type ? t.properties : {});\n  }\n  function Si(t, e) {\n    return t.length > 1 ? g(t, e) : h(t[0], e);\n  }\n  function Ci(t, e) {\n    var n, r, i;\n    void 0 === e && (e = {});\n    var o = e.properties,\n      s = null === (n = e.autoComplete) || void 0 === n || n,\n      a = null === (r = e.orderCoords) || void 0 === r || r;\n    switch (null !== (i = e.mutate) && void 0 !== i && i || (t = Ie(t)), t.type) {\n      case \"FeatureCollection\":\n        var u = [];\n        return t.features.forEach(function (t) {\n          u.push(Q(Pi(t, {}, s, a)));\n        }), y(u, o);\n      default:\n        return Pi(t, o, s, a);\n    }\n  }\n  function Pi(t, e, n, r) {\n    e = e || (\"Feature\" === t.type ? t.properties : {});\n    var i = rt(t),\n      o = i.coordinates,\n      s = i.type;\n    if (!o.length) throw new Error(\"line must contain coordinates\");\n    switch (s) {\n      case \"LineString\":\n        return n && (o = Mi(o)), l([o], e);\n      case \"MultiLineString\":\n        var a = [],\n          u = 0;\n        return o.forEach(function (t) {\n          if (n && (t = Mi(t)), r) {\n            var e = function (t) {\n              var e = t[0],\n                n = t[1],\n                r = t[2],\n                i = t[3];\n              return Math.abs(e - r) * Math.abs(n - i);\n            }(Z(h(t)));\n            e > u ? (a.unshift(t), u = e) : a.push(t);\n          } else a.push(t);\n        }), l(a, e);\n      default:\n        throw new Error(\"geometry type \" + s + \" is not supported\");\n    }\n  }\n  function Mi(t) {\n    var e = t[0],\n      n = e[0],\n      r = e[1],\n      i = t[t.length - 1],\n      o = i[0],\n      s = i[1];\n    return n === o && r === s || t.push(e), t;\n  }\n  function Li(t, e) {\n    var n, r, i, o, s, a, u;\n    for (r = 1; r <= 8; r *= 2) {\n      for (n = [], o = !(Ri(i = t[t.length - 1], e) & r), s = 0; s < t.length; s++) (u = !(Ri(a = t[s], e) & r)) !== o && n.push(Oi(i, a, r, e)), u && n.push(a), i = a, o = u;\n      if (!(t = n).length) break;\n    }\n    return n;\n  }\n  function Oi(t, e, n, r) {\n    return 8 & n ? [t[0] + (e[0] - t[0]) * (r[3] - t[1]) / (e[1] - t[1]), r[3]] : 4 & n ? [t[0] + (e[0] - t[0]) * (r[1] - t[1]) / (e[1] - t[1]), r[1]] : 2 & n ? [r[2], t[1] + (e[1] - t[1]) * (r[2] - t[0]) / (e[0] - t[0])] : 1 & n ? [r[0], t[1] + (e[1] - t[1]) * (r[0] - t[0]) / (e[0] - t[0])] : null;\n  }\n  function Ri(t, e) {\n    var n = 0;\n    return t[0] < e[0] ? n |= 1 : t[0] > e[2] && (n |= 2), t[1] < e[1] ? n |= 4 : t[1] > e[3] && (n |= 8), n;\n  }\n  function Ti(t, e) {\n    for (var n = [], r = 0, i = t; r < i.length; r++) {\n      var o = Li(i[r], e);\n      o.length > 0 && (o[0][0] === o[o.length - 1][0] && o[0][1] === o[o.length - 1][1] || o.push(o[0]), o.length >= 4 && n.push(o));\n    }\n    return n;\n  }\n  vi.prototype.interpolate = function (t) {\n    var e = Math.sin((1 - t) * this.g) / Math.sin(this.g),\n      n = Math.sin(t * this.g) / Math.sin(this.g),\n      r = e * Math.cos(this.start.y) * Math.cos(this.start.x) + n * Math.cos(this.end.y) * Math.cos(this.end.x),\n      i = e * Math.cos(this.start.y) * Math.sin(this.start.x) + n * Math.cos(this.end.y) * Math.sin(this.end.x),\n      o = e * Math.sin(this.start.y) + n * Math.sin(this.end.y),\n      s = fi * Math.atan2(o, Math.sqrt(Math.pow(r, 2) + Math.pow(i, 2)));\n    return [fi * Math.atan2(i, r), s];\n  }, vi.prototype.Arc = function (t, e) {\n    var n = [];\n    if (!t || t <= 2) n.push([this.start.lon, this.start.lat]), n.push([this.end.lon, this.end.lat]);else for (var r = 1 / (t - 1), i = 0; i < t; ++i) {\n      var o = r * i,\n        s = this.interpolate(o);\n      n.push(s);\n    }\n    for (var a = !1, u = 0, l = e && e.offset ? e.offset : 10, c = 180 - l, h = -180 + l, p = 360 - l, f = 1; f < n.length; ++f) {\n      var g = n[f - 1][0],\n        d = n[f][0],\n        y = Math.abs(d - g);\n      y > p && (d > c && g < h || g > c && d < h) ? a = !0 : y > u && (u = y);\n    }\n    var v = [];\n    if (a && u < l) {\n      var _ = [];\n      v.push(_);\n      for (var m = 0; m < n.length; ++m) {\n        var x = parseFloat(n[m][0]);\n        if (m > 0 && Math.abs(x - n[m - 1][0]) > p) {\n          var E = parseFloat(n[m - 1][0]),\n            b = parseFloat(n[m - 1][1]),\n            w = parseFloat(n[m][0]),\n            I = parseFloat(n[m][1]);\n          if (E > -180 && E < h && 180 === w && m + 1 < n.length && n[m - 1][0] > -180 && n[m - 1][0] < h) {\n            _.push([-180, n[m][1]]), m++, _.push([n[m][0], n[m][1]]);\n            continue;\n          }\n          if (E > c && E < 180 && -180 === w && m + 1 < n.length && n[m - 1][0] > c && n[m - 1][0] < 180) {\n            _.push([180, n[m][1]]), m++, _.push([n[m][0], n[m][1]]);\n            continue;\n          }\n          if (E < h && w > c) {\n            var N = E;\n            E = w, w = N;\n            var S = b;\n            b = I, I = S;\n          }\n          if (E > c && w < h && (w += 360), E <= 180 && w >= 180 && E < w) {\n            var C = (180 - E) / (w - E),\n              P = C * I + (1 - C) * b;\n            _.push([n[m - 1][0] > c ? 180 : -180, P]), (_ = []).push([n[m - 1][0] > c ? -180 : 180, P]), v.push(_);\n          } else _ = [], v.push(_);\n          _.push([x, n[m][1]]);\n        } else _.push([n[m][0], n[m][1]]);\n      }\n    } else {\n      var M = [];\n      v.push(M);\n      for (var L = 0; L < n.length; ++L) M.push([n[L][0], n[L][1]]);\n    }\n    for (var O = new yi(this.properties), R = 0; R < v.length; ++R) {\n      var T = new di();\n      O.geometries.push(T);\n      for (var A = v[R], D = 0; D < A.length; ++D) T.move_to(A[D]);\n    }\n    return O;\n  };\n  var Ai = Bt(function (t, e) {\n      function n(t) {\n        var e = [];\n        for (var n in t) e.push(n);\n        return e;\n      }\n      (t.exports = \"function\" == typeof Object.keys ? Object.keys : n).shim = n;\n    }),\n    Di = Bt(function (t, e) {\n      var n = \"[object Arguments]\" == function () {\n        return Object.prototype.toString.call(arguments);\n      }();\n      function r(t) {\n        return \"[object Arguments]\" == Object.prototype.toString.call(t);\n      }\n      function i(t) {\n        return t && \"object\" == typeof t && \"number\" == typeof t.length && Object.prototype.hasOwnProperty.call(t, \"callee\") && !Object.prototype.propertyIsEnumerable.call(t, \"callee\") || !1;\n      }\n      (e = t.exports = n ? r : i).supported = r, e.unsupported = i;\n    }),\n    Fi = Bt(function (t) {\n      var e = Array.prototype.slice,\n        n = t.exports = function (t, o, s) {\n          return s || (s = {}), t === o || (t instanceof Date && o instanceof Date ? t.getTime() === o.getTime() : !t || !o || \"object\" != typeof t && \"object\" != typeof o ? s.strict ? t === o : t == o : function (t, o, s) {\n            var a, u;\n            if (r(t) || r(o)) return !1;\n            if (t.prototype !== o.prototype) return !1;\n            if (Di(t)) return !!Di(o) && (t = e.call(t), o = e.call(o), n(t, o, s));\n            if (i(t)) {\n              if (!i(o)) return !1;\n              if (t.length !== o.length) return !1;\n              for (a = 0; a < t.length; a++) if (t[a] !== o[a]) return !1;\n              return !0;\n            }\n            try {\n              var l = Ai(t),\n                c = Ai(o);\n            } catch (t) {\n              return !1;\n            }\n            if (l.length != c.length) return !1;\n            for (l.sort(), c.sort(), a = l.length - 1; a >= 0; a--) if (l[a] != c[a]) return !1;\n            for (a = l.length - 1; a >= 0; a--) if (u = l[a], !n(t[u], o[u], s)) return !1;\n            return typeof t == typeof o;\n          }(t, o, s));\n        };\n      function r(t) {\n        return null == t;\n      }\n      function i(t) {\n        return !(!t || \"object\" != typeof t || \"number\" != typeof t.length) && \"function\" == typeof t.copy && \"function\" == typeof t.slice && !(t.length > 0 && \"number\" != typeof t[0]);\n      }\n    });\n  function ki(t, e, n) {\n    if (void 0 === n && (n = {}), !P(n = n || {})) throw new Error(\"options is invalid\");\n    var r,\n      i = n.tolerance || 0,\n      o = [],\n      s = Mr(),\n      a = Zn(t);\n    return s.load(a), U(e, function (t) {\n      var e = !1;\n      t && (F(s.search(t), function (n) {\n        if (!1 === e) {\n          var o = Q(t).sort(),\n            s = Q(n).sort();\n          Fi(o, s) || (0 === i ? Wr(o[0], n) && Wr(o[1], n) : Tr(n, o[0]).properties.dist <= i && Tr(n, o[1]).properties.dist <= i) ? (e = !0, r = r ? Gi(r, t) : t) : (0 === i ? Wr(s[0], t) && Wr(s[1], t) : Tr(t, s[0]).properties.dist <= i && Tr(t, s[1]).properties.dist <= i) && (r = r ? Gi(r, n) : n);\n        }\n      }), !1 === e && r && (o.push(r), r = void 0));\n    }), r && o.push(r), f(o);\n  }\n  function Gi(t, e) {\n    var n = Q(e),\n      r = Q(t),\n      i = r[0],\n      o = r[r.length - 1],\n      s = t.geometry.coordinates;\n    return Fi(n[0], i) ? s.unshift(n[1]) : Fi(n[0], o) ? s.push(n[1]) : Fi(n[1], i) ? s.unshift(n[0]) : Fi(n[1], o) && s.push(n[0]), t;\n  }\n  function qi(t) {\n    var e = t % 360;\n    return e < 0 && (e += 360), e;\n  }\n  function Bi(t, e, n) {\n    var r;\n    return void 0 === n && (n = {}), (r = n.final ? zi(K(e), K(t)) : zi(K(t), K(e))) > 180 ? -(360 - r) : r;\n  }\n  function zi(t, e) {\n    var n = I(t[1]),\n      r = I(e[1]),\n      i = I(e[0] - t[0]);\n    i > Math.PI && (i -= 2 * Math.PI), i < -Math.PI && (i += 2 * Math.PI);\n    var o = Math.log(Math.tan(r / 2 + Math.PI / 4) / Math.tan(n / 2 + Math.PI / 4));\n    return (w(Math.atan2(i, o)) + 360) % 360;\n  }\n  function ji(t, n, r, i) {\n    void 0 === i && (i = {});\n    var o = n < 0,\n      s = N(Math.abs(n), i.units, \"meters\");\n    o && (s = -Math.abs(s));\n    var u = K(t),\n      l = function (t, n, r, i) {\n        i = void 0 === i ? e : Number(i);\n        var o = n / i,\n          s = t[0] * Math.PI / 180,\n          a = I(t[1]),\n          u = I(r),\n          l = o * Math.cos(u),\n          c = a + l;\n        Math.abs(c) > Math.PI / 2 && (c = c > 0 ? Math.PI - c : -Math.PI - c);\n        var h = Math.log(Math.tan(c / 2 + Math.PI / 4) / Math.tan(a / 2 + Math.PI / 4)),\n          p = Math.abs(h) > 1e-11 ? l / h : Math.cos(a),\n          f = o * Math.sin(u) / p;\n        return [(180 * (s + f) / Math.PI + 540) % 360 - 180, 180 * c / Math.PI];\n      }(u, s, r);\n    return l[0] += l[0] - u[0] > 180 ? -360 : u[0] - l[0] > 180 ? 360 : 0, a(l, i.properties);\n  }\n  function Ui(t, e, n, r, i, o) {\n    for (var s = 0; s < t.length; s++) {\n      var a = t[s],\n        u = t[s + 1];\n      s === t.length - 1 && (u = t[0]), r = Xi(a, u, e), n <= 0 && r > 0 ? Xi(e, a, i) < 0 || (i = a) : n > 0 && r <= 0 && (Vi(e, a, o) || (o = a)), n = r;\n    }\n    return [i, o];\n  }\n  function Vi(t, e, n) {\n    return Xi(t, e, n) > 0;\n  }\n  function Xi(t, e, n) {\n    return (e[0] - t[0]) * (n[1] - t[1]) - (n[0] - t[0]) * (e[1] - t[1]);\n  }\n  function Yi(t) {\n    for (var e, n, r = Q(t), i = 0, o = 1; o < r.length;) e = n || r[0], i += ((n = r[o])[0] - e[0]) * (n[1] + e[1]), o++;\n    return i > 0;\n  }\n  function Hi(t, e) {\n    switch (\"Feature\" === t.type ? t.geometry.type : t.type) {\n      case \"GeometryCollection\":\n        return q(t, function (t) {\n          Hi(t, e);\n        }), t;\n      case \"LineString\":\n        return Wi(Q(t), e), t;\n      case \"Polygon\":\n        return Ji(Q(t), e), t;\n      case \"MultiLineString\":\n        return Q(t).forEach(function (t) {\n          Wi(t, e);\n        }), t;\n      case \"MultiPolygon\":\n        return Q(t).forEach(function (t) {\n          Ji(t, e);\n        }), t;\n      case \"Point\":\n      case \"MultiPoint\":\n        return t;\n    }\n  }\n  function Wi(t, e) {\n    Yi(t) === e && t.reverse();\n  }\n  function Ji(t, e) {\n    Yi(t[0]) !== e && t[0].reverse();\n    for (var n = 1; n < t.length; n++) Yi(t[n]) === e && t[n].reverse();\n  }\n  function Zi(t, e) {\n    if (!P(e = e || {})) throw new Error(\"options is invalid\");\n    var n = e.zProperty || \"elevation\",\n      r = e.flip,\n      i = e.flags;\n    nt(t, \"Point\", \"input must contain Points\");\n    for (var o = function (t, e) {\n        var n = {};\n        return F(t, function (t) {\n          var e = Q(t)[1];\n          n[e] || (n[e] = []), n[e].push(t);\n        }), Object.keys(n).map(function (t) {\n          return n[t].sort(function (t, e) {\n            return Q(t)[0] - Q(e)[0];\n          });\n        }).sort(function (t, n) {\n          return e ? Q(t[0])[1] - Q(n[0])[1] : Q(n[0])[1] - Q(t[0])[1];\n        });\n      }\n      /*!\n           * @license GNU Affero General Public License.\n           * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>\n           * v. 1.2.0\n           * https://github.com/RaumZeit/MarchingSquares.js\n           *\n           * MarchingSquaresJS is free software: you can redistribute it and/or modify\n           * it under the terms of the GNU Affero General Public License as published by\n           * the Free Software Foundation, either version 3 of the License, or\n           * (at your option) any later version.\n           *\n           * MarchingSquaresJS is distributed in the hope that it will be useful,\n           * but WITHOUT ANY WARRANTY; without even the implied warranty of\n           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n           * GNU Affero General Public License for more details.\n           *\n           * As additional permission under GNU Affero General Public License version 3\n           * section 7, third-party projects (personal or commercial) may distribute,\n           * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the\n           * requirement that said third-party project for that reason alone becomes\n           * subject to any requirement of the GNU Affero General Public License version 3.\n           * Any modifications to MarchingSquaresJS, however, must be shared with the public\n           * and made available.\n           *\n           * In summary this:\n           * - allows you to use MarchingSquaresJS at no cost\n           * - allows you to use MarchingSquaresJS for both personal and commercial purposes\n           * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any\n           *   license as long as this license notice is included\n           * - enables you to keep the source code of your program that uses MarchingSquaresJS\n           *   undisclosed\n           * - forces you to share any modifications you have made to MarchingSquaresJS,\n           *   e.g. bug-fixes\n           *\n           * You should have received a copy of the GNU Affero General Public License\n           * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.\n           */(t, r), s = [], a = 0; a < o.length; a++) {\n      for (var u = o[a], l = [], c = 0; c < u.length; c++) {\n        var h = u[c];\n        h.properties[n] ? l.push(h.properties[n]) : l.push(0), !0 === i && (h.properties.matrixPosition = [a, c]);\n      }\n      s.push(l);\n    }\n    return s;\n  }\n  var Ki = {\n      successCallback: null,\n      verbose: !1,\n      polygons: !1\n    },\n    Qi = {};\n  function $i(t, e, n, r) {\n    r = r || {};\n    for (var i = Object.keys(Ki), o = 0; o < i.length; o++) {\n      var s = i[o],\n        a = r[s];\n      a = null != a ? a : Ki[s], Qi[s] = a;\n    }\n    Qi.verbose && console.log(\"MarchingSquaresJS-isoBands: computing isobands for [\" + e + \":\" + (e + n) + \"]\");\n    var u,\n      l = function (t, e, n) {\n        for (var r = t.length - 1, i = t[0].length - 1, o = {\n            rows: r,\n            cols: i,\n            cells: []\n          }, s = e + Math.abs(n), a = 0; a < r; ++a) {\n          o.cells[a] = [];\n          for (var u = 0; u < i; ++u) {\n            var l = 0,\n              c = t[a + 1][u],\n              h = t[a + 1][u + 1],\n              p = t[a][u + 1],\n              f = t[a][u];\n            if (!(isNaN(c) || isNaN(h) || isNaN(p) || isNaN(f))) {\n              l |= c < e ? 0 : c > s ? 128 : 64, l |= h < e ? 0 : h > s ? 32 : 16, l |= p < e ? 0 : p > s ? 8 : 4;\n              var g = +(l |= f < e ? 0 : f > s ? 2 : 1),\n                d = 0;\n              if (17 === l || 18 === l || 33 === l || 34 === l || 38 === l || 68 === l || 72 === l || 98 === l || 102 === l || 132 === l || 136 === l || 137 === l || 152 === l || 153 === l) {\n                var y = (c + h + p + f) / 4;\n                d = y > s ? 2 : y < e ? 0 : 1, 34 === l ? 1 === d ? l = 35 : 0 === d && (l = 136) : 136 === l ? 1 === d ? (l = 35, d = 4) : 0 === d && (l = 34) : 17 === l ? 1 === d ? (l = 155, d = 4) : 0 === d && (l = 153) : 68 === l ? 1 === d ? (l = 103, d = 4) : 0 === d && (l = 102) : 153 === l ? 1 === d && (l = 155) : 102 === l ? 1 === d && (l = 103) : 152 === l ? d < 2 && (l = 156, d = 1) : 137 === l ? d < 2 && (l = 139, d = 1) : 98 === l ? d < 2 && (l = 99, d = 1) : 38 === l ? d < 2 && (l = 39, d = 1) : 18 === l ? d > 0 ? (l = 156, d = 4) : l = 152 : 33 === l ? d > 0 ? (l = 139, d = 4) : l = 137 : 72 === l ? d > 0 ? (l = 99, d = 4) : l = 98 : 132 === l && (d > 0 ? (l = 39, d = 4) : l = 38);\n              }\n              if (0 != l && 170 != l) {\n                var v, _, m, x, E, b, w, I;\n                v = _ = m = x = E = b = w = I = .5;\n                var N = [];\n                1 === l ? (m = 1 - Vo(e, p, f), I = 1 - Vo(e, c, f), N.push(Go[l])) : 169 === l ? (m = Vo(s, f, p), I = Vo(s, f, c), N.push(Go[l])) : 4 === l ? (b = 1 - Vo(e, h, p), x = Vo(e, f, p), N.push(Fo[l])) : 166 === l ? (b = Vo(s, p, h), x = 1 - Vo(s, p, f), N.push(Fo[l])) : 16 === l ? (E = Vo(e, p, h), _ = Vo(e, c, h), N.push(Do[l])) : 154 === l ? (E = 1 - Vo(s, h, p), _ = 1 - Vo(s, h, c), N.push(Do[l])) : 64 === l ? (w = Vo(e, f, c), v = 1 - Vo(e, h, c), N.push(Bo[l])) : 106 === l ? (w = 1 - Vo(s, c, f), v = Vo(s, c, h), N.push(Bo[l])) : 168 === l ? (x = Vo(s, f, p), m = Vo(e, f, p), I = Vo(e, f, c), w = Vo(s, f, c), N.push(ko[l]), N.push(Go[l])) : 2 === l ? (x = 1 - Vo(e, p, f), m = 1 - Vo(s, p, f), I = 1 - Vo(s, c, f), w = 1 - Vo(e, c, f), N.push(ko[l]), N.push(Go[l])) : 162 === l ? (E = Vo(s, p, h), b = Vo(e, p, h), x = 1 - Vo(e, p, f), m = 1 - Vo(s, p, f), N.push(ko[l]), N.push(Go[l])) : 8 === l ? (E = 1 - Vo(e, h, p), b = 1 - Vo(s, h, p), x = Vo(s, f, p), m = Vo(e, f, p), N.push(Do[l]), N.push(Fo[l])) : 138 === l ? (E = 1 - Vo(e, h, p), b = 1 - Vo(s, h, p), v = 1 - Vo(s, h, c), _ = 1 - Vo(e, h, c), N.push(Do[l]), N.push(Fo[l])) : 32 === l ? (E = Vo(s, p, h), b = Vo(e, p, h), v = Vo(e, c, h), _ = Vo(s, c, h), N.push(Do[l]), N.push(Fo[l])) : 42 === l ? (I = 1 - Vo(s, c, f), w = 1 - Vo(e, c, f), v = Vo(e, c, h), _ = Vo(s, c, h), N.push(qo[l]), N.push(Bo[l])) : 128 === l && (I = Vo(e, f, c), w = Vo(s, f, c), v = 1 - Vo(s, h, c), _ = 1 - Vo(e, h, c), N.push(qo[l]), N.push(Bo[l])), 5 === l ? (b = 1 - Vo(e, h, p), I = 1 - Vo(e, c, f), N.push(Fo[l])) : 165 === l ? (b = Vo(s, p, h), I = Vo(s, f, c), N.push(Fo[l])) : 20 === l ? (x = Vo(e, f, p), _ = Vo(e, c, h), N.push(ko[l])) : 150 === l ? (x = 1 - Vo(s, p, f), _ = 1 - Vo(s, h, c), N.push(ko[l])) : 80 === l ? (E = Vo(e, p, h), w = Vo(e, f, c), N.push(Do[l])) : 90 === l ? (E = 1 - Vo(s, h, p), w = 1 - Vo(s, c, f), N.push(Do[l])) : 65 === l ? (m = 1 - Vo(e, p, f), v = 1 - Vo(e, h, c), N.push(Go[l])) : 105 === l ? (m = Vo(s, f, p), v = Vo(s, c, h), N.push(Go[l])) : 160 === l ? (E = Vo(s, p, h), b = Vo(e, p, h), I = Vo(e, f, c), w = Vo(s, f, c), N.push(Do[l]), N.push(Fo[l])) : 10 === l ? (E = 1 - Vo(e, h, p), b = 1 - Vo(s, h, p), I = 1 - Vo(s, c, f), w = 1 - Vo(e, c, f), N.push(Do[l]), N.push(Fo[l])) : 130 === l ? (x = 1 - Vo(e, p, f), m = 1 - Vo(s, p, f), v = 1 - Vo(s, h, c), _ = 1 - Vo(e, h, c), N.push(ko[l]), N.push(Go[l])) : 40 === l ? (x = Vo(s, f, p), m = Vo(e, f, p), v = Vo(e, c, h), _ = Vo(s, c, h), N.push(ko[l]), N.push(Go[l])) : 101 === l ? (b = Vo(s, p, h), v = Vo(s, c, h), N.push(Fo[l])) : 69 === l ? (b = 1 - Vo(e, h, p), v = 1 - Vo(e, h, c), N.push(Fo[l])) : 149 === l ? (I = Vo(s, f, c), _ = 1 - Vo(s, h, c), N.push(qo[l])) : 21 === l ? (I = 1 - Vo(e, c, f), _ = Vo(e, c, h), N.push(qo[l])) : 86 === l ? (x = 1 - Vo(s, p, f), w = 1 - Vo(s, c, f), N.push(ko[l])) : 84 === l ? (x = Vo(e, f, p), w = Vo(e, f, c), N.push(ko[l])) : 89 === l ? (E = 1 - Vo(s, h, p), m = Vo(s, f, p), N.push(Go[l])) : 81 === l ? (E = Vo(e, p, h), m = 1 - Vo(e, p, f), N.push(Go[l])) : 96 === l ? (E = Vo(s, p, h), b = Vo(e, p, h), w = Vo(e, f, c), v = Vo(s, c, h), N.push(Do[l]), N.push(Fo[l])) : 74 === l ? (E = 1 - Vo(e, h, p), b = 1 - Vo(s, h, p), w = 1 - Vo(s, c, f), v = 1 - Vo(e, h, c), N.push(Do[l]), N.push(Fo[l])) : 24 === l ? (E = 1 - Vo(s, h, p), x = Vo(s, f, p), m = Vo(e, f, p), _ = Vo(e, c, h), N.push(Do[l]), N.push(Go[l])) : 146 === l ? (E = Vo(e, p, h), x = 1 - Vo(e, p, f), m = 1 - Vo(s, p, f), _ = 1 - Vo(s, h, c), N.push(Do[l]), N.push(Go[l])) : 6 === l ? (b = 1 - Vo(e, h, p), x = 1 - Vo(s, p, f), I = 1 - Vo(s, c, f), w = 1 - Vo(e, c, f), N.push(Fo[l]), N.push(ko[l])) : 164 === l ? (b = Vo(s, p, h), x = Vo(e, f, p), I = Vo(e, f, c), w = Vo(s, f, c), N.push(Fo[l]), N.push(ko[l])) : 129 === l ? (m = 1 - Vo(e, p, f), I = Vo(s, f, c), v = 1 - Vo(s, h, c), _ = 1 - Vo(e, h, c), N.push(Go[l]), N.push(qo[l])) : 41 === l ? (m = Vo(s, f, p), I = 1 - Vo(e, c, f), v = Vo(e, c, h), _ = Vo(s, c, h), N.push(Go[l]), N.push(qo[l])) : 66 === l ? (x = 1 - Vo(e, p, f), m = 1 - Vo(s, p, f), w = 1 - Vo(s, c, f), v = 1 - Vo(e, h, c), N.push(ko[l]), N.push(Go[l])) : 104 === l ? (x = Vo(s, f, p), m = Vo(e, f, p), w = Vo(e, f, c), v = Vo(s, c, h), N.push(Go[l]), N.push(zo[l])) : 144 === l ? (E = Vo(e, p, h), I = Vo(e, f, c), w = Vo(s, f, c), _ = 1 - Vo(s, h, c), N.push(Do[l]), N.push(Bo[l])) : 26 === l ? (E = 1 - Vo(s, h, p), I = 1 - Vo(s, c, f), w = 1 - Vo(e, c, f), _ = Vo(e, c, h), N.push(Do[l]), N.push(Bo[l])) : 36 === l ? (b = Vo(s, p, h), x = Vo(e, f, p), v = Vo(e, c, h), _ = Vo(s, c, h), N.push(Fo[l]), N.push(ko[l])) : 134 === l ? (b = 1 - Vo(e, h, p), x = 1 - Vo(s, p, f), v = 1 - Vo(s, h, c), _ = 1 - Vo(e, h, c), N.push(Fo[l]), N.push(ko[l])) : 9 === l ? (E = 1 - Vo(e, h, p), b = 1 - Vo(s, h, p), m = Vo(s, f, p), I = 1 - Vo(e, c, f), N.push(Do[l]), N.push(Fo[l])) : 161 === l ? (E = Vo(s, p, h), b = Vo(e, p, h), m = 1 - Vo(e, p, f), I = Vo(s, f, c), N.push(Do[l]), N.push(Fo[l])) : 37 === l ? (b = Vo(s, p, h), I = 1 - Vo(e, c, f), v = Vo(e, c, h), _ = Vo(s, c, h), N.push(Fo[l]), N.push(qo[l])) : 133 === l ? (b = 1 - Vo(e, h, p), I = Vo(s, f, c), v = 1 - Vo(s, h, c), _ = 1 - Vo(e, h, c), N.push(Fo[l]), N.push(qo[l])) : 148 === l ? (x = Vo(e, f, p), I = Vo(e, f, c), w = Vo(s, f, c), _ = 1 - Vo(s, h, c), N.push(ko[l]), N.push(Bo[l])) : 22 === l ? (x = 1 - Vo(s, p, f), I = 1 - Vo(s, c, f), w = 1 - Vo(e, c, f), _ = Vo(e, c, h), N.push(ko[l]), N.push(Bo[l])) : 82 === l ? (E = Vo(e, p, h), x = 1 - Vo(e, p, f), m = 1 - Vo(s, p, f), w = 1 - Vo(s, c, f), N.push(Do[l]), N.push(Go[l])) : 88 === l ? (E = 1 - Vo(s, h, p), x = Vo(s, f, p), m = Vo(e, f, p), w = Vo(e, f, c), N.push(Do[l]), N.push(Go[l])) : 73 === l ? (E = 1 - Vo(e, h, p), b = 1 - Vo(s, h, p), m = Vo(s, f, p), v = 1 - Vo(e, h, c), N.push(Do[l]), N.push(Fo[l])) : 97 === l ? (E = Vo(s, p, h), b = Vo(e, p, h), m = 1 - Vo(e, p, f), v = Vo(s, c, h), N.push(Do[l]), N.push(Fo[l])) : 145 === l ? (E = Vo(e, p, h), m = 1 - Vo(e, p, f), I = Vo(s, f, c), _ = 1 - Vo(s, h, c), N.push(Do[l]), N.push(qo[l])) : 25 === l ? (E = 1 - Vo(s, h, p), m = Vo(s, f, p), I = 1 - Vo(e, c, f), _ = Vo(e, c, h), N.push(Do[l]), N.push(qo[l])) : 70 === l ? (b = 1 - Vo(e, h, p), x = 1 - Vo(s, p, f), w = 1 - Vo(s, c, f), v = 1 - Vo(e, h, c), N.push(Fo[l]), N.push(ko[l])) : 100 === l ? (b = Vo(s, p, h), x = Vo(e, f, p), w = Vo(e, f, c), v = Vo(s, c, h), N.push(Fo[l]), N.push(ko[l])) : 34 === l ? (0 === d ? (E = 1 - Vo(e, h, p), b = 1 - Vo(s, h, p), x = Vo(s, f, p), m = Vo(e, f, p), I = Vo(e, f, c), w = Vo(s, f, c), v = 1 - Vo(s, h, c), _ = 1 - Vo(e, h, c)) : (E = Vo(s, p, h), b = Vo(e, p, h), x = 1 - Vo(e, p, f), m = 1 - Vo(s, p, f), I = 1 - Vo(s, c, f), w = 1 - Vo(e, c, f), v = Vo(e, c, h), _ = Vo(s, c, h)), N.push(Do[l]), N.push(Fo[l]), N.push(qo[l]), N.push(Bo[l])) : 35 === l ? (4 === d ? (E = 1 - Vo(e, h, p), b = 1 - Vo(s, h, p), x = Vo(s, f, p), m = Vo(e, f, p), I = Vo(e, f, c), w = Vo(s, f, c), v = 1 - Vo(s, h, c), _ = 1 - Vo(e, h, c)) : (E = Vo(s, p, h), b = Vo(e, p, h), x = 1 - Vo(e, p, f), m = 1 - Vo(s, p, f), I = 1 - Vo(s, c, f), w = 1 - Vo(e, c, f), v = Vo(e, c, h), _ = Vo(s, c, h)), N.push(Do[l]), N.push(Fo[l]), N.push(Go[l]), N.push(Bo[l])) : 136 === l ? (0 === d ? (E = Vo(s, p, h), b = Vo(e, p, h), x = 1 - Vo(e, p, f), m = 1 - Vo(s, p, f), I = 1 - Vo(s, c, f), w = 1 - Vo(e, c, f), v = Vo(e, c, h), _ = Vo(s, c, h)) : (E = 1 - Vo(e, h, p), b = 1 - Vo(s, h, p), x = Vo(s, f, p), m = Vo(e, f, p), I = Vo(e, f, c), w = Vo(s, f, c), v = 1 - Vo(s, h, c), _ = 1 - Vo(e, h, c)), N.push(Do[l]), N.push(Fo[l]), N.push(qo[l]), N.push(Bo[l])) : 153 === l ? (0 === d ? (E = Vo(e, p, h), m = 1 - Vo(e, p, f), I = 1 - Vo(e, c, f), _ = Vo(e, c, h)) : (E = 1 - Vo(s, h, p), m = Vo(s, f, p), I = Vo(s, f, c), _ = 1 - Vo(s, h, c)), N.push(Do[l]), N.push(Go[l])) : 102 === l ? (0 === d ? (b = 1 - Vo(e, h, p), x = Vo(e, f, p), w = Vo(e, f, c), v = 1 - Vo(e, h, c)) : (b = Vo(s, p, h), x = 1 - Vo(s, p, f), w = 1 - Vo(s, c, f), v = Vo(s, c, h)), N.push(Fo[l]), N.push(Bo[l])) : 155 === l ? (4 === d ? (E = Vo(e, p, h), m = 1 - Vo(e, p, f), I = 1 - Vo(e, c, f), _ = Vo(e, c, h)) : (E = 1 - Vo(s, h, p), m = Vo(s, f, p), I = Vo(s, f, c), _ = 1 - Vo(s, h, c)), N.push(Do[l]), N.push(qo[l])) : 103 === l ? (4 === d ? (b = 1 - Vo(e, h, p), x = Vo(e, f, p), w = Vo(e, f, c), v = 1 - Vo(e, h, c)) : (b = Vo(s, p, h), x = 1 - Vo(s, p, f), w = 1 - Vo(s, c, f), v = Vo(s, c, h)), N.push(Fo[l]), N.push(ko[l])) : 152 === l ? (0 === d ? (E = Vo(e, p, h), x = 1 - Vo(e, p, f), m = 1 - Vo(s, p, f), I = 1 - Vo(s, c, f), w = 1 - Vo(e, c, f), _ = Vo(e, c, h)) : (E = 1 - Vo(s, h, p), x = Vo(s, f, p), m = Vo(e, f, p), I = Vo(e, f, c), w = Vo(s, f, c), _ = 1 - Vo(s, h, c)), N.push(Do[l]), N.push(ko[l]), N.push(Go[l])) : 156 === l ? (4 === d ? (E = Vo(e, p, h), x = 1 - Vo(e, p, f), m = 1 - Vo(s, p, f), I = 1 - Vo(s, c, f), w = 1 - Vo(e, c, f), _ = Vo(e, c, h)) : (E = 1 - Vo(s, h, p), x = Vo(s, f, p), m = Vo(e, f, p), I = Vo(e, f, c), w = Vo(s, f, c), _ = 1 - Vo(s, h, c)), N.push(Do[l]), N.push(Go[l]), N.push(Bo[l])) : 137 === l ? (0 === d ? (E = Vo(s, p, h), b = Vo(e, p, h), m = 1 - Vo(e, p, f), I = 1 - Vo(e, c, f), v = Vo(e, c, h), _ = Vo(s, c, h)) : (E = 1 - Vo(e, h, p), b = 1 - Vo(s, h, p), m = Vo(s, f, p), I = Vo(s, f, c), v = 1 - Vo(s, h, c), _ = 1 - Vo(e, h, c)), N.push(Do[l]), N.push(Fo[l]), N.push(Go[l])) : 139 === l ? (4 === d ? (E = Vo(s, p, h), b = Vo(e, p, h), m = 1 - Vo(e, p, f), I = 1 - Vo(e, c, f), v = Vo(e, c, h), _ = Vo(s, c, h)) : (E = 1 - Vo(e, h, p), b = 1 - Vo(s, h, p), m = Vo(s, f, p), I = Vo(s, f, c), v = 1 - Vo(s, h, c), _ = 1 - Vo(e, h, c)), N.push(Do[l]), N.push(Fo[l]), N.push(qo[l])) : 98 === l ? (0 === d ? (E = 1 - Vo(e, h, p), b = 1 - Vo(s, h, p), x = Vo(s, f, p), m = Vo(e, f, p), w = Vo(e, f, c), v = 1 - Vo(e, h, c)) : (E = Vo(s, p, h), b = Vo(e, p, h), x = 1 - Vo(e, p, f), m = 1 - Vo(s, p, f), w = 1 - Vo(s, c, f), v = Vo(s, c, h)), N.push(Do[l]), N.push(Fo[l]), N.push(Bo[l])) : 99 === l ? (4 === d ? (E = 1 - Vo(e, h, p), b = 1 - Vo(s, h, p), x = Vo(s, f, p), m = Vo(e, f, p), w = Vo(e, f, c), v = 1 - Vo(e, h, c)) : (E = Vo(s, p, h), b = Vo(e, p, h), x = 1 - Vo(e, p, f), m = 1 - Vo(s, p, f), w = 1 - Vo(s, c, f), v = Vo(s, c, h)), N.push(Do[l]), N.push(Fo[l]), N.push(Go[l])) : 38 === l ? (0 === d ? (b = 1 - Vo(e, h, p), x = Vo(e, f, p), I = Vo(e, f, c), w = Vo(s, f, c), v = 1 - Vo(s, h, c), _ = 1 - Vo(e, h, c)) : (b = Vo(s, p, h), x = 1 - Vo(s, p, f), I = 1 - Vo(s, c, f), w = 1 - Vo(e, c, f), v = Vo(e, c, h), _ = Vo(s, c, h)), N.push(Fo[l]), N.push(qo[l]), N.push(Bo[l])) : 39 === l ? (4 === d ? (b = 1 - Vo(e, h, p), x = Vo(e, f, p), I = Vo(e, f, c), w = Vo(s, f, c), v = 1 - Vo(s, h, c), _ = 1 - Vo(e, h, c)) : (b = Vo(s, p, h), x = 1 - Vo(s, p, f), I = 1 - Vo(s, c, f), w = 1 - Vo(e, c, f), v = Vo(e, c, h), _ = Vo(s, c, h)), N.push(Fo[l]), N.push(ko[l]), N.push(Bo[l])) : 85 === l && (E = 1, b = 0, x = 1, m = 0, I = 0, w = 1, v = 0, _ = 1), (v < 0 || v > 1 || _ < 0 || _ > 1 || E < 0 || E > 1 || x < 0 || x > 1 || I < 0 || I > 1 || w < 0 || w > 1) && console.log(\"MarchingSquaresJS-isoBands: \" + l + \" \" + g + \" \" + c + \",\" + h + \",\" + p + \",\" + f + \" \" + d + \" \" + v + \" \" + _ + \" \" + E + \" \" + b + \" \" + x + \" \" + m + \" \" + I + \" \" + w), o.cells[a][u] = {\n                  cval: l,\n                  cval_real: g,\n                  flipped: d,\n                  topleft: v,\n                  topright: _,\n                  righttop: E,\n                  rightbottom: b,\n                  bottomright: x,\n                  bottomleft: m,\n                  leftbottom: I,\n                  lefttop: w,\n                  edges: N\n                };\n              }\n            }\n          }\n        }\n        return o;\n      }(t, e, n);\n    return Qi.polygons ? (Qi.verbose && console.log(\"MarchingSquaresJS-isoBands: returning single polygons for each grid cell\"), u = function (t) {\n      var e = [],\n        n = 0;\n      return t.cells.forEach(function (t, r) {\n        t.forEach(function (t, i) {\n          if (void 0 !== t) {\n            var o = Uo[t.cval](t);\n            \"object\" == typeof o && Xo(o) ? \"object\" == typeof o[0] && Xo(o[0]) ? \"object\" == typeof o[0][0] && Xo(o[0][0]) ? o.forEach(function (t) {\n              t.forEach(function (t) {\n                t[0] += i, t[1] += r;\n              }), e[n++] = t;\n            }) : (o.forEach(function (t) {\n              t[0] += i, t[1] += r;\n            }), e[n++] = o) : console.log(\"MarchingSquaresJS-isoBands: bandcell polygon with malformed coordinates\") : console.log(\"MarchingSquaresJS-isoBands: bandcell polygon with null coordinates\");\n          }\n        });\n      }), e;\n    }(l)) : (Qi.verbose && console.log(\"MarchingSquaresJS-isoBands: returning polygon paths for entire data grid\"), u = function (t) {\n      for (var e = [], n = t.rows, r = t.cols, i = [], o = 0; o < n; o++) for (var s = 0; s < r; s++) if (void 0 !== t.cells[o][s] && t.cells[o][s].edges.length > 0) {\n        var a = Ho(t.cells[o][s]),\n          u = null,\n          l = s,\n          c = o;\n        null !== a && i.push([a.p[0] + l, a.p[1] + c]);\n        do {\n          if (null === (u = Wo(t.cells[c][l], a.x, a.y, a.o))) break;\n          if (i.push([u.p[0] + l, u.p[1] + c]), l += u.x, a = u, (c += u.y) < 0 || c >= n || l < 0 || l >= r || void 0 === t.cells[c][l]) {\n            var h = Yo(t, l -= u.x, c -= u.y, u.x, u.y, u.o);\n            if (null === h) break;\n            h.path.forEach(function (t) {\n              i.push(t);\n            }), l = h.i, c = h.j, a = h;\n          }\n        } while (void 0 !== t.cells[c][l] && t.cells[c][l].edges.length > 0);\n        e.push(i), i = [], t.cells[o][s].edges.length > 0 && s--;\n      }\n      return e;\n    }(l)), \"function\" == typeof Qi.successCallback && Qi.successCallback(u), u;\n  }\n  var to = 64,\n    eo = 16,\n    no = [],\n    ro = [],\n    io = [],\n    oo = [],\n    so = [],\n    ao = [],\n    uo = [],\n    lo = [],\n    co = [],\n    ho = [],\n    po = [],\n    fo = [],\n    go = [],\n    yo = [],\n    vo = [],\n    _o = [],\n    mo = [],\n    xo = [],\n    Eo = [],\n    bo = [],\n    wo = [],\n    Io = [],\n    No = [],\n    So = [];\n  uo[85] = ho[85] = -1, lo[85] = po[85] = 0, co[85] = fo[85] = 1, Eo[85] = Io[85] = 1, bo[85] = No[85] = 0, wo[85] = So[85] = 1, no[85] = oo[85] = 0, ro[85] = so[85] = -1, io[85] = vo[85] = 0, _o[85] = go[85] = 0, mo[85] = yo[85] = 1, ao[85] = xo[85] = 1, Io[1] = Io[169] = 0, No[1] = No[169] = -1, So[1] = So[169] = 0, go[1] = go[169] = -1, yo[1] = yo[169] = 0, vo[1] = vo[169] = 0, ho[4] = ho[166] = 0, po[4] = po[166] = -1, fo[4] = fo[166] = 1, _o[4] = _o[166] = 1, mo[4] = mo[166] = 0, xo[4] = xo[166] = 0, uo[16] = uo[154] = 0, lo[16] = lo[154] = 1, co[16] = co[154] = 1, oo[16] = oo[154] = 1, so[16] = so[154] = 0, ao[16] = ao[154] = 1, Eo[64] = Eo[106] = 0, bo[64] = bo[106] = 1, wo[64] = wo[106] = 0, no[64] = no[106] = -1, ro[64] = ro[106] = 0, io[64] = io[106] = 1, Eo[2] = Eo[168] = 0, bo[2] = bo[168] = -1, wo[2] = wo[168] = 1, Io[2] = Io[168] = 0, No[2] = No[168] = -1, So[2] = So[168] = 0, go[2] = go[168] = -1, yo[2] = yo[168] = 0, vo[2] = vo[168] = 0, _o[2] = _o[168] = -1, mo[2] = mo[168] = 0, xo[2] = xo[168] = 1, uo[8] = uo[162] = 0, lo[8] = lo[162] = -1, co[8] = co[162] = 0, ho[8] = ho[162] = 0, po[8] = po[162] = -1, fo[8] = fo[162] = 1, go[8] = go[162] = 1, yo[8] = yo[162] = 0, vo[8] = vo[162] = 1, _o[8] = _o[162] = 1, mo[8] = mo[162] = 0, xo[8] = xo[162] = 0, uo[32] = uo[138] = 0, lo[32] = lo[138] = 1, co[32] = co[138] = 1, ho[32] = ho[138] = 0, po[32] = po[138] = 1, fo[32] = fo[138] = 0, no[32] = no[138] = 1, ro[32] = ro[138] = 0, io[32] = io[138] = 0, oo[32] = oo[138] = 1, so[32] = so[138] = 0, ao[32] = ao[138] = 1, Io[128] = Io[42] = 0, No[128] = No[42] = 1, So[128] = So[42] = 1, Eo[128] = Eo[42] = 0, bo[128] = bo[42] = 1, wo[128] = wo[42] = 0, no[128] = no[42] = -1, ro[128] = ro[42] = 0, io[128] = io[42] = 1, oo[128] = oo[42] = -1, so[128] = so[42] = 0, ao[128] = ao[42] = 0, ho[5] = ho[165] = -1, po[5] = po[165] = 0, fo[5] = fo[165] = 0, Io[5] = Io[165] = 1, No[5] = No[165] = 0, So[5] = So[165] = 0, _o[20] = _o[150] = 0, mo[20] = mo[150] = 1, xo[20] = xo[150] = 1, oo[20] = oo[150] = 0, so[20] = so[150] = -1, ao[20] = ao[150] = 1, uo[80] = uo[90] = -1, lo[80] = lo[90] = 0, co[80] = co[90] = 1, Eo[80] = Eo[90] = 1, bo[80] = bo[90] = 0, wo[80] = wo[90] = 1, go[65] = go[105] = 0, yo[65] = yo[105] = 1, vo[65] = vo[105] = 0, no[65] = no[105] = 0, ro[65] = ro[105] = -1, io[65] = io[105] = 0, uo[160] = uo[10] = -1, lo[160] = lo[10] = 0, co[160] = co[10] = 1, ho[160] = ho[10] = -1, po[160] = po[10] = 0, fo[160] = fo[10] = 0, Io[160] = Io[10] = 1, No[160] = No[10] = 0, So[160] = So[10] = 0, Eo[160] = Eo[10] = 1, bo[160] = bo[10] = 0, wo[160] = wo[10] = 1, _o[130] = _o[40] = 0, mo[130] = mo[40] = 1, xo[130] = xo[40] = 1, go[130] = go[40] = 0, yo[130] = yo[40] = 1, vo[130] = vo[40] = 0, no[130] = no[40] = 0, ro[130] = ro[40] = -1, io[130] = io[40] = 0, oo[130] = oo[40] = 0, so[130] = so[40] = -1, ao[130] = ao[40] = 1, ho[37] = ho[133] = 0, po[37] = po[133] = 1, fo[37] = fo[133] = 1, Io[37] = Io[133] = 0, No[37] = No[133] = 1, So[37] = So[133] = 0, no[37] = no[133] = -1, ro[37] = ro[133] = 0, io[37] = io[133] = 0, oo[37] = oo[133] = 1, so[37] = so[133] = 0, ao[37] = ao[133] = 0, _o[148] = _o[22] = -1, mo[148] = mo[22] = 0, xo[148] = xo[22] = 0, Io[148] = Io[22] = 0, No[148] = No[22] = -1, So[148] = So[22] = 1, Eo[148] = Eo[22] = 0, bo[148] = bo[22] = 1, wo[148] = wo[22] = 1, oo[148] = oo[22] = -1, so[148] = so[22] = 0, ao[148] = ao[22] = 1, uo[82] = uo[88] = 0, lo[82] = lo[88] = -1, co[82] = co[88] = 1, _o[82] = _o[88] = 1, mo[82] = mo[88] = 0, xo[82] = xo[88] = 1, go[82] = go[88] = -1, yo[82] = yo[88] = 0, vo[82] = vo[88] = 1, Eo[82] = Eo[88] = 0, bo[82] = bo[88] = -1, wo[82] = wo[88] = 0, uo[73] = uo[97] = 0, lo[73] = lo[97] = 1, co[73] = co[97] = 0, ho[73] = ho[97] = 0, po[73] = po[97] = -1, fo[73] = fo[97] = 0, go[73] = go[97] = 1, yo[73] = yo[97] = 0, vo[73] = vo[97] = 0, no[73] = no[97] = 1, ro[73] = ro[97] = 0, io[73] = io[97] = 1, uo[145] = uo[25] = 0, lo[145] = lo[25] = -1, co[145] = co[25] = 0, go[145] = go[25] = 1, yo[145] = yo[25] = 0, vo[145] = vo[25] = 1, Io[145] = Io[25] = 0, No[145] = No[25] = 1, So[145] = So[25] = 1, oo[145] = oo[25] = -1, so[145] = so[25] = 0, ao[145] = ao[25] = 0, ho[70] = ho[100] = 0, po[70] = po[100] = 1, fo[70] = fo[100] = 0, _o[70] = _o[100] = -1, mo[70] = mo[100] = 0, xo[70] = xo[100] = 1, Eo[70] = Eo[100] = 0, bo[70] = bo[100] = -1, wo[70] = wo[100] = 1, no[70] = no[100] = 1, ro[70] = ro[100] = 0, io[70] = io[100] = 0, ho[101] = ho[69] = 0, po[101] = po[69] = 1, fo[101] = fo[69] = 0, no[101] = no[69] = 1, ro[101] = ro[69] = 0, io[101] = io[69] = 0, Io[149] = Io[21] = 0, No[149] = No[21] = 1, So[149] = So[21] = 1, oo[149] = oo[21] = -1, so[149] = so[21] = 0, ao[149] = ao[21] = 0, _o[86] = _o[84] = -1, mo[86] = mo[84] = 0, xo[86] = xo[84] = 1, Eo[86] = Eo[84] = 0, bo[86] = bo[84] = -1, wo[86] = wo[84] = 1, uo[89] = uo[81] = 0, lo[89] = lo[81] = -1, co[89] = co[81] = 0, go[89] = go[81] = 1, yo[89] = yo[81] = 0, vo[89] = vo[81] = 1, uo[96] = uo[74] = 0, lo[96] = lo[74] = 1, co[96] = co[74] = 0, ho[96] = ho[74] = -1, po[96] = po[74] = 0, fo[96] = fo[74] = 1, Eo[96] = Eo[74] = 1, bo[96] = bo[74] = 0, wo[96] = wo[74] = 0, no[96] = no[74] = 1, ro[96] = ro[74] = 0, io[96] = io[74] = 1, uo[24] = uo[146] = 0, lo[24] = lo[146] = -1, co[24] = co[146] = 1, _o[24] = _o[146] = 1, mo[24] = mo[146] = 0, xo[24] = xo[146] = 1, go[24] = go[146] = 0, yo[24] = yo[146] = 1, vo[24] = vo[146] = 1, oo[24] = oo[146] = 0, so[24] = so[146] = -1, ao[24] = ao[146] = 0, ho[6] = ho[164] = -1, po[6] = po[164] = 0, fo[6] = fo[164] = 1, _o[6] = _o[164] = -1, mo[6] = mo[164] = 0, xo[6] = xo[164] = 0, Io[6] = Io[164] = 0, No[6] = No[164] = -1, So[6] = So[164] = 1, Eo[6] = Eo[164] = 1, bo[6] = bo[164] = 0, wo[6] = wo[164] = 0, go[129] = go[41] = 0, yo[129] = yo[41] = 1, vo[129] = vo[41] = 1, Io[129] = Io[41] = 0, No[129] = No[41] = 1, So[129] = So[41] = 0, no[129] = no[41] = -1, ro[129] = ro[41] = 0, io[129] = io[41] = 0, oo[129] = oo[41] = 0, so[129] = so[41] = -1, ao[129] = ao[41] = 0, _o[66] = _o[104] = 0, mo[66] = mo[104] = 1, xo[66] = xo[104] = 0, go[66] = go[104] = -1, yo[66] = yo[104] = 0, vo[66] = vo[104] = 1, Eo[66] = Eo[104] = 0, bo[66] = bo[104] = -1, wo[66] = wo[104] = 0, no[66] = no[104] = 0, ro[66] = ro[104] = -1, io[66] = io[104] = 1, uo[144] = uo[26] = -1, lo[144] = lo[26] = 0, co[144] = co[26] = 0, Io[144] = Io[26] = 1, No[144] = No[26] = 0, So[144] = So[26] = 1, Eo[144] = Eo[26] = 0, bo[144] = bo[26] = 1, wo[144] = wo[26] = 1, oo[144] = oo[26] = -1, so[144] = so[26] = 0, ao[144] = ao[26] = 1, ho[36] = ho[134] = 0, po[36] = po[134] = 1, fo[36] = fo[134] = 1, _o[36] = _o[134] = 0, mo[36] = mo[134] = 1, xo[36] = xo[134] = 0, no[36] = no[134] = 0, ro[36] = ro[134] = -1, io[36] = io[134] = 1, oo[36] = oo[134] = 1, so[36] = so[134] = 0, ao[36] = ao[134] = 0, uo[9] = uo[161] = -1, lo[9] = lo[161] = 0, co[9] = co[161] = 0, ho[9] = ho[161] = 0, po[9] = po[161] = -1, fo[9] = fo[161] = 0, go[9] = go[161] = 1, yo[9] = yo[161] = 0, vo[9] = vo[161] = 0, Io[9] = Io[161] = 1, No[9] = No[161] = 0, So[9] = So[161] = 1, uo[136] = 0, lo[136] = 1, co[136] = 1, ho[136] = 0, po[136] = 1, fo[136] = 0, _o[136] = -1, mo[136] = 0, xo[136] = 1, go[136] = -1, yo[136] = 0, vo[136] = 0, Io[136] = 0, No[136] = -1, So[136] = 0, Eo[136] = 0, bo[136] = -1, wo[136] = 1, no[136] = 1, ro[136] = 0, io[136] = 0, oo[136] = 1, so[136] = 0, ao[136] = 1, uo[34] = 0, lo[34] = -1, co[34] = 0, ho[34] = 0, po[34] = -1, fo[34] = 1, _o[34] = 1, mo[34] = 0, xo[34] = 0, go[34] = 1, yo[34] = 0, vo[34] = 1, Io[34] = 0, No[34] = 1, So[34] = 1, Eo[34] = 0, bo[34] = 1, wo[34] = 0, no[34] = -1, ro[34] = 0, io[34] = 1, oo[34] = -1, so[34] = 0, ao[34] = 0, uo[35] = 0, lo[35] = 1, co[35] = 1, ho[35] = 0, po[35] = -1, fo[35] = 1, _o[35] = 1, mo[35] = 0, xo[35] = 0, go[35] = -1, yo[35] = 0, vo[35] = 0, Io[35] = 0, No[35] = -1, So[35] = 0, Eo[35] = 0, bo[35] = 1, wo[35] = 0, no[35] = -1, ro[35] = 0, io[35] = 1, oo[35] = 1, so[35] = 0, ao[35] = 1, uo[153] = 0, lo[153] = 1, co[153] = 1, go[153] = -1, yo[153] = 0, vo[153] = 0, Io[153] = 0, No[153] = -1, So[153] = 0, oo[153] = 1, so[153] = 0, ao[153] = 1, ho[102] = 0, po[102] = -1, fo[102] = 1, _o[102] = 1, mo[102] = 0, xo[102] = 0, Eo[102] = 0, bo[102] = 1, wo[102] = 0, no[102] = -1, ro[102] = 0, io[102] = 1, uo[155] = 0, lo[155] = -1, co[155] = 0, go[155] = 1, yo[155] = 0, vo[155] = 1, Io[155] = 0, No[155] = 1, So[155] = 1, oo[155] = -1, so[155] = 0, ao[155] = 0, ho[103] = 0, po[103] = 1, fo[103] = 0, _o[103] = -1, mo[103] = 0, xo[103] = 1, Eo[103] = 0, bo[103] = -1, wo[103] = 1, no[103] = 1, ro[103] = 0, io[103] = 0, uo[152] = 0, lo[152] = 1, co[152] = 1, _o[152] = -1, mo[152] = 0, xo[152] = 1, go[152] = -1, yo[152] = 0, vo[152] = 0, Io[152] = 0, No[152] = -1, So[152] = 0, Eo[152] = 0, bo[152] = -1, wo[152] = 1, oo[152] = 1, so[152] = 0, ao[152] = 1, uo[156] = 0, lo[156] = -1, co[156] = 1, _o[156] = 1, mo[156] = 0, xo[156] = 1, go[156] = -1, yo[156] = 0, vo[156] = 0, Io[156] = 0, No[156] = -1, So[156] = 0, Eo[156] = 0, bo[156] = 1, wo[156] = 1, oo[156] = -1, so[156] = 0, ao[156] = 1, uo[137] = 0, lo[137] = 1, co[137] = 1, ho[137] = 0, po[137] = 1, fo[137] = 0, go[137] = -1, yo[137] = 0, vo[137] = 0, Io[137] = 0, No[137] = -1, So[137] = 0, no[137] = 1, ro[137] = 0, io[137] = 0, oo[137] = 1, so[137] = 0, ao[137] = 1, uo[139] = 0, lo[139] = 1, co[139] = 1, ho[139] = 0, po[139] = -1, fo[139] = 0, go[139] = 1, yo[139] = 0, vo[139] = 0, Io[139] = 0, No[139] = 1, So[139] = 0, no[139] = -1, ro[139] = 0, io[139] = 0, oo[139] = 1, so[139] = 0, ao[139] = 1, uo[98] = 0, lo[98] = -1, co[98] = 0, ho[98] = 0, po[98] = -1, fo[98] = 1, _o[98] = 1, mo[98] = 0, xo[98] = 0, go[98] = 1, yo[98] = 0, vo[98] = 1, Eo[98] = 0, bo[98] = 1, wo[98] = 0, no[98] = -1, ro[98] = 0, io[98] = 1, uo[99] = 0, lo[99] = 1, co[99] = 0, ho[99] = 0, po[99] = -1, fo[99] = 1, _o[99] = 1, mo[99] = 0, xo[99] = 0, go[99] = -1, yo[99] = 0, vo[99] = 1, Eo[99] = 0, bo[99] = -1, wo[99] = 0, no[99] = 1, ro[99] = 0, io[99] = 1, ho[38] = 0, po[38] = -1, fo[38] = 1, _o[38] = 1, mo[38] = 0, xo[38] = 0, Io[38] = 0, No[38] = 1, So[38] = 1, Eo[38] = 0, bo[38] = 1, wo[38] = 0, no[38] = -1, ro[38] = 0, io[38] = 1, oo[38] = -1, so[38] = 0, ao[38] = 0, ho[39] = 0, po[39] = 1, fo[39] = 1, _o[39] = -1, mo[39] = 0, xo[39] = 0, Io[39] = 0, No[39] = -1, So[39] = 1, Eo[39] = 0, bo[39] = 1, wo[39] = 0, no[39] = -1, ro[39] = 0, io[39] = 1, oo[39] = 1, so[39] = 0, ao[39] = 0;\n  var Co = function Co(t) {\n      return [[t.bottomleft, 0], [0, 0], [0, t.leftbottom]];\n    },\n    Po = function Po(t) {\n      return [[1, t.rightbottom], [1, 0], [t.bottomright, 0]];\n    },\n    Mo = function Mo(t) {\n      return [[t.topright, 1], [1, 1], [1, t.righttop]];\n    },\n    Lo = function Lo(t) {\n      return [[0, t.lefttop], [0, 1], [t.topleft, 1]];\n    },\n    Oo = function Oo(t) {\n      return [[t.bottomright, 0], [t.bottomleft, 0], [0, t.leftbottom], [0, t.lefttop]];\n    },\n    Ro = function Ro(t) {\n      return [[t.bottomright, 0], [t.bottomleft, 0], [1, t.righttop], [1, t.rightbottom]];\n    },\n    To = function To(t) {\n      return [[1, t.righttop], [1, t.rightbottom], [t.topleft, 1], [t.topright, 1]];\n    },\n    Ao = function Ao(t) {\n      return [[0, t.leftbottom], [0, t.lefttop], [t.topleft, 1], [t.topright, 1]];\n    },\n    Do = [],\n    Fo = [],\n    ko = [],\n    Go = [],\n    qo = [],\n    Bo = [],\n    zo = [],\n    jo = [];\n  Go[1] = qo[1] = 18, Go[169] = qo[169] = 18, ko[4] = Fo[4] = 12, ko[166] = Fo[166] = 12, Do[16] = jo[16] = 4, Do[154] = jo[154] = 4, Bo[64] = zo[64] = 22, Bo[106] = zo[106] = 22, ko[2] = Bo[2] = 17, Go[2] = qo[2] = 18, ko[168] = Bo[168] = 17, Go[168] = qo[168] = 18, Do[8] = Go[8] = 9, Fo[8] = ko[8] = 12, Do[162] = Go[162] = 9, Fo[162] = ko[162] = 12, Do[32] = jo[32] = 4, Fo[32] = zo[32] = 1, Do[138] = jo[138] = 4, Fo[138] = zo[138] = 1, qo[128] = jo[128] = 21, Bo[128] = zo[128] = 22, qo[42] = jo[42] = 21, Bo[42] = zo[42] = 22, Fo[5] = qo[5] = 14, Fo[165] = qo[165] = 14, ko[20] = jo[20] = 6, ko[150] = jo[150] = 6, Do[80] = Bo[80] = 11, Do[90] = Bo[90] = 11, Go[65] = zo[65] = 3, Go[105] = zo[105] = 3, Do[160] = Bo[160] = 11, Fo[160] = qo[160] = 14, Do[10] = Bo[10] = 11, Fo[10] = qo[10] = 14, ko[130] = jo[130] = 6, Go[130] = zo[130] = 3, ko[40] = jo[40] = 6, Go[40] = zo[40] = 3, Fo[101] = zo[101] = 1, Fo[69] = zo[69] = 1, qo[149] = jo[149] = 21, qo[21] = jo[21] = 21, ko[86] = Bo[86] = 17, ko[84] = Bo[84] = 17, Do[89] = Go[89] = 9, Do[81] = Go[81] = 9, Do[96] = zo[96] = 0, Fo[96] = Bo[96] = 15, Do[74] = zo[74] = 0, Fo[74] = Bo[74] = 15, Do[24] = ko[24] = 8, Go[24] = jo[24] = 7, Do[146] = ko[146] = 8, Go[146] = jo[146] = 7, Fo[6] = Bo[6] = 15, ko[6] = qo[6] = 16, Fo[164] = Bo[164] = 15, ko[164] = qo[164] = 16, Go[129] = jo[129] = 7, qo[129] = zo[129] = 20, Go[41] = jo[41] = 7, qo[41] = zo[41] = 20, ko[66] = zo[66] = 2, Go[66] = Bo[66] = 19, ko[104] = zo[104] = 2, Go[104] = Bo[104] = 19, Do[144] = qo[144] = 10, Bo[144] = jo[144] = 23, Do[26] = qo[26] = 10, Bo[26] = jo[26] = 23, Fo[36] = jo[36] = 5, ko[36] = zo[36] = 2, Fo[134] = jo[134] = 5, ko[134] = zo[134] = 2, Do[9] = qo[9] = 10, Fo[9] = Go[9] = 13, Do[161] = qo[161] = 10, Fo[161] = Go[161] = 13, Fo[37] = jo[37] = 5, qo[37] = zo[37] = 20, Fo[133] = jo[133] = 5, qo[133] = zo[133] = 20, ko[148] = qo[148] = 16, Bo[148] = jo[148] = 23, ko[22] = qo[22] = 16, Bo[22] = jo[22] = 23, Do[82] = ko[82] = 8, Go[82] = Bo[82] = 19, Do[88] = ko[88] = 8, Go[88] = Bo[88] = 19, Do[73] = zo[73] = 0, Fo[73] = Go[73] = 13, Do[97] = zo[97] = 0, Fo[97] = Go[97] = 13, Do[145] = Go[145] = 9, qo[145] = jo[145] = 21, Do[25] = Go[25] = 9, qo[25] = jo[25] = 21, Fo[70] = zo[70] = 1, ko[70] = Bo[70] = 17, Fo[100] = zo[100] = 1, ko[100] = Bo[100] = 17, Do[34] = Go[34] = 9, Fo[34] = ko[34] = 12, qo[34] = jo[34] = 21, Bo[34] = zo[34] = 22, Do[136] = jo[136] = 4, Fo[136] = zo[136] = 1, ko[136] = Bo[136] = 17, Go[136] = qo[136] = 18, Do[35] = jo[35] = 4, Fo[35] = ko[35] = 12, Go[35] = qo[35] = 18, Bo[35] = zo[35] = 22, Do[153] = jo[153] = 4, Go[153] = qo[153] = 18, Fo[102] = ko[102] = 12, Bo[102] = zo[102] = 22, Do[155] = Go[155] = 9, qo[155] = jo[155] = 23, Fo[103] = zo[103] = 1, ko[103] = Bo[103] = 17, Do[152] = jo[152] = 4, ko[152] = Bo[152] = 17, Go[152] = qo[152] = 18, Do[156] = ko[156] = 8, Go[156] = qo[156] = 18, Bo[156] = jo[156] = 23, Do[137] = jo[137] = 4, Fo[137] = zo[137] = 1, Go[137] = qo[137] = 18, Do[139] = jo[139] = 4, Fo[139] = Go[139] = 13, qo[139] = zo[139] = 20, Do[98] = Go[98] = 9, Fo[98] = ko[98] = 12, Bo[98] = zo[98] = 22, Do[99] = zo[99] = 0, Fo[99] = ko[99] = 12, Go[99] = Bo[99] = 19, Fo[38] = ko[38] = 12, qo[38] = jo[38] = 21, Bo[38] = zo[38] = 22, Fo[39] = jo[39] = 5, ko[39] = qo[39] = 16, Bo[39] = zo[39] = 22;\n  var Uo = [];\n  function Vo(t, e, n) {\n    return (t - e) / (n - e);\n  }\n  function Xo(t) {\n    return t.constructor.toString().indexOf(\"Array\") > -1;\n  }\n  function Yo(t, e, n, r, i, o) {\n    for (var s = t.cells[n][e], a = s.cval_real, u = e + r, l = n + i, c = [], h = !1; !h;) {\n      if (void 0 === t.cells[l] || void 0 === t.cells[l][u]) {\n        if (l -= i, u -= r, a = (s = t.cells[l][u]).cval_real, -1 === i) {\n          if (0 === o) {\n            if (1 & a) c.push([u, l]), r = -1, i = 0, o = 0;else {\n              if (!(4 & a)) {\n                c.push([u + s.bottomright, l]), r = 0, i = 1, o = 1, h = !0;\n                break;\n              }\n              c.push([u + 1, l]), r = 1, i = 0, o = 0;\n            }\n          } else {\n            if (!(1 & a)) {\n              if (4 & a) {\n                c.push([u + s.bottomright, l]), r = 0, i = 1, o = 1, h = !0;\n                break;\n              }\n              c.push([u + s.bottomleft, l]), r = 0, i = 1, o = 0, h = !0;\n              break;\n            }\n            c.push([u, l]), r = -1, i = 0, o = 0;\n          }\n        } else if (1 === i) {\n          if (0 === o) {\n            if (!(a & eo)) {\n              if (a & to) {\n                c.push([u + s.topleft, l + 1]), r = 0, i = -1, o = 0, h = !0;\n                break;\n              }\n              c.push([u + s.topright, l + 1]), r = 0, i = -1, o = 1, h = !0;\n              break;\n            }\n            c.push([u + 1, l + 1]), r = 1, i = 0, o = 1;\n          } else c.push([u + 1, l + 1]), r = 1, i = 0, o = 1;\n        } else if (-1 === r) {\n          if (0 === o) {\n            if (!(a & to)) {\n              if (1 & a) {\n                c.push([u, l + s.leftbottom]), r = 1, i = 0, o = 0, h = !0;\n                break;\n              }\n              c.push([u, l + s.lefttop]), r = 1, i = 0, o = 1, h = !0;\n              break;\n            }\n            c.push([u, l + 1]), r = 0, i = 1, o = 0;\n          } else {\n            if (!(a & to)) {\n              console.log(\"MarchingSquaresJS-isoBands: wtf\");\n              break;\n            }\n            c.push([u, l + 1]), r = 0, i = 1, o = 0;\n          }\n        } else {\n          if (1 !== r) {\n            console.log(\"MarchingSquaresJS-isoBands: we came from nowhere!\");\n            break;\n          }\n          if (0 === o) {\n            if (!(4 & a)) {\n              c.push([u + 1, l + s.rightbottom]), r = -1, i = 0, o = 0, h = !0;\n              break;\n            }\n            c.push([u + 1, l]), r = 0, i = -1, o = 1;\n          } else {\n            if (!(4 & a)) {\n              if (a & eo) {\n                c.push([u + 1, l + s.righttop]), r = -1, i = 0, o = 1;\n                break;\n              }\n              c.push([u + 1, l + s.rightbottom]), r = -1, i = 0, o = 0, h = !0;\n              break;\n            }\n            c.push([u + 1, l]), r = 0, i = -1, o = 1;\n          }\n        }\n      } else if (a = (s = t.cells[l][u]).cval_real, -1 === r) {\n        if (0 === o) {\n          if (void 0 !== t.cells[l - 1] && void 0 !== t.cells[l - 1][u]) r = 0, i = -1, o = 1;else {\n            if (!(1 & a)) {\n              c.push([u + s.bottomright, l]), r = 0, i = 1, o = 1, h = !0;\n              break;\n            }\n            c.push([u, l]);\n          }\n        } else {\n          if (!(a & to)) {\n            console.log(\"MarchingSquaresJS-isoBands: found entry from top at \" + u + \",\" + l);\n            break;\n          }\n          console.log(\"MarchingSquaresJS-isoBands: proceeding in x-direction!\");\n        }\n      } else if (1 === r) {\n        if (0 === o) {\n          console.log(\"MarchingSquaresJS-isoBands: wtf\");\n          break;\n        }\n        if (void 0 !== t.cells[l + 1] && void 0 !== t.cells[l + 1][u]) r = 0, i = 1, o = 0;else {\n          if (!(a & eo)) {\n            c.push([u + s.topleft, l + 1]), r = 0, i = -1, o = 0, h = !0;\n            break;\n          }\n          c.push([u + 1, l + 1]), r = 1, i = 0, o = 1;\n        }\n      } else if (-1 === i) {\n        if (1 !== o) {\n          console.log(\"MarchingSquaresJS-isoBands: wtf\");\n          break;\n        }\n        if (void 0 !== t.cells[l][u + 1]) r = 1, i = 0, o = 1;else {\n          if (!(4 & a)) {\n            c.push([u + 1, l + s.righttop]), r = -1, i = 0, o = 1, h = !0;\n            break;\n          }\n          c.push([u + 1, l]), r = 0, i = -1, o = 1;\n        }\n      } else {\n        if (1 !== i) {\n          console.log(\"MarchingSquaresJS-isoBands: where did we came from???\");\n          break;\n        }\n        if (0 !== o) {\n          console.log(\"MarchingSquaresJS-isoBands: wtf\");\n          break;\n        }\n        if (void 0 !== t.cells[l][u - 1]) r = -1, i = 0, o = 0;else {\n          if (!(a & to)) {\n            c.push([u, l + s.leftbottom]), r = 1, i = 0, o = 0, h = !0;\n            break;\n          }\n          c.push([u, l + 1]), r = 0, i = 1, o = 0;\n        }\n      }\n      if (l += i, (u += r) === e && l === n) break;\n    }\n    return {\n      path: c,\n      i: u,\n      j: l,\n      x: r,\n      y: i,\n      o: o\n    };\n  }\n  function Ho(t) {\n    if (t.edges.length > 0) {\n      var e = t.edges[t.edges.length - 1],\n        n = t.cval_real;\n      switch (e) {\n        case 0:\n          return n & eo ? {\n            p: [1, t.righttop],\n            x: -1,\n            y: 0,\n            o: 1\n          } : {\n            p: [t.topleft, 1],\n            x: 0,\n            y: -1,\n            o: 0\n          };\n        case 1:\n          return 4 & n ? {\n            p: [t.topleft, 1],\n            x: 0,\n            y: -1,\n            o: 0\n          } : {\n            p: [1, t.rightbottom],\n            x: -1,\n            y: 0,\n            o: 0\n          };\n        case 2:\n          return 4 & n ? {\n            p: [t.bottomright, 0],\n            x: 0,\n            y: 1,\n            o: 1\n          } : {\n            p: [t.topleft, 1],\n            x: 0,\n            y: -1,\n            o: 0\n          };\n        case 3:\n          return 1 & n ? {\n            p: [t.topleft, 1],\n            x: 0,\n            y: -1,\n            o: 0\n          } : {\n            p: [t.bottomleft, 0],\n            x: 0,\n            y: 1,\n            o: 0\n          };\n        case 4:\n          return n & eo ? {\n            p: [1, t.righttop],\n            x: -1,\n            y: 0,\n            o: 1\n          } : {\n            p: [t.topright, 1],\n            x: 0,\n            y: -1,\n            o: 1\n          };\n        case 5:\n          return 4 & n ? {\n            p: [t.topright, 1],\n            x: 0,\n            y: -1,\n            o: 1\n          } : {\n            p: [1, t.rightbottom],\n            x: -1,\n            y: 0,\n            o: 0\n          };\n        case 6:\n          return 4 & n ? {\n            p: [t.bottomright, 0],\n            x: 0,\n            y: 1,\n            o: 1\n          } : {\n            p: [t.topright, 1],\n            x: 0,\n            y: -1,\n            o: 1\n          };\n        case 7:\n          return 1 & n ? {\n            p: [t.topright, 1],\n            x: 0,\n            y: -1,\n            o: 1\n          } : {\n            p: [t.bottomleft, 0],\n            x: 0,\n            y: 1,\n            o: 0\n          };\n        case 8:\n          return 4 & n ? {\n            p: [t.bottomright, 0],\n            x: 0,\n            y: 1,\n            o: 1\n          } : {\n            p: [1, t.righttop],\n            x: -1,\n            y: 0,\n            o: 1\n          };\n        case 9:\n          return 1 & n ? {\n            p: [1, t.righttop],\n            x: -1,\n            y: 0,\n            o: 1\n          } : {\n            p: [t.bottomleft, 0],\n            x: 0,\n            y: 1,\n            o: 0\n          };\n        case 10:\n          return 1 & n ? {\n            p: [0, t.leftbottom],\n            x: 1,\n            y: 0,\n            o: 0\n          } : {\n            p: [1, t.righttop],\n            x: -1,\n            y: 0,\n            o: 1\n          };\n        case 11:\n          return n & to ? {\n            p: [1, t.righttop],\n            x: -1,\n            y: 0,\n            o: 1\n          } : {\n            p: [0, t.lefttop],\n            x: 1,\n            y: 0,\n            o: 1\n          };\n        case 12:\n          return 4 & n ? {\n            p: [t.bottomright, 0],\n            x: 0,\n            y: 1,\n            o: 1\n          } : {\n            p: [1, t.rightbottom],\n            x: -1,\n            y: 0,\n            o: 0\n          };\n        case 13:\n          return 1 & n ? {\n            p: [1, t.rightbottom],\n            x: -1,\n            y: 0,\n            o: 0\n          } : {\n            p: [t.bottomleft, 0],\n            x: 0,\n            y: 1,\n            o: 0\n          };\n        case 14:\n          return 1 & n ? {\n            p: [0, t.leftbottom],\n            x: 1,\n            y: 0,\n            o: 0\n          } : {\n            p: [1, t.rightbottom],\n            x: -1,\n            y: 0,\n            o: 0\n          };\n        case 15:\n          return n & to ? {\n            p: [1, t.rightbottom],\n            x: -1,\n            y: 0,\n            o: 0\n          } : {\n            p: [0, t.lefttop],\n            x: 1,\n            y: 0,\n            o: 1\n          };\n        case 16:\n          return 4 & n ? {\n            p: [t.bottomright, 0],\n            x: 0,\n            y: 1,\n            o: 1\n          } : {\n            p: [0, t.leftbottom],\n            x: 1,\n            y: 0,\n            o: 0\n          };\n        case 17:\n          return n & to ? {\n            p: [t.bottomright, 0],\n            x: 0,\n            y: 1,\n            o: 1\n          } : {\n            p: [0, t.lefttop],\n            x: 1,\n            y: 0,\n            o: 1\n          };\n        case 18:\n          return 1 & n ? {\n            p: [0, t.leftbottom],\n            x: 1,\n            y: 0,\n            o: 0\n          } : {\n            p: [t.bottomleft, 0],\n            x: 0,\n            y: 1,\n            o: 0\n          };\n        case 19:\n          return n & to ? {\n            p: [t.bottomleft, 0],\n            x: 0,\n            y: 1,\n            o: 0\n          } : {\n            p: [0, t.lefttop],\n            x: 1,\n            y: 0,\n            o: 1\n          };\n        case 20:\n          return n & to ? {\n            p: [t.topleft, 1],\n            x: 0,\n            y: -1,\n            o: 0\n          } : {\n            p: [0, t.leftbottom],\n            x: 1,\n            y: 0,\n            o: 0\n          };\n        case 21:\n          return n & eo ? {\n            p: [0, t.leftbottom],\n            x: 1,\n            y: 0,\n            o: 0\n          } : {\n            p: [t.topright, 1],\n            x: 0,\n            y: -1,\n            o: 1\n          };\n        case 22:\n          return n & to ? {\n            p: [t.topleft, 1],\n            x: 0,\n            y: -1,\n            o: 0\n          } : {\n            p: [0, t.lefttop],\n            x: 1,\n            y: 0,\n            o: 1\n          };\n        case 23:\n          return n & eo ? {\n            p: [0, t.lefttop],\n            x: 1,\n            y: 0,\n            o: 1\n          } : {\n            p: [t.topright, 1],\n            x: 0,\n            y: -1,\n            o: 1\n          };\n        default:\n          console.log(\"MarchingSquaresJS-isoBands: edge index out of range!\"), console.log(t);\n      }\n    }\n    return null;\n  }\n  function Wo(t, e, n, r) {\n    var i,\n      o,\n      s,\n      a,\n      u,\n      l = t.cval;\n    switch (e) {\n      case -1:\n        switch (r) {\n          case 0:\n            i = Fo[l], s = ho[l], a = po[l], u = fo[l];\n            break;\n          default:\n            i = Do[l], s = uo[l], a = lo[l], u = co[l];\n        }\n        break;\n      case 1:\n        switch (r) {\n          case 0:\n            i = qo[l], s = Io[l], a = No[l], u = So[l];\n            break;\n          default:\n            i = Bo[l], s = Eo[l], a = bo[l], u = wo[l];\n        }\n        break;\n      default:\n        switch (n) {\n          case -1:\n            switch (r) {\n              case 0:\n                i = zo[l], s = no[l], a = ro[l], u = io[l];\n                break;\n              default:\n                i = jo[l], s = oo[l], a = so[l], u = ao[l];\n            }\n            break;\n          case 1:\n            switch (r) {\n              case 0:\n                i = Go[l], s = go[l], a = yo[l], u = vo[l];\n                break;\n              default:\n                i = ko[l], s = _o[l], a = mo[l], u = xo[l];\n            }\n        }\n    }\n    if (o = t.edges.indexOf(i), void 0 === t.edges[o]) return null;\n    switch (function (t, e) {\n      delete t.edges[e];\n      for (var n = e + 1; n < t.edges.length; n++) t.edges[n - 1] = t.edges[n];\n      t.edges.pop();\n    }(t, o), l = t.cval_real, i) {\n      case 0:\n        l & eo ? (e = t.topleft, n = 1) : (e = 1, n = t.righttop);\n        break;\n      case 1:\n        4 & l ? (e = 1, n = t.rightbottom) : (e = t.topleft, n = 1);\n        break;\n      case 2:\n        4 & l ? (e = t.topleft, n = 1) : (e = t.bottomright, n = 0);\n        break;\n      case 3:\n        1 & l ? (e = t.bottomleft, n = 0) : (e = t.topleft, n = 1);\n        break;\n      case 4:\n        l & eo ? (e = t.topright, n = 1) : (e = 1, n = t.righttop);\n        break;\n      case 5:\n        4 & l ? (e = 1, n = t.rightbottom) : (e = t.topright, n = 1);\n        break;\n      case 6:\n        4 & l ? (e = t.topright, n = 1) : (e = t.bottomright, n = 0);\n        break;\n      case 7:\n        1 & l ? (e = t.bottomleft, n = 0) : (e = t.topright, n = 1);\n        break;\n      case 8:\n        4 & l ? (e = 1, n = t.righttop) : (e = t.bottomright, n = 0);\n        break;\n      case 9:\n        1 & l ? (e = t.bottomleft, n = 0) : (e = 1, n = t.righttop);\n        break;\n      case 10:\n        1 & l ? (e = 1, n = t.righttop) : (e = 0, n = t.leftbottom);\n        break;\n      case 11:\n        l & to ? (e = 0, n = t.lefttop) : (e = 1, n = t.righttop);\n        break;\n      case 12:\n        4 & l ? (e = 1, n = t.rightbottom) : (e = t.bottomright, n = 0);\n        break;\n      case 13:\n        1 & l ? (e = t.bottomleft, n = 0) : (e = 1, n = t.rightbottom);\n        break;\n      case 14:\n        1 & l ? (e = 1, n = t.rightbottom) : (e = 0, n = t.leftbottom);\n        break;\n      case 15:\n        l & to ? (e = 0, n = t.lefttop) : (e = 1, n = t.rightbottom);\n        break;\n      case 16:\n        4 & l ? (e = 0, n = t.leftbottom) : (e = t.bottomright, n = 0);\n        break;\n      case 17:\n        l & to ? (e = 0, n = t.lefttop) : (e = t.bottomright, n = 0);\n        break;\n      case 18:\n        1 & l ? (e = t.bottomleft, n = 0) : (e = 0, n = t.leftbottom);\n        break;\n      case 19:\n        l & to ? (e = 0, n = t.lefttop) : (e = t.bottomleft, n = 0);\n        break;\n      case 20:\n        l & to ? (e = 0, n = t.leftbottom) : (e = t.topleft, n = 1);\n        break;\n      case 21:\n        l & eo ? (e = t.topright, n = 1) : (e = 0, n = t.leftbottom);\n        break;\n      case 22:\n        l & to ? (e = 0, n = t.lefttop) : (e = t.topleft, n = 1);\n        break;\n      case 23:\n        l & eo ? (e = t.topright, n = 1) : (e = 0, n = t.lefttop);\n        break;\n      default:\n        return console.log(\"MarchingSquaresJS-isoBands: edge index out of range!\"), console.log(t), null;\n    }\n    return void 0 !== e && void 0 !== n && void 0 !== s && void 0 !== a && void 0 !== u || (console.log(\"MarchingSquaresJS-isoBands: undefined value!\"), console.log(t), console.log(e + \" \" + n + \" \" + s + \" \" + a + \" \" + u)), {\n      p: [e, n],\n      x: s,\n      y: a,\n      o: u\n    };\n  }\n  function Jo(t) {\n    var e = [],\n      n = [];\n    t.forEach(function (t) {\n      var r = jr(l([t]));\n      n.push(r), e.push({\n        ring: t,\n        area: r\n      });\n    }), n.sort(function (t, e) {\n      return e - t;\n    });\n    var r = [];\n    return n.forEach(function (t) {\n      for (var n = 0; n < e.length; n++) if (e[n].area === t) {\n        r.push(e[n].ring), e.splice(n, 1);\n        break;\n      }\n    }), r;\n  }\n  function Zo(t) {\n    for (var e = t.map(function (t) {\n        return {\n          lrCoordinates: t,\n          grouped: !1\n        };\n      }), n = []; !Qo(e);) for (var r = 0; r < e.length; r++) if (!e[r].grouped) {\n      var i = [];\n      i.push(e[r].lrCoordinates), e[r].grouped = !0;\n      for (var o = l([e[r].lrCoordinates]), s = r + 1; s < e.length; s++) {\n        if (!e[s].grouped) Ko(l([e[s].lrCoordinates]), o) && (i.push(e[s].lrCoordinates), e[s].grouped = !0);\n      }\n      n.push(i);\n    }\n    return n;\n  }\n  function Ko(t, e) {\n    for (var n = bn(t), r = 0; r < n.features.length; r++) if (!ye(n.features[r], e)) return !1;\n    return !0;\n  }\n  function Qo(t) {\n    for (var e = 0; e < t.length; e++) if (!1 === t[e].grouped) return !1;\n    return !0;\n  }\n  function $o(t, e, n) {\n    if (!P(n = n || {})) throw new Error(\"options is invalid\");\n    var r = n.pivot,\n      i = n.mutate;\n    if (!t) throw new Error(\"geojson is required\");\n    if (null == e || isNaN(e)) throw new Error(\"angle is required\");\n    return 0 === e || (r || (r = En(t)), !1 !== i && void 0 !== i || (t = Ie(t)), R(t, function (t) {\n      var n = Bi(r, t) + e,\n        i = Ar(r, t),\n        o = Q(ji(r, i, n));\n      t[0] = o[0], t[1] = o[1];\n    })), t;\n  }\n  function ts(t, e, n) {\n    if (!P(n = n || {})) throw new Error(\"options is invalid\");\n    var r = n.origin,\n      i = n.mutate;\n    if (!t) throw new Error(\"geojson required\");\n    if (\"number\" != typeof e || 0 === e) throw new Error(\"invalid factor\");\n    var o = Array.isArray(r) || \"object\" == typeof r;\n    return !0 !== i && (t = Ie(t)), \"FeatureCollection\" !== t.type || o ? es(t, e, r) : (F(t, function (n, i) {\n      t.features[i] = es(n, e, r);\n    }), t);\n  }\n  function es(t, e, n) {\n    var r = \"Point\" === it(t);\n    return n = function (t, e) {\n      null == e && (e = \"centroid\");\n      if (Array.isArray(e) || \"object\" == typeof e) return K(e);\n      var n = t.bbox ? t.bbox : Z(t),\n        r = n[0],\n        i = n[1],\n        o = n[2],\n        s = n[3];\n      switch (e) {\n        case \"sw\":\n        case \"southwest\":\n        case \"westsouth\":\n        case \"bottomleft\":\n          return a([r, i]);\n        case \"se\":\n        case \"southeast\":\n        case \"eastsouth\":\n        case \"bottomright\":\n          return a([o, i]);\n        case \"nw\":\n        case \"northwest\":\n        case \"westnorth\":\n        case \"topleft\":\n          return a([r, s]);\n        case \"ne\":\n        case \"northeast\":\n        case \"eastnorth\":\n        case \"topright\":\n          return a([o, s]);\n        case \"center\":\n          return xn(t);\n        case void 0:\n        case null:\n        case \"centroid\":\n          return En(t);\n        default:\n          throw new Error(\"invalid origin\");\n      }\n    }(t, n), 1 === e || r || R(t, function (t) {\n      var r = Ar(n, t),\n        i = Bi(n, t),\n        o = Q(ji(n, r * e, i));\n      t[0] = o[0], t[1] = o[1], 3 === t.length && (t[2] *= e);\n    }), t;\n  }\n  function ns(t) {\n    var e = t[0],\n      n = t[1];\n    return [n[0] - e[0], n[1] - e[1]];\n  }\n  function rs(t, e) {\n    return t[0] * e[1] - e[0] * t[1];\n  }\n  function is(t, e) {\n    return !function (t, e) {\n      return 0 === rs(ns(t), ns(e));\n    }(t, e) && function (t, e) {\n      var n,\n        r,\n        i = t[0],\n        o = ns(t),\n        s = e[0],\n        a = ns(e),\n        u = rs(o, a);\n      return function (t, e) {\n        return [t[0] + e[0], t[1] + e[1]];\n      }(i, function (t, e) {\n        return [t * e[0], t * e[1]];\n      }(rs((r = i, [(n = s)[0] - r[0], n[1] - r[1]]), a) / u, o));\n    }(t, e);\n  }\n  function os(t, e, n) {\n    var r = [],\n      i = E(e, n),\n      o = Q(t),\n      s = [];\n    return o.forEach(function (t, e) {\n      if (e !== o.length - 1) {\n        var n = (l = t, c = o[e + 1], h = i, p = Math.sqrt((l[0] - c[0]) * (l[0] - c[0]) + (l[1] - c[1]) * (l[1] - c[1])), f = l[0] + h * (c[1] - l[1]) / p, g = c[0] + h * (c[1] - l[1]) / p, d = l[1] + h * (l[0] - c[0]) / p, y = c[1] + h * (l[0] - c[0]) / p, [[f, d], [g, y]]);\n        if (r.push(n), e > 0) {\n          var a = r[e - 1],\n            u = is(n, a);\n          !1 !== u && (a[1] = u, n[0] = u), s.push(a[0]), e === o.length - 2 && (s.push(n[0]), s.push(n[1]));\n        }\n        2 === o.length && (s.push(n[0]), s.push(n[1]));\n      }\n      var l, c, h, p, f, g, d, y;\n    }), h(s, t.properties);\n  }\n  function ss(t, e, n) {\n    var r = e[0] - t[0],\n      i = e[1] - t[1],\n      o = n[0] - e[0];\n    return function (t) {\n      return (t > 0) - (t < 0) || +t;\n    }(r * (n[1] - e[1]) - o * i);\n  }\n  function as(t, e) {\n    return e.geometry.coordinates[0].every(function (e) {\n      return ye(a(e), t);\n    });\n  }\n  Uo[1] = Uo[169] = Co, Uo[4] = Uo[166] = Po, Uo[16] = Uo[154] = Mo, Uo[64] = Uo[106] = Lo, Uo[168] = Uo[2] = Oo, Uo[162] = Uo[8] = Ro, Uo[138] = Uo[32] = To, Uo[42] = Uo[128] = Ao, Uo[5] = Uo[165] = function (t) {\n    return [[0, 0], [0, t.leftbottom], [1, t.rightbottom], [1, 0]];\n  }, Uo[20] = Uo[150] = function (t) {\n    return [[1, 0], [t.bottomright, 0], [t.topright, 1], [1, 1]];\n  }, Uo[80] = Uo[90] = function (t) {\n    return [[1, 1], [1, t.righttop], [0, t.lefttop], [0, 1]];\n  }, Uo[65] = Uo[105] = function (t) {\n    return [[t.bottomleft, 0], [0, 0], [0, 1], [t.topleft, 1]];\n  }, Uo[160] = Uo[10] = function (t) {\n    return [[1, t.righttop], [1, t.rightbottom], [0, t.leftbottom], [0, t.lefttop]];\n  }, Uo[130] = Uo[40] = function (t) {\n    return [[t.topleft, 1], [t.topright, 1], [t.bottomright, 0], [t.bottomleft, 0]];\n  }, Uo[85] = function () {\n    return [[0, 0], [0, 1], [1, 1], [1, 0]];\n  }, Uo[101] = Uo[69] = function (t) {\n    return [[1, t.rightbottom], [1, 0], [0, 0], [0, 1], [t.topleft, 1]];\n  }, Uo[149] = Uo[21] = function (t) {\n    return [[t.topright, 1], [1, 1], [1, 0], [0, 0], [0, t.leftbottom]];\n  }, Uo[86] = Uo[84] = function (t) {\n    return [[1, 0], [t.bottomright, 0], [0, t.lefttop], [0, 1], [1, 1]];\n  }, Uo[89] = Uo[81] = function (t) {\n    return [[1, 1], [1, t.righttop], [t.bottomleft, 0], [0, 0], [0, 1]];\n  }, Uo[96] = Uo[74] = function (t) {\n    return [[1, t.righttop], [1, t.rightbottom], [0, t.lefttop], [0, 1], [t.topleft, 1]];\n  }, Uo[24] = Uo[146] = function (t) {\n    return [[1, 1], [1, t.righttop], [t.bottomright, 0], [t.bottomleft, 0], [t.topright, 1]];\n  }, Uo[6] = Uo[164] = function (t) {\n    return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [0, t.leftbottom], [0, t.lefttop]];\n  }, Uo[129] = Uo[41] = function (t) {\n    return [[t.topright, 1], [t.bottomleft, 0], [0, 0], [0, t.leftbottom], [t.topleft, 1]];\n  }, Uo[66] = Uo[104] = function (t) {\n    return [[t.bottomright, 0], [t.bottomleft, 0], [0, t.lefttop], [0, 1], [t.topleft, 1]];\n  }, Uo[144] = Uo[26] = function (t) {\n    return [[1, 1], [1, t.righttop], [0, t.leftbottom], [0, t.lefttop], [t.topright, 1]];\n  }, Uo[36] = Uo[134] = function (t) {\n    return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [t.topleft, 1], [t.topright, 1]];\n  }, Uo[9] = Uo[161] = function (t) {\n    return [[1, t.righttop], [1, t.rightbottom], [t.bottomleft, 0], [0, 0], [0, t.leftbottom]];\n  }, Uo[37] = Uo[133] = function (t) {\n    return [[1, t.rightbottom], [1, 0], [0, 0], [0, t.leftbottom], [t.topleft, 1], [t.topright, 1]];\n  }, Uo[148] = Uo[22] = function (t) {\n    return [[1, 1], [1, 0], [t.bottomright, 0], [0, t.leftbottom], [0, t.lefttop], [t.topright, 1]];\n  }, Uo[82] = Uo[88] = function (t) {\n    return [[1, 1], [1, t.righttop], [t.bottomright, 0], [t.bottomleft, 0], [0, t.lefttop], [0, 1]];\n  }, Uo[73] = Uo[97] = function (t) {\n    return [[1, t.righttop], [1, t.rightbottom], [t.bottomleft, 0], [0, 0], [0, 1], [t.topleft, 1]];\n  }, Uo[145] = Uo[25] = function (t) {\n    return [[1, 1], [1, t.righttop], [t.bottomleft, 0], [0, 0], [0, t.leftbottom], [t.topright, 1]];\n  }, Uo[70] = Uo[100] = function (t) {\n    return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [0, t.lefttop], [0, 1], [t.topleft, 1]];\n  }, Uo[34] = function (t) {\n    return [Ao(t), Ro(t)];\n  }, Uo[35] = function (t) {\n    return [[1, t.righttop], [1, t.rightbottom], [t.bottomright, 0], [t.bottomleft, 0], [0, t.leftbottom], [0, t.lefttop], [t.topleft, 1], [t.topright, 1]];\n  }, Uo[136] = function (t) {\n    return [To(t), Oo(t)];\n  }, Uo[153] = function (t) {\n    return [Mo(t), Co(t)];\n  }, Uo[102] = function (t) {\n    return [Po(t), Lo(t)];\n  }, Uo[155] = function (t) {\n    return [[1, 1], [1, t.righttop], [t.bottomleft, 0], [0, 0], [0, t.leftbottom], [t.topright, 1]];\n  }, Uo[103] = function (t) {\n    return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [0, t.lefttop], [0, 1], [t.topleft, 1]];\n  }, Uo[152] = function (t) {\n    return [Mo(t), Oo(t)];\n  }, Uo[156] = function (t) {\n    return [[1, 1], [1, t.righttop], [t.bottomright, 0], [t.bottomleft, 0], [0, t.leftbottom], [0, t.lefttop], [t.topright, 1]];\n  }, Uo[137] = function (t) {\n    return [To(t), Co(t)];\n  }, Uo[139] = function (t) {\n    return [[1, t.righttop], [1, t.rightbottom], [t.bottomleft, 0], [0, 0], [0, t.leftbottom], [t.topleft, 1], [t.topright, 1]];\n  }, Uo[98] = function (t) {\n    return [Ro(t), Lo(t)];\n  }, Uo[99] = function (t) {\n    return [[1, t.righttop], [1, t.rightbottom], [t.bottomright, 0], [t.bottomleft, 0], [0, t.lefttop], [0, 1], [t.topleft, 1]];\n  }, Uo[38] = function (t) {\n    return [Po(t), Ao(t)];\n  }, Uo[39] = function (t) {\n    return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [0, t.leftbottom], [0, t.lefttop], [t.topleft, 1], [t.topright, 1]];\n  };\n  var us = function () {\n      function t(e) {\n        this.id = t.buildId(e), this.coordinates = e, this.innerEdges = [], this.outerEdges = [], this.outerEdgesSorted = !1;\n      }\n      return t.buildId = function (t) {\n        return t.join(\",\");\n      }, t.prototype.removeInnerEdge = function (t) {\n        this.innerEdges = this.innerEdges.filter(function (e) {\n          return e.from.id !== t.from.id;\n        });\n      }, t.prototype.removeOuterEdge = function (t) {\n        this.outerEdges = this.outerEdges.filter(function (e) {\n          return e.to.id !== t.to.id;\n        });\n      }, t.prototype.addOuterEdge = function (t) {\n        this.outerEdges.push(t), this.outerEdgesSorted = !1;\n      }, t.prototype.sortOuterEdges = function () {\n        var t = this;\n        this.outerEdgesSorted || (this.outerEdges.sort(function (e, n) {\n          var r = e.to,\n            i = n.to;\n          if (r.coordinates[0] - t.coordinates[0] >= 0 && i.coordinates[0] - t.coordinates[0] < 0) return 1;\n          if (r.coordinates[0] - t.coordinates[0] < 0 && i.coordinates[0] - t.coordinates[0] >= 0) return -1;\n          if (r.coordinates[0] - t.coordinates[0] == 0 && i.coordinates[0] - t.coordinates[0] == 0) return r.coordinates[1] - t.coordinates[1] >= 0 || i.coordinates[1] - t.coordinates[1] >= 0 ? r.coordinates[1] - i.coordinates[1] : i.coordinates[1] - r.coordinates[1];\n          var o = ss(t.coordinates, r.coordinates, i.coordinates);\n          return o < 0 ? 1 : o > 0 ? -1 : Math.pow(r.coordinates[0] - t.coordinates[0], 2) + Math.pow(r.coordinates[1] - t.coordinates[1], 2) - (Math.pow(i.coordinates[0] - t.coordinates[0], 2) + Math.pow(i.coordinates[1] - t.coordinates[1], 2));\n        }), this.outerEdgesSorted = !0);\n      }, t.prototype.getOuterEdges = function () {\n        return this.sortOuterEdges(), this.outerEdges;\n      }, t.prototype.getOuterEdge = function (t) {\n        return this.sortOuterEdges(), this.outerEdges[t];\n      }, t.prototype.addInnerEdge = function (t) {\n        this.innerEdges.push(t);\n      }, t;\n    }(),\n    ls = function () {\n      function t(t, e) {\n        this.from = t, this.to = e, this.next = void 0, this.label = void 0, this.symetric = void 0, this.ring = void 0, this.from.addOuterEdge(this), this.to.addInnerEdge(this);\n      }\n      return t.prototype.getSymetric = function () {\n        return this.symetric || (this.symetric = new t(this.to, this.from), this.symetric.symetric = this), this.symetric;\n      }, t.prototype.deleteEdge = function () {\n        this.from.removeOuterEdge(this), this.to.removeInnerEdge(this);\n      }, t.prototype.isEqual = function (t) {\n        return this.from.id === t.from.id && this.to.id === t.to.id;\n      }, t.prototype.toString = function () {\n        return \"Edge { \" + this.from.id + \" -> \" + this.to.id + \" }\";\n      }, t.prototype.toLineString = function () {\n        return h([this.from.coordinates, this.to.coordinates]);\n      }, t.prototype.compareTo = function (t) {\n        return ss(t.from.coordinates, t.to.coordinates, this.to.coordinates);\n      }, t;\n    }(),\n    cs = function () {\n      function t() {\n        this.edges = [], this.polygon = void 0, this.envelope = void 0;\n      }\n      return t.prototype.push = function (t) {\n        this.edges.push(t), this.polygon = this.envelope = void 0;\n      }, t.prototype.get = function (t) {\n        return this.edges[t];\n      }, Object.defineProperty(t.prototype, \"length\", {\n        get: function get() {\n          return this.edges.length;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), t.prototype.forEach = function (t) {\n        this.edges.forEach(t);\n      }, t.prototype.map = function (t) {\n        return this.edges.map(t);\n      }, t.prototype.some = function (t) {\n        return this.edges.some(t);\n      }, t.prototype.isValid = function () {\n        return !0;\n      }, t.prototype.isHole = function () {\n        var t = this,\n          e = this.edges.reduce(function (e, n, r) {\n            return n.from.coordinates[1] > t.edges[e].from.coordinates[1] && (e = r), e;\n          }, 0),\n          n = (0 === e ? this.length : e) - 1,\n          r = (e + 1) % this.length,\n          i = ss(this.edges[n].from.coordinates, this.edges[e].from.coordinates, this.edges[r].from.coordinates);\n        return 0 === i ? this.edges[n].from.coordinates[0] > this.edges[r].from.coordinates[0] : i > 0;\n      }, t.prototype.toMultiPoint = function () {\n        return d(this.edges.map(function (t) {\n          return t.from.coordinates;\n        }));\n      }, t.prototype.toPolygon = function () {\n        if (this.polygon) return this.polygon;\n        var t = this.edges.map(function (t) {\n          return t.from.coordinates;\n        });\n        return t.push(this.edges[0].from.coordinates), this.polygon = l([t]);\n      }, t.prototype.getEnvelope = function () {\n        return this.envelope ? this.envelope : this.envelope = dn(this.toPolygon());\n      }, t.findEdgeRingContaining = function (t, e) {\n        var n,\n          r,\n          i = t.getEnvelope();\n        return e.forEach(function (e) {\n          var o,\n            s,\n            u,\n            l,\n            c,\n            h,\n            p = e.getEnvelope();\n          if ((r && (n = r.getEnvelope()), s = i, u = (o = p).geometry.coordinates[0].map(function (t) {\n            return t[0];\n          }), l = o.geometry.coordinates[0].map(function (t) {\n            return t[1];\n          }), c = s.geometry.coordinates[0].map(function (t) {\n            return t[0];\n          }), h = s.geometry.coordinates[0].map(function (t) {\n            return t[1];\n          }), Math.max.apply(null, u) !== Math.max.apply(null, c) || Math.max.apply(null, l) !== Math.max.apply(null, h) || Math.min.apply(null, u) !== Math.min.apply(null, c) || Math.min.apply(null, l) !== Math.min.apply(null, h)) && as(p, i)) {\n            for (var f = t.map(function (t) {\n                return t.from.coordinates;\n              }), g = void 0, d = function d(t) {\n                e.some(function (e) {\n                  return n = t, r = e.from.coordinates, n[0] === r[0] && n[1] === r[1];\n                  var n, r;\n                }) || (g = t);\n              }, y = 0, v = f; y < v.length; y++) {\n              d(v[y]);\n            }\n            g && e.inside(a(g)) && (r && !as(n, p) || (r = e));\n          }\n        }), r;\n      }, t.prototype.inside = function (t) {\n        return ye(t, this.toPolygon());\n      }, t;\n    }();\n  var hs = function () {\n    function t() {\n      this.edges = [], this.nodes = {};\n    }\n    return t.fromGeoJson = function (e) {\n      !function (t) {\n        if (!t) throw new Error(\"No geojson passed\");\n        if (\"FeatureCollection\" !== t.type && \"GeometryCollection\" !== t.type && \"MultiLineString\" !== t.type && \"LineString\" !== t.type && \"Feature\" !== t.type) throw new Error(\"Invalid input type '\" + t.type + \"'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature\");\n      }(e);\n      var n = new t();\n      return z(e, function (t) {\n        et(t, \"LineString\", \"Graph::fromGeoJson\"), T(t, function (t, e) {\n          if (t) {\n            var r = n.getNode(t),\n              i = n.getNode(e);\n            n.addEdge(r, i);\n          }\n          return e;\n        });\n      }), n;\n    }, t.prototype.getNode = function (t) {\n      var e = us.buildId(t),\n        n = this.nodes[e];\n      return n || (n = this.nodes[e] = new us(t)), n;\n    }, t.prototype.addEdge = function (t, e) {\n      var n = new ls(t, e),\n        r = n.getSymetric();\n      this.edges.push(n), this.edges.push(r);\n    }, t.prototype.deleteDangles = function () {\n      var t = this;\n      Object.keys(this.nodes).map(function (e) {\n        return t.nodes[e];\n      }).forEach(function (e) {\n        return t._removeIfDangle(e);\n      });\n    }, t.prototype._removeIfDangle = function (t) {\n      var e = this;\n      if (t.innerEdges.length <= 1) {\n        var n = t.getOuterEdges().map(function (t) {\n          return t.to;\n        });\n        this.removeNode(t), n.forEach(function (t) {\n          return e._removeIfDangle(t);\n        });\n      }\n    }, t.prototype.deleteCutEdges = function () {\n      var t = this;\n      this._computeNextCWEdges(), this._findLabeledEdgeRings(), this.edges.forEach(function (e) {\n        e.label === e.symetric.label && (t.removeEdge(e.symetric), t.removeEdge(e));\n      });\n    }, t.prototype._computeNextCWEdges = function (t) {\n      var e = this;\n      void 0 === t ? Object.keys(this.nodes).forEach(function (t) {\n        return e._computeNextCWEdges(e.nodes[t]);\n      }) : t.getOuterEdges().forEach(function (e, n) {\n        t.getOuterEdge((0 === n ? t.getOuterEdges().length : n) - 1).symetric.next = e;\n      });\n    }, t.prototype._computeNextCCWEdges = function (t, e) {\n      for (var n, r, i = t.getOuterEdges(), o = i.length - 1; o >= 0; --o) {\n        var s = i[o],\n          a = s.symetric,\n          u = void 0,\n          l = void 0;\n        s.label === e && (u = s), a.label === e && (l = a), u && l && (l && (r = l), u && (r && (r.next = u, r = void 0), n || (n = u)));\n      }\n      r && (r.next = n);\n    }, t.prototype._findLabeledEdgeRings = function () {\n      var t = [],\n        e = 0;\n      return this.edges.forEach(function (n) {\n        if (!(n.label >= 0)) {\n          t.push(n);\n          var r = n;\n          do {\n            r.label = e, r = r.next;\n          } while (!n.isEqual(r));\n          e++;\n        }\n      }), t;\n    }, t.prototype.getEdgeRings = function () {\n      var t = this;\n      this._computeNextCWEdges(), this.edges.forEach(function (t) {\n        t.label = void 0;\n      }), this._findLabeledEdgeRings().forEach(function (e) {\n        t._findIntersectionNodes(e).forEach(function (n) {\n          t._computeNextCCWEdges(n, e.label);\n        });\n      });\n      var e = [];\n      return this.edges.forEach(function (n) {\n        n.ring || e.push(t._findEdgeRing(n));\n      }), e;\n    }, t.prototype._findIntersectionNodes = function (t) {\n      var e = [],\n        n = t,\n        r = function r() {\n          var r = 0;\n          n.from.getOuterEdges().forEach(function (e) {\n            e.label === t.label && ++r;\n          }), r > 1 && e.push(n.from), n = n.next;\n        };\n      do {\n        r();\n      } while (!t.isEqual(n));\n      return e;\n    }, t.prototype._findEdgeRing = function (t) {\n      var e = t,\n        n = new cs();\n      do {\n        n.push(e), e.ring = n, e = e.next;\n      } while (!t.isEqual(e));\n      return n;\n    }, t.prototype.removeNode = function (t) {\n      var e = this;\n      t.getOuterEdges().forEach(function (t) {\n        return e.removeEdge(t);\n      }), t.innerEdges.forEach(function (t) {\n        return e.removeEdge(t);\n      }), delete this.nodes[t.id];\n    }, t.prototype.removeEdge = function (t) {\n      this.edges = this.edges.filter(function (e) {\n        return !e.isEqual(t);\n      }), t.deleteEdge();\n    }, t;\n  }();\n  function ps(t, e) {\n    var n = !0;\n    return z(t, function (t) {\n      z(e, function (e) {\n        if (!1 === n) return !1;\n        n = function (t, e) {\n          switch (t.type) {\n            case \"Point\":\n              switch (e.type) {\n                case \"Point\":\n                  return n = t.coordinates, r = e.coordinates, !(n[0] === r[0] && n[1] === r[1]);\n                case \"LineString\":\n                  return !fs(e, t);\n                case \"Polygon\":\n                  return !ye(t, e);\n              }\n              break;\n            case \"LineString\":\n              switch (e.type) {\n                case \"Point\":\n                  return !fs(t, e);\n                case \"LineString\":\n                  return !function (t, e) {\n                    if (Or(t, e).features.length > 0) return !0;\n                    return !1;\n                  }(t, e);\n                case \"Polygon\":\n                  return !gs(e, t);\n              }\n              break;\n            case \"Polygon\":\n              switch (e.type) {\n                case \"Point\":\n                  return !ye(e, t);\n                case \"LineString\":\n                  return !gs(t, e);\n                case \"Polygon\":\n                  return !function (t, e) {\n                    for (var n = 0, r = t.coordinates[0]; n < r.length; n++) {\n                      if (ye(r[n], e)) return !0;\n                    }\n                    for (var i = 0, o = e.coordinates[0]; i < o.length; i++) {\n                      if (ye(o[i], t)) return !0;\n                    }\n                    if (Or(Ii(t), Ii(e)).features.length > 0) return !0;\n                    return !1;\n                  }(e, t);\n              }\n          }\n          var n, r;\n          return !1;\n        }(t.geometry, e.geometry);\n      });\n    }), n;\n  }\n  function fs(t, e) {\n    for (var n = 0; n < t.coordinates.length - 1; n++) if (ds(t.coordinates[n], t.coordinates[n + 1], e.coordinates)) return !0;\n    return !1;\n  }\n  function gs(t, e) {\n    for (var n = 0, r = e.coordinates; n < r.length; n++) {\n      if (ye(r[n], t)) return !0;\n    }\n    return Or(e, Ii(t)).features.length > 0;\n  }\n  function ds(t, e, n) {\n    var r = n[0] - t[0],\n      i = n[1] - t[1],\n      o = e[0] - t[0],\n      s = e[1] - t[1];\n    return 0 == r * s - i * o && (Math.abs(o) >= Math.abs(s) ? o > 0 ? t[0] <= n[0] && n[0] <= e[0] : e[0] <= n[0] && n[0] <= t[0] : s > 0 ? t[1] <= n[1] && n[1] <= e[1] : e[1] <= n[1] && n[1] <= t[1]);\n  }\n  function ys(t, e) {\n    return !(t[0] > e[0]) && !(t[2] < e[2]) && !(t[1] > e[1]) && !(t[3] < e[3]);\n  }\n  function vs(t, e) {\n    return t[0] === e[0] && t[1] === e[1];\n  }\n  function _s(t, e) {\n    return [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2];\n  }\n  function ms(t, e) {\n    for (var n = !1, r = !1, i = t.coordinates.length, o = 0; o < i && !n && !r;) {\n      for (var s = 0; s < e.coordinates.length - 1; s++) {\n        var a = !0;\n        0 !== s && s !== e.coordinates.length - 2 || (a = !1), bs(e.coordinates[s], e.coordinates[s + 1], t.coordinates[o], a) ? n = !0 : r = !0;\n      }\n      o++;\n    }\n    return n && r;\n  }\n  function xs(t, e) {\n    return Or(t, Ni(e)).features.length > 0;\n  }\n  function Es(t, e) {\n    for (var n = !1, r = !1, i = t.coordinates.length, o = 0; o < i && (!n || !r); o++) ye(a(t.coordinates[o]), e) ? n = !0 : r = !0;\n    return r && n;\n  }\n  function bs(t, e, n, r) {\n    var i = n[0] - t[0],\n      o = n[1] - t[1],\n      s = e[0] - t[0],\n      a = e[1] - t[1];\n    return 0 == i * a - o * s && (r ? Math.abs(s) >= Math.abs(a) ? s > 0 ? t[0] <= n[0] && n[0] <= e[0] : e[0] <= n[0] && n[0] <= t[0] : a > 0 ? t[1] <= n[1] && n[1] <= e[1] : e[1] <= n[1] && n[1] <= t[1] : Math.abs(s) >= Math.abs(a) ? s > 0 ? t[0] < n[0] && n[0] < e[0] : e[0] < n[0] && n[0] < t[0] : a > 0 ? t[1] < n[1] && n[1] < e[1] : e[1] < n[1] && n[1] < t[1]);\n  }\n  var ws = function ws(t) {\n    this.precision = t && t.precision ? t.precision : 17, this.direction = !(!t || !t.direction) && t.direction, this.pseudoNode = !(!t || !t.pseudoNode) && t.pseudoNode, this.objectComparator = t && t.objectComparator ? t.objectComparator : Ss;\n  };\n  function Is(t) {\n    return t.coordinates.map(function (e) {\n      return {\n        type: t.type.replace(\"Multi\", \"\"),\n        coordinates: e\n      };\n    });\n  }\n  function Ns(t, e) {\n    return t.hasOwnProperty(\"coordinates\") ? t.coordinates.length === e.coordinates.length : t.length === e.length;\n  }\n  function Ss(t, e) {\n    return Fi(t, e, {\n      strict: !0\n    });\n  }\n  ws.prototype.compare = function (t, e) {\n    if (t.type !== e.type || !Ns(t, e)) return !1;\n    switch (t.type) {\n      case \"Point\":\n        return this.compareCoord(t.coordinates, e.coordinates);\n      case \"LineString\":\n        return this.compareLine(t.coordinates, e.coordinates, 0, !1);\n      case \"Polygon\":\n        return this.comparePolygon(t, e);\n      case \"Feature\":\n        return this.compareFeature(t, e);\n      default:\n        if (0 === t.type.indexOf(\"Multi\")) {\n          var n = this,\n            r = Is(t),\n            i = Is(e);\n          return r.every(function (t) {\n            return this.some(function (e) {\n              return n.compare(t, e);\n            });\n          }, i);\n        }\n    }\n    return !1;\n  }, ws.prototype.compareCoord = function (t, e) {\n    if (t.length !== e.length) return !1;\n    for (var n = 0; n < t.length; n++) if (t[n].toFixed(this.precision) !== e[n].toFixed(this.precision)) return !1;\n    return !0;\n  }, ws.prototype.compareLine = function (t, e, n, r) {\n    if (!Ns(t, e)) return !1;\n    var i = this.pseudoNode ? t : this.removePseudo(t),\n      o = this.pseudoNode ? e : this.removePseudo(e);\n    if (!r || this.compareCoord(i[0], o[0]) || (o = this.fixStartIndex(o, i))) {\n      var s = this.compareCoord(i[n], o[n]);\n      return this.direction || s ? this.comparePath(i, o) : !!this.compareCoord(i[n], o[o.length - (1 + n)]) && this.comparePath(i.slice().reverse(), o);\n    }\n  }, ws.prototype.fixStartIndex = function (t, e) {\n    for (var n, r = -1, i = 0; i < t.length; i++) if (this.compareCoord(t[i], e[0])) {\n      r = i;\n      break;\n    }\n    return r >= 0 && (n = [].concat(t.slice(r, t.length), t.slice(1, r + 1))), n;\n  }, ws.prototype.comparePath = function (t, e) {\n    var n = this;\n    return t.every(function (t, e) {\n      return n.compareCoord(t, this[e]);\n    }, e);\n  }, ws.prototype.comparePolygon = function (t, e) {\n    if (this.compareLine(t.coordinates[0], e.coordinates[0], 1, !0)) {\n      var n = t.coordinates.slice(1, t.coordinates.length),\n        r = e.coordinates.slice(1, e.coordinates.length),\n        i = this;\n      return n.every(function (t) {\n        return this.some(function (e) {\n          return i.compareLine(t, e, 1, !0);\n        });\n      }, r);\n    }\n    return !1;\n  }, ws.prototype.compareFeature = function (t, e) {\n    return !(t.id !== e.id || !this.objectComparator(t.properties, e.properties) || !this.compareBBox(t, e)) && this.compare(t.geometry, e.geometry);\n  }, ws.prototype.compareBBox = function (t, e) {\n    return !!(!t.bbox && !e.bbox || t.bbox && e.bbox && this.compareCoord(t.bbox, e.bbox));\n  }, ws.prototype.removePseudo = function (t) {\n    return t;\n  };\n  var Cs = ws;\n  function Ps(t, e) {\n    var n = !1;\n    return z(t, function (t) {\n      z(e, function (e) {\n        if (!0 === n) return !0;\n        n = !ps(t.geometry, e.geometry);\n      });\n    }), n;\n  }\n  var Ms = Bt(function (t) {\n      function e(t, e, n, r) {\n        this.dataset = [], this.epsilon = 1, this.minPts = 2, this.distance = this._euclideanDistance, this.clusters = [], this.noise = [], this._visited = [], this._assigned = [], this._datasetLength = 0, this._init(t, e, n, r);\n      }\n      e.prototype.run = function (t, e, n, r) {\n        this._init(t, e, n, r);\n        for (var i = 0; i < this._datasetLength; i++) if (1 !== this._visited[i]) {\n          this._visited[i] = 1;\n          var o = this._regionQuery(i);\n          if (o.length < this.minPts) this.noise.push(i);else {\n            var s = this.clusters.length;\n            this.clusters.push([]), this._addToCluster(i, s), this._expandCluster(s, o);\n          }\n        }\n        return this.clusters;\n      }, e.prototype._init = function (t, e, n, r) {\n        if (t) {\n          if (!(t instanceof Array)) throw Error(\"Dataset must be of type array, \" + typeof t + \" given\");\n          this.dataset = t, this.clusters = [], this.noise = [], this._datasetLength = t.length, this._visited = new Array(this._datasetLength), this._assigned = new Array(this._datasetLength);\n        }\n        e && (this.epsilon = e), n && (this.minPts = n), r && (this.distance = r);\n      }, e.prototype._expandCluster = function (t, e) {\n        for (var n = 0; n < e.length; n++) {\n          var r = e[n];\n          if (1 !== this._visited[r]) {\n            this._visited[r] = 1;\n            var i = this._regionQuery(r);\n            i.length >= this.minPts && (e = this._mergeArrays(e, i));\n          }\n          1 !== this._assigned[r] && this._addToCluster(r, t);\n        }\n      }, e.prototype._addToCluster = function (t, e) {\n        this.clusters[e].push(t), this._assigned[t] = 1;\n      }, e.prototype._regionQuery = function (t) {\n        for (var e = [], n = 0; n < this._datasetLength; n++) {\n          this.distance(this.dataset[t], this.dataset[n]) < this.epsilon && e.push(n);\n        }\n        return e;\n      }, e.prototype._mergeArrays = function (t, e) {\n        for (var n = e.length, r = 0; r < n; r++) {\n          var i = e[r];\n          t.indexOf(i) < 0 && t.push(i);\n        }\n        return t;\n      }, e.prototype._euclideanDistance = function (t, e) {\n        for (var n = 0, r = Math.min(t.length, e.length); r--;) n += (t[r] - e[r]) * (t[r] - e[r]);\n        return Math.sqrt(n);\n      }, t.exports && (t.exports = e);\n    }),\n    Ls = Bt(function (t) {\n      function e(t, e, n) {\n        this.k = 3, this.dataset = [], this.assignments = [], this.centroids = [], this.init(t, e, n);\n      }\n      e.prototype.init = function (t, e, n) {\n        this.assignments = [], this.centroids = [], void 0 !== t && (this.dataset = t), void 0 !== e && (this.k = e), void 0 !== n && (this.distance = n);\n      }, e.prototype.run = function (t, e) {\n        this.init(t, e);\n        for (var n = this.dataset.length, r = 0; r < this.k; r++) this.centroids[r] = this.randomCentroid();\n        for (var i = !0; i;) {\n          i = this.assign();\n          for (var o = 0; o < this.k; o++) {\n            for (var s = new Array(c), a = 0, u = 0; u < c; u++) s[u] = 0;\n            for (var l = 0; l < n; l++) {\n              var c = this.dataset[l].length;\n              if (o === this.assignments[l]) {\n                for (u = 0; u < c; u++) s[u] += this.dataset[l][u];\n                a++;\n              }\n            }\n            if (a > 0) {\n              for (u = 0; u < c; u++) s[u] /= a;\n              this.centroids[o] = s;\n            } else this.centroids[o] = this.randomCentroid(), i = !0;\n          }\n        }\n        return this.getClusters();\n      }, e.prototype.randomCentroid = function () {\n        var t,\n          e,\n          n = this.dataset.length - 1;\n        do {\n          e = Math.round(Math.random() * n), t = this.dataset[e];\n        } while (this.centroids.indexOf(t) >= 0);\n        return t;\n      }, e.prototype.assign = function () {\n        for (var t, e = !1, n = this.dataset.length, r = 0; r < n; r++) (t = this.argmin(this.dataset[r], this.centroids, this.distance)) != this.assignments[r] && (this.assignments[r] = t, e = !0);\n        return e;\n      }, e.prototype.getClusters = function () {\n        for (var t, e = new Array(this.k), n = 0; n < this.assignments.length; n++) void 0 === e[t = this.assignments[n]] && (e[t] = []), e[t].push(n);\n        return e;\n      }, e.prototype.argmin = function (t, e, n) {\n        for (var r, i = Number.MAX_VALUE, o = 0, s = e.length, a = 0; a < s; a++) (r = n(t, e[a])) < i && (i = r, o = a);\n        return o;\n      }, e.prototype.distance = function (t, e) {\n        for (var n = 0, r = Math.min(t.length, e.length); r--;) {\n          var i = t[r] - e[r];\n          n += i * i;\n        }\n        return Math.sqrt(n);\n      }, t.exports && (t.exports = e);\n    }),\n    Os = Bt(function (t) {\n      function e(t, e, n) {\n        this._queue = [], this._priorities = [], this._sorting = \"desc\", this._init(t, e, n);\n      }\n      e.prototype.insert = function (t, e) {\n        for (var n = this._queue.length, r = n; r--;) {\n          var i = this._priorities[r];\n          \"desc\" === this._sorting ? e > i && (n = r) : e < i && (n = r);\n        }\n        this._insertAt(t, e, n);\n      }, e.prototype.remove = function (t) {\n        for (var e = this._queue.length; e--;) {\n          if (t === this._queue[e]) {\n            this._queue.splice(e, 1), this._priorities.splice(e, 1);\n            break;\n          }\n        }\n      }, e.prototype.forEach = function (t) {\n        this._queue.forEach(t);\n      }, e.prototype.getElements = function () {\n        return this._queue;\n      }, e.prototype.getElementPriority = function (t) {\n        return this._priorities[t];\n      }, e.prototype.getPriorities = function () {\n        return this._priorities;\n      }, e.prototype.getElementsWithPriorities = function () {\n        for (var t = [], e = 0, n = this._queue.length; e < n; e++) t.push([this._queue[e], this._priorities[e]]);\n        return t;\n      }, e.prototype._init = function (t, e, n) {\n        if (t && e) {\n          if (this._queue = [], this._priorities = [], t.length !== e.length) throw new Error(\"Arrays must have the same length\");\n          for (var r = 0; r < t.length; r++) this.insert(t[r], e[r]);\n        }\n        n && (this._sorting = n);\n      }, e.prototype._insertAt = function (t, e, n) {\n        this._queue.length === n ? (this._queue.push(t), this._priorities.push(e)) : (this._queue.splice(n, 0, t), this._priorities.splice(n, 0, e));\n      }, t.exports && (t.exports = e);\n    }),\n    Rs = Bt(function (t) {\n      if (t.exports) var e = Os;\n      function n(t, e, n, r) {\n        this.epsilon = 1, this.minPts = 1, this.distance = this._euclideanDistance, this._reachability = [], this._processed = [], this._coreDistance = 0, this._orderedList = [], this._init(t, e, n, r);\n      }\n      n.prototype.run = function (t, n, r, i) {\n        this._init(t, n, r, i);\n        for (var o = 0, s = this.dataset.length; o < s; o++) if (1 !== this._processed[o]) {\n          this._processed[o] = 1, this.clusters.push([o]);\n          var a = this.clusters.length - 1;\n          this._orderedList.push(o);\n          var u = new e(null, null, \"asc\"),\n            l = this._regionQuery(o);\n          void 0 !== this._distanceToCore(o) && (this._updateQueue(o, l, u), this._expandCluster(a, u));\n        }\n        return this.clusters;\n      }, n.prototype.getReachabilityPlot = function () {\n        for (var t = [], e = 0, n = this._orderedList.length; e < n; e++) {\n          var r = this._orderedList[e],\n            i = this._reachability[r];\n          t.push([r, i]);\n        }\n        return t;\n      }, n.prototype._init = function (t, e, n, r) {\n        if (t) {\n          if (!(t instanceof Array)) throw Error(\"Dataset must be of type array, \" + typeof t + \" given\");\n          this.dataset = t, this.clusters = [], this._reachability = new Array(this.dataset.length), this._processed = new Array(this.dataset.length), this._coreDistance = 0, this._orderedList = [];\n        }\n        e && (this.epsilon = e), n && (this.minPts = n), r && (this.distance = r);\n      }, n.prototype._updateQueue = function (t, e, n) {\n        var r = this;\n        this._coreDistance = this._distanceToCore(t), e.forEach(function (e) {\n          if (void 0 === r._processed[e]) {\n            var i = r.distance(r.dataset[t], r.dataset[e]),\n              o = Math.max(r._coreDistance, i);\n            void 0 === r._reachability[e] ? (r._reachability[e] = o, n.insert(e, o)) : o < r._reachability[e] && (r._reachability[e] = o, n.remove(e), n.insert(e, o));\n          }\n        });\n      }, n.prototype._expandCluster = function (t, e) {\n        for (var n = e.getElements(), r = 0, i = n.length; r < i; r++) {\n          var o = n[r];\n          if (void 0 === this._processed[o]) {\n            var s = this._regionQuery(o);\n            this._processed[o] = 1, this.clusters[t].push(o), this._orderedList.push(o), void 0 !== this._distanceToCore(o) && (this._updateQueue(o, s, e), this._expandCluster(t, e));\n          }\n        }\n      }, n.prototype._distanceToCore = function (t) {\n        for (var e = this.epsilon, n = 0; n < e; n++) {\n          if (this._regionQuery(t, n).length >= this.minPts) return n;\n        }\n      }, n.prototype._regionQuery = function (t, e) {\n        e = e || this.epsilon;\n        for (var n = [], r = 0, i = this.dataset.length; r < i; r++) this.distance(this.dataset[t], this.dataset[r]) < e && n.push(r);\n        return n;\n      }, n.prototype._euclideanDistance = function (t, e) {\n        for (var n = 0, r = Math.min(t.length, e.length); r--;) n += (t[r] - e[r]) * (t[r] - e[r]);\n        return Math.sqrt(n);\n      }, t.exports && (t.exports = n);\n    }),\n    Ts = Bt(function (t) {\n      t.exports && (t.exports = {\n        DBSCAN: Ms,\n        KMEANS: Ls,\n        OPTICS: Rs,\n        PriorityQueue: Os\n      });\n    });\n  var As = function As(t, e, n) {\n      for (var r = t.length, i = 0, o = 0; o < r; o++) {\n        var s = (t[o] || 0) - (e[o] || 0);\n        i += s * s;\n      }\n      return n ? Math.sqrt(i) : i;\n    },\n    Ds = As,\n    Fs = function Fs(t, e, n) {\n      var r = Math.abs(t - e);\n      return n ? r : r * r;\n    },\n    ks = As,\n    Gs = function Gs(t, e) {\n      for (var n = {}, r = [], i = e << 2, o = t.length, s = t[0].length > 0; r.length < e && i-- > 0;) {\n        var a = t[Math.floor(Math.random() * o)],\n          u = s ? a.join(\"_\") : \"\" + a;\n        n[u] || (n[u] = !0, r.push(a));\n      }\n      if (r.length < e) throw new Error(\"Error initializating clusters\");\n      return r;\n    },\n    qs = function qs(t, e) {\n      var n = t[0].length ? Ds : Fs,\n        r = [],\n        i = t.length,\n        o = t[0].length > 0,\n        s = t[Math.floor(Math.random() * i)];\n      o && s.join(\"_\");\n      for (r.push(s); r.length < e;) {\n        for (var a = [], u = r.length, l = 0, c = [], h = 0; h < i; h++) {\n          for (var p = 1 / 0, f = 0; f < u; f++) {\n            var g = n(t[h], r[f]);\n            g <= p && (p = g);\n          }\n          a[h] = p;\n        }\n        for (var d = 0; d < i; d++) l += a[d];\n        for (var y = 0; y < i; y++) c[y] = {\n          i: y,\n          v: t[y],\n          pr: a[y] / l,\n          cs: 0\n        };\n        c.sort(function (t, e) {\n          return t.pr - e.pr;\n        }), c[0].cs = c[0].pr;\n        for (var v = 1; v < i; v++) c[v].cs = c[v - 1].cs + c[v].pr;\n        for (var _ = Math.random(), m = 0; m < i - 1 && c[m++].cs < _;);\n        r.push(c[m - 1].v);\n      }\n      return r;\n    };\n  function Bs(t, e, n) {\n    n = n || [];\n    for (var r = 0; r < t; r++) n[r] = e;\n    return n;\n  }\n  var zs = function zs(t, e, n, r) {\n    var i = [],\n      o = [],\n      s = [],\n      a = [],\n      u = !1,\n      l = r || 1e4,\n      c = t.length,\n      h = t[0].length,\n      p = h > 0,\n      f = [];\n    if (n) i = \"kmrand\" == n ? Gs(t, e) : \"kmpp\" == n ? qs(t, e) : n;else for (var g = {}; i.length < e;) {\n      var d = Math.floor(Math.random() * c);\n      g[d] || (g[d] = !0, i.push(t[d]));\n    }\n    do {\n      Bs(e, 0, f);\n      for (var y = 0; y < c; y++) {\n        for (var v = 1 / 0, _ = 0, m = 0; m < e; m++) {\n          (a = p ? ks(t[y], i[m]) : Math.abs(t[y] - i[m])) <= v && (v = a, _ = m);\n        }\n        s[y] = _, f[_]++;\n      }\n      for (var x = [], E = (o = [], 0); E < e; E++) x[E] = p ? Bs(h, 0, x[E]) : 0, o[E] = i[E];\n      if (p) {\n        for (var b = 0; b < e; b++) i[b] = [];\n        for (var w = 0; w < c; w++) for (var I = x[s[w]], N = t[w], S = 0; S < h; S++) I[S] += N[S];\n        u = !0;\n        for (var C = 0; C < e; C++) {\n          for (var P = i[C], M = x[C], L = o[C], O = f[C], R = 0; R < h; R++) P[R] = M[R] / O || 0;\n          if (u) for (var T = 0; T < h; T++) if (L[T] != P[T]) {\n            u = !1;\n            break;\n          }\n        }\n      } else {\n        for (var A = 0; A < c; A++) {\n          x[s[A]] += t[A];\n        }\n        for (var D = 0; D < e; D++) i[D] = x[D] / f[D] || 0;\n        u = !0;\n        for (var F = 0; F < e; F++) if (o[F] != i[F]) {\n          u = !1;\n          break;\n        }\n      }\n      u = u || --l <= 0;\n    } while (!u);\n    return {\n      it: 1e4 - l,\n      k: e,\n      idxs: s,\n      centroids: i\n    };\n  };\n  function js(t, e) {\n    return b(Bi(t[0], t[1])) === b(Bi(e[0], e[1]));\n  }\n  function Us(t, e) {\n    if (t.geometry && t.geometry.type) return t.geometry.type;\n    if (t.type) return t.type;\n    throw new Error(\"Invalid GeoJSON object for \" + e);\n  }\n  function Vs(t) {\n    for (var e = t, n = []; e.parent;) n.unshift(e), e = e.parent;\n    return n;\n  }\n  var Xs = {\n    search: function search(t, e, n, r) {\n      t.cleanDirty();\n      var i = (r = r || {}).heuristic || Xs.heuristics.manhattan,\n        o = r.closest || !1,\n        s = new Ws(function (t) {\n          return t.f;\n        }),\n        a = e;\n      for (e.h = i(e, n), s.push(e); s.size() > 0;) {\n        var u = s.pop();\n        if (u === n) return Vs(u);\n        u.closed = !0;\n        for (var l = t.neighbors(u), c = 0, h = l.length; c < h; ++c) {\n          var p = l[c];\n          if (!p.closed && !p.isWall()) {\n            var f = u.g + p.getCost(u),\n              g = p.visited;\n            (!g || f < p.g) && (p.visited = !0, p.parent = u, p.h = p.h || i(p, n), p.g = f, p.f = p.g + p.h, t.markDirty(p), o && (p.h < a.h || p.h === a.h && p.g < a.g) && (a = p), g ? s.rescoreElement(p) : s.push(p));\n          }\n        }\n      }\n      return o ? Vs(a) : [];\n    },\n    heuristics: {\n      manhattan: function manhattan(t, e) {\n        return Math.abs(e.x - t.x) + Math.abs(e.y - t.y);\n      },\n      diagonal: function diagonal(t, e) {\n        var n = Math.sqrt(2),\n          r = Math.abs(e.x - t.x),\n          i = Math.abs(e.y - t.y);\n        return 1 * (r + i) + (n - 2) * Math.min(r, i);\n      }\n    },\n    cleanNode: function cleanNode(t) {\n      t.f = 0, t.g = 0, t.h = 0, t.visited = !1, t.closed = !1, t.parent = null;\n    }\n  };\n  function Ys(t, e) {\n    e = e || {}, this.nodes = [], this.diagonal = !!e.diagonal, this.grid = [];\n    for (var n = 0; n < t.length; n++) {\n      this.grid[n] = [];\n      for (var r = 0, i = t[n]; r < i.length; r++) {\n        var o = new Hs(n, r, i[r]);\n        this.grid[n][r] = o, this.nodes.push(o);\n      }\n    }\n    this.init();\n  }\n  function Hs(t, e, n) {\n    this.x = t, this.y = e, this.weight = n;\n  }\n  function Ws(t) {\n    this.content = [], this.scoreFunction = t;\n  }\n  function Js(t, e) {\n    for (var n = 0; n < e.features.length; n++) if (ye(t, e.features[n])) return !0;\n    return !1;\n  }\n  function Zs(t) {\n    return function () {\n      return t;\n    };\n  }\n  function Ks(t) {\n    return t[0];\n  }\n  function Qs(t) {\n    return t[1];\n  }\n  function $s() {\n    this._ = null;\n  }\n  function ta(t) {\n    t.U = t.C = t.L = t.R = t.P = t.N = null;\n  }\n  function ea(t, e) {\n    var n = e,\n      r = e.R,\n      i = n.U;\n    i ? i.L === n ? i.L = r : i.R = r : t._ = r, r.U = i, n.U = r, n.R = r.L, n.R && (n.R.U = n), r.L = n;\n  }\n  function na(t, e) {\n    var n = e,\n      r = e.L,\n      i = n.U;\n    i ? i.L === n ? i.L = r : i.R = r : t._ = r, r.U = i, n.U = r, n.L = r.R, n.L && (n.L.U = n), r.R = n;\n  }\n  function ra(t) {\n    for (; t.L;) t = t.L;\n    return t;\n  }\n  function ia(t, e, n, r) {\n    var i = [null, null],\n      o = Pa.push(i) - 1;\n    return i.left = t, i.right = e, n && sa(i, t, e, n), r && sa(i, e, t, r), Sa[t.index].halfedges.push(o), Sa[e.index].halfedges.push(o), i;\n  }\n  function oa(t, e, n) {\n    var r = [e, n];\n    return r.left = t, r;\n  }\n  function sa(t, e, n, r) {\n    t[0] || t[1] ? t.left === n ? t[1] = r : t[0] = r : (t[0] = r, t.left = e, t.right = n);\n  }\n  function aa(t, e, n, r, i) {\n    var o,\n      s = t[0],\n      a = t[1],\n      u = s[0],\n      l = s[1],\n      c = 0,\n      h = 1,\n      p = a[0] - u,\n      f = a[1] - l;\n    if (o = e - u, p || !(o > 0)) {\n      if (o /= p, p < 0) {\n        if (o < c) return;\n        o < h && (h = o);\n      } else if (p > 0) {\n        if (o > h) return;\n        o > c && (c = o);\n      }\n      if (o = r - u, p || !(o < 0)) {\n        if (o /= p, p < 0) {\n          if (o > h) return;\n          o > c && (c = o);\n        } else if (p > 0) {\n          if (o < c) return;\n          o < h && (h = o);\n        }\n        if (o = n - l, f || !(o > 0)) {\n          if (o /= f, f < 0) {\n            if (o < c) return;\n            o < h && (h = o);\n          } else if (f > 0) {\n            if (o > h) return;\n            o > c && (c = o);\n          }\n          if (o = i - l, f || !(o < 0)) {\n            if (o /= f, f < 0) {\n              if (o > h) return;\n              o > c && (c = o);\n            } else if (f > 0) {\n              if (o < c) return;\n              o < h && (h = o);\n            }\n            return !(c > 0 || h < 1) || (c > 0 && (t[0] = [u + c * p, l + c * f]), h < 1 && (t[1] = [u + h * p, l + h * f]), !0);\n          }\n        }\n      }\n    }\n  }\n  function ua(t, e, n, r, i) {\n    var o = t[1];\n    if (o) return !0;\n    var s,\n      a,\n      u = t[0],\n      l = t.left,\n      c = t.right,\n      h = l[0],\n      p = l[1],\n      f = c[0],\n      g = c[1],\n      d = (h + f) / 2,\n      y = (p + g) / 2;\n    if (g === p) {\n      if (d < e || d >= r) return;\n      if (h > f) {\n        if (u) {\n          if (u[1] >= i) return;\n        } else u = [d, n];\n        o = [d, i];\n      } else {\n        if (u) {\n          if (u[1] < n) return;\n        } else u = [d, i];\n        o = [d, n];\n      }\n    } else if (a = y - (s = (h - f) / (g - p)) * d, s < -1 || s > 1) {\n      if (h > f) {\n        if (u) {\n          if (u[1] >= i) return;\n        } else u = [(n - a) / s, n];\n        o = [(i - a) / s, i];\n      } else {\n        if (u) {\n          if (u[1] < n) return;\n        } else u = [(i - a) / s, i];\n        o = [(n - a) / s, n];\n      }\n    } else if (p < g) {\n      if (u) {\n        if (u[0] >= r) return;\n      } else u = [e, s * e + a];\n      o = [r, s * r + a];\n    } else {\n      if (u) {\n        if (u[0] < e) return;\n      } else u = [r, s * r + a];\n      o = [e, s * e + a];\n    }\n    return t[0] = u, t[1] = o, !0;\n  }\n  function la(t, e) {\n    var n = t.site,\n      r = e.left,\n      i = e.right;\n    return n === i && (i = r, r = n), i ? Math.atan2(i[1] - r[1], i[0] - r[0]) : (n === r ? (r = e[1], i = e[0]) : (r = e[0], i = e[1]), Math.atan2(r[0] - i[0], i[1] - r[1]));\n  }\n  function ca(t, e) {\n    return e[+(e.left !== t.site)];\n  }\n  function ha(t, e) {\n    return e[+(e.left === t.site)];\n  }\n  Ys.prototype.init = function () {\n    this.dirtyNodes = [];\n    for (var t = 0; t < this.nodes.length; t++) Xs.cleanNode(this.nodes[t]);\n  }, Ys.prototype.cleanDirty = function () {\n    for (var t = 0; t < this.dirtyNodes.length; t++) Xs.cleanNode(this.dirtyNodes[t]);\n    this.dirtyNodes = [];\n  }, Ys.prototype.markDirty = function (t) {\n    this.dirtyNodes.push(t);\n  }, Ys.prototype.neighbors = function (t) {\n    var e = [],\n      n = t.x,\n      r = t.y,\n      i = this.grid;\n    return i[n - 1] && i[n - 1][r] && e.push(i[n - 1][r]), i[n + 1] && i[n + 1][r] && e.push(i[n + 1][r]), i[n] && i[n][r - 1] && e.push(i[n][r - 1]), i[n] && i[n][r + 1] && e.push(i[n][r + 1]), this.diagonal && (i[n - 1] && i[n - 1][r - 1] && e.push(i[n - 1][r - 1]), i[n + 1] && i[n + 1][r - 1] && e.push(i[n + 1][r - 1]), i[n - 1] && i[n - 1][r + 1] && e.push(i[n - 1][r + 1]), i[n + 1] && i[n + 1][r + 1] && e.push(i[n + 1][r + 1])), e;\n  }, Ys.prototype.toString = function () {\n    for (var t, e, n, r, i = [], o = this.grid, s = 0, a = o.length; s < a; s++) {\n      for (t = [], n = 0, r = (e = o[s]).length; n < r; n++) t.push(e[n].weight);\n      i.push(t.join(\" \"));\n    }\n    return i.join(\"\\n\");\n  }, Hs.prototype.toString = function () {\n    return \"[\" + this.x + \" \" + this.y + \"]\";\n  }, Hs.prototype.getCost = function (t) {\n    return t && t.x !== this.x && t.y !== this.y ? 1.41421 * this.weight : this.weight;\n  }, Hs.prototype.isWall = function () {\n    return 0 === this.weight;\n  }, Ws.prototype = {\n    push: function push(t) {\n      this.content.push(t), this.sinkDown(this.content.length - 1);\n    },\n    pop: function pop() {\n      var t = this.content[0],\n        e = this.content.pop();\n      return this.content.length > 0 && (this.content[0] = e, this.bubbleUp(0)), t;\n    },\n    remove: function remove(t) {\n      var e = this.content.indexOf(t),\n        n = this.content.pop();\n      e !== this.content.length - 1 && (this.content[e] = n, this.scoreFunction(n) < this.scoreFunction(t) ? this.sinkDown(e) : this.bubbleUp(e));\n    },\n    size: function size() {\n      return this.content.length;\n    },\n    rescoreElement: function rescoreElement(t) {\n      this.sinkDown(this.content.indexOf(t));\n    },\n    sinkDown: function sinkDown(t) {\n      for (var e = this.content[t]; t > 0;) {\n        var n = (t + 1 >> 1) - 1,\n          r = this.content[n];\n        if (!(this.scoreFunction(e) < this.scoreFunction(r))) break;\n        this.content[n] = e, this.content[t] = r, t = n;\n      }\n    },\n    bubbleUp: function bubbleUp(t) {\n      for (var e = this.content.length, n = this.content[t], r = this.scoreFunction(n);;) {\n        var i,\n          o = t + 1 << 1,\n          s = o - 1,\n          a = null;\n        if (s < e) {\n          var u = this.content[s];\n          (i = this.scoreFunction(u)) < r && (a = s);\n        }\n        if (o < e) {\n          var l = this.content[o];\n          this.scoreFunction(l) < (null === a ? r : i) && (a = o);\n        }\n        if (null === a) break;\n        this.content[t] = this.content[a], this.content[a] = n, t = a;\n      }\n    }\n  }, $s.prototype = {\n    constructor: $s,\n    insert: function insert(t, e) {\n      var n, r, i;\n      if (t) {\n        if (e.P = t, e.N = t.N, t.N && (t.N.P = e), t.N = e, t.R) {\n          for (t = t.R; t.L;) t = t.L;\n          t.L = e;\n        } else t.R = e;\n        n = t;\n      } else this._ ? (t = ra(this._), e.P = null, e.N = t, t.P = t.L = e, n = t) : (e.P = e.N = null, this._ = e, n = null);\n      for (e.L = e.R = null, e.U = n, e.C = !0, t = e; n && n.C;) n === (r = n.U).L ? (i = r.R) && i.C ? (n.C = i.C = !1, r.C = !0, t = r) : (t === n.R && (ea(this, n), n = (t = n).U), n.C = !1, r.C = !0, na(this, r)) : (i = r.L) && i.C ? (n.C = i.C = !1, r.C = !0, t = r) : (t === n.L && (na(this, n), n = (t = n).U), n.C = !1, r.C = !0, ea(this, r)), n = t.U;\n      this._.C = !1;\n    },\n    remove: function remove(t) {\n      t.N && (t.N.P = t.P), t.P && (t.P.N = t.N), t.N = t.P = null;\n      var e,\n        n,\n        r,\n        i = t.U,\n        o = t.L,\n        s = t.R;\n      if (n = o ? s ? ra(s) : o : s, i ? i.L === t ? i.L = n : i.R = n : this._ = n, o && s ? (r = n.C, n.C = t.C, n.L = o, o.U = n, n !== s ? (i = n.U, n.U = t.U, t = n.R, i.L = t, n.R = s, s.U = n) : (n.U = i, i = n, t = n.R)) : (r = t.C, t = n), t && (t.U = i), !r) if (t && t.C) t.C = !1;else {\n        do {\n          if (t === this._) break;\n          if (t === i.L) {\n            if ((e = i.R).C && (e.C = !1, i.C = !0, ea(this, i), e = i.R), e.L && e.L.C || e.R && e.R.C) {\n              e.R && e.R.C || (e.L.C = !1, e.C = !0, na(this, e), e = i.R), e.C = i.C, i.C = e.R.C = !1, ea(this, i), t = this._;\n              break;\n            }\n          } else if ((e = i.L).C && (e.C = !1, i.C = !0, na(this, i), e = i.L), e.L && e.L.C || e.R && e.R.C) {\n            e.L && e.L.C || (e.R.C = !1, e.C = !0, ea(this, e), e = i.L), e.C = i.C, i.C = e.L.C = !1, na(this, i), t = this._;\n            break;\n          }\n          e.C = !0, t = i, i = i.U;\n        } while (!t.C);\n        t && (t.C = !1);\n      }\n    }\n  };\n  var pa,\n    fa = [];\n  function ga() {\n    ta(this), this.x = this.y = this.arc = this.site = this.cy = null;\n  }\n  function da(t) {\n    var e = t.P,\n      n = t.N;\n    if (e && n) {\n      var r = e.site,\n        i = t.site,\n        o = n.site;\n      if (r !== o) {\n        var s = i[0],\n          a = i[1],\n          u = r[0] - s,\n          l = r[1] - a,\n          c = o[0] - s,\n          h = o[1] - a,\n          p = 2 * (u * h - l * c);\n        if (!(p >= -La)) {\n          var f = u * u + l * l,\n            g = c * c + h * h,\n            d = (h * f - l * g) / p,\n            y = (u * g - c * f) / p,\n            v = fa.pop() || new ga();\n          v.arc = t, v.site = i, v.x = d + s, v.y = (v.cy = y + a) + Math.sqrt(d * d + y * y), t.circle = v;\n          for (var _ = null, m = Ca._; m;) if (v.y < m.y || v.y === m.y && v.x <= m.x) {\n            if (!m.L) {\n              _ = m.P;\n              break;\n            }\n            m = m.L;\n          } else {\n            if (!m.R) {\n              _ = m;\n              break;\n            }\n            m = m.R;\n          }\n          Ca.insert(_, v), _ || (pa = v);\n        }\n      }\n    }\n  }\n  function ya(t) {\n    var e = t.circle;\n    e && (e.P || (pa = e.N), Ca.remove(e), fa.push(e), ta(e), t.circle = null);\n  }\n  var va = [];\n  function _a() {\n    ta(this), this.edge = this.site = this.circle = null;\n  }\n  function ma(t) {\n    var e = va.pop() || new _a();\n    return e.site = t, e;\n  }\n  function xa(t) {\n    ya(t), Na.remove(t), va.push(t), ta(t);\n  }\n  function Ea(t) {\n    var e = t.circle,\n      n = e.x,\n      r = e.cy,\n      i = [n, r],\n      o = t.P,\n      s = t.N,\n      a = [t];\n    xa(t);\n    for (var u = o; u.circle && Math.abs(n - u.circle.x) < Ma && Math.abs(r - u.circle.cy) < Ma;) o = u.P, a.unshift(u), xa(u), u = o;\n    a.unshift(u), ya(u);\n    for (var l = s; l.circle && Math.abs(n - l.circle.x) < Ma && Math.abs(r - l.circle.cy) < Ma;) s = l.N, a.push(l), xa(l), l = s;\n    a.push(l), ya(l);\n    var c,\n      h = a.length;\n    for (c = 1; c < h; ++c) l = a[c], u = a[c - 1], sa(l.edge, u.site, l.site, i);\n    u = a[0], (l = a[h - 1]).edge = ia(u.site, l.site, null, i), da(u), da(l);\n  }\n  function ba(t) {\n    for (var e, n, r, i, o = t[0], s = t[1], a = Na._; a;) if ((r = wa(a, s) - o) > Ma) a = a.L;else {\n      if (!((i = o - Ia(a, s)) > Ma)) {\n        r > -Ma ? (e = a.P, n = a) : i > -Ma ? (e = a, n = a.N) : e = n = a;\n        break;\n      }\n      if (!a.R) {\n        e = a;\n        break;\n      }\n      a = a.R;\n    }\n    !function (t) {\n      Sa[t.index] = {\n        site: t,\n        halfedges: []\n      };\n    }(t);\n    var u = ma(t);\n    if (Na.insert(e, u), e || n) {\n      if (e === n) return ya(e), n = ma(e.site), Na.insert(u, n), u.edge = n.edge = ia(e.site, u.site), da(e), void da(n);\n      if (n) {\n        ya(e), ya(n);\n        var l = e.site,\n          c = l[0],\n          h = l[1],\n          p = t[0] - c,\n          f = t[1] - h,\n          g = n.site,\n          d = g[0] - c,\n          y = g[1] - h,\n          v = 2 * (p * y - f * d),\n          _ = p * p + f * f,\n          m = d * d + y * y,\n          x = [(y * _ - f * m) / v + c, (p * m - d * _) / v + h];\n        sa(n.edge, l, g, x), u.edge = ia(l, t, null, x), n.edge = ia(t, g, null, x), da(e), da(n);\n      } else u.edge = ia(e.site, u.site);\n    }\n  }\n  function wa(t, e) {\n    var n = t.site,\n      r = n[0],\n      i = n[1],\n      o = i - e;\n    if (!o) return r;\n    var s = t.P;\n    if (!s) return -1 / 0;\n    var a = (n = s.site)[0],\n      u = n[1],\n      l = u - e;\n    if (!l) return a;\n    var c = a - r,\n      h = 1 / o - 1 / l,\n      p = c / l;\n    return h ? (-p + Math.sqrt(p * p - 2 * h * (c * c / (-2 * l) - u + l / 2 + i - o / 2))) / h + r : (r + a) / 2;\n  }\n  function Ia(t, e) {\n    var n = t.N;\n    if (n) return wa(n, e);\n    var r = t.site;\n    return r[1] === e ? r[0] : 1 / 0;\n  }\n  var Na,\n    Sa,\n    Ca,\n    Pa,\n    Ma = 1e-6,\n    La = 1e-12;\n  function Oa(t, e) {\n    return e[1] - t[1] || e[0] - t[0];\n  }\n  function Ra(t, e) {\n    var n,\n      r,\n      i,\n      o = t.sort(Oa).pop();\n    for (Pa = [], Sa = new Array(t.length), Na = new $s(), Ca = new $s();;) if (i = pa, o && (!i || o[1] < i.y || o[1] === i.y && o[0] < i.x)) o[0] === n && o[1] === r || (ba(o), n = o[0], r = o[1]), o = t.pop();else {\n      if (!i) break;\n      Ea(i.arc);\n    }\n    if (function () {\n      for (var t, e, n, r, i = 0, o = Sa.length; i < o; ++i) if ((t = Sa[i]) && (r = (e = t.halfedges).length)) {\n        var s = new Array(r),\n          a = new Array(r);\n        for (n = 0; n < r; ++n) s[n] = n, a[n] = la(t, Pa[e[n]]);\n        for (s.sort(function (t, e) {\n          return a[e] - a[t];\n        }), n = 0; n < r; ++n) a[n] = e[s[n]];\n        for (n = 0; n < r; ++n) e[n] = a[n];\n      }\n    }(), e) {\n      var s = +e[0][0],\n        a = +e[0][1],\n        u = +e[1][0],\n        l = +e[1][1];\n      !function (t, e, n, r) {\n        for (var i, o = Pa.length; o--;) ua(i = Pa[o], t, e, n, r) && aa(i, t, e, n, r) && (Math.abs(i[0][0] - i[1][0]) > Ma || Math.abs(i[0][1] - i[1][1]) > Ma) || delete Pa[o];\n      }(s, a, u, l), function (t, e, n, r) {\n        var i,\n          o,\n          s,\n          a,\n          u,\n          l,\n          c,\n          h,\n          p,\n          f,\n          g,\n          d,\n          y = Sa.length,\n          v = !0;\n        for (i = 0; i < y; ++i) if (o = Sa[i]) {\n          for (s = o.site, a = (u = o.halfedges).length; a--;) Pa[u[a]] || u.splice(a, 1);\n          for (a = 0, l = u.length; a < l;) g = (f = ha(o, Pa[u[a]]))[0], d = f[1], h = (c = ca(o, Pa[u[++a % l]]))[0], p = c[1], (Math.abs(g - h) > Ma || Math.abs(d - p) > Ma) && (u.splice(a, 0, Pa.push(oa(s, f, Math.abs(g - t) < Ma && r - d > Ma ? [t, Math.abs(h - t) < Ma ? p : r] : Math.abs(d - r) < Ma && n - g > Ma ? [Math.abs(p - r) < Ma ? h : n, r] : Math.abs(g - n) < Ma && d - e > Ma ? [n, Math.abs(h - n) < Ma ? p : e] : Math.abs(d - e) < Ma && g - t > Ma ? [Math.abs(p - e) < Ma ? h : t, e] : null)) - 1), ++l);\n          l && (v = !1);\n        }\n        if (v) {\n          var _,\n            m,\n            x,\n            E = 1 / 0;\n          for (i = 0, v = null; i < y; ++i) (o = Sa[i]) && (x = (_ = (s = o.site)[0] - t) * _ + (m = s[1] - e) * m) < E && (E = x, v = o);\n          if (v) {\n            var b = [t, e],\n              w = [t, r],\n              I = [n, r],\n              N = [n, e];\n            v.halfedges.push(Pa.push(oa(s = v.site, b, w)) - 1, Pa.push(oa(s, w, I)) - 1, Pa.push(oa(s, I, N)) - 1, Pa.push(oa(s, N, b)) - 1);\n          }\n        }\n        for (i = 0; i < y; ++i) (o = Sa[i]) && (o.halfedges.length || delete Sa[i]);\n      }(s, a, u, l);\n    }\n    this.edges = Pa, this.cells = Sa, Na = Ca = Pa = Sa = null;\n  }\n  function Ta(t) {\n    return (t = t.slice()).push(t[0]), l([t]);\n  }\n  function Aa(t, e, n, r) {\n    var i = (r = r || {}).steps || 64,\n      o = r.units || \"kilometers\",\n      s = r.angle || 0,\n      a = r.pivot || t,\n      u = r.properties || t.properties || {};\n    if (!t) throw new Error(\"center is required\");\n    if (!e) throw new Error(\"xSemiAxis is required\");\n    if (!n) throw new Error(\"ySemiAxis is required\");\n    if (!P(r)) throw new Error(\"options must be an object\");\n    if (!C(i)) throw new Error(\"steps must be a number\");\n    if (!C(s)) throw new Error(\"angle must be a number\");\n    var c = K(t);\n    if (\"degrees\" === o) var h = I(s);else e = ji(t, e, 90, {\n      units: o\n    }), n = ji(t, n, 0, {\n      units: o\n    }), e = K(e)[0] - c[0], n = K(n)[1] - c[1];\n    for (var p = [], f = 0; f < i; f += 1) {\n      var g = -360 * f / i,\n        d = e * n / Math.sqrt(Math.pow(n, 2) + Math.pow(e, 2) * Math.pow(Da(g), 2)),\n        y = e * n / Math.sqrt(Math.pow(e, 2) + Math.pow(n, 2) / Math.pow(Da(g), 2));\n      if (g < -90 && g >= -270 && (d = -d), g < -180 && g >= -360 && (y = -y), \"degrees\" === o) {\n        var v = d * Math.cos(h) + y * Math.sin(h),\n          _ = y * Math.cos(h) - d * Math.sin(h);\n        d = v, y = _;\n      }\n      p.push([d + c[0], y + c[1]]);\n    }\n    return p.push(p[0]), \"degrees\" === o ? l([p], u) : $o(l([p], u), s, {\n      pivot: a\n    });\n  }\n  function Da(t) {\n    var e = t * Math.PI / 180;\n    return Math.tan(e);\n  }\n  function Fa(t, e) {\n    void 0 === e && (e = {});\n    var n = 0,\n      r = 0,\n      i = 0;\n    return q(t, function (t, o, s) {\n      var a = e.weight ? null == s ? void 0 : s[e.weight] : void 0;\n      if (!C(a = null == a ? 1 : a)) throw new Error(\"weight value must be a number for feature index \" + o);\n      (a = Number(a)) > 0 && R(t, function (t) {\n        n += t[0] * a, r += t[1] * a, i += a;\n      });\n    }), a([n / i, r / i], e.properties, e);\n  }\n  function ka(t, e, n, r, i) {\n    var o = r.tolerance || .001,\n      s = 0,\n      u = 0,\n      l = 0,\n      c = 0;\n    if (F(n, function (e) {\n      var n,\n        r = null === (n = e.properties) || void 0 === n ? void 0 : n.weight,\n        i = null == r ? 1 : r;\n      if (!C(i = Number(i))) throw new Error(\"weight value must be a number\");\n      if (i > 0) {\n        c += 1;\n        var o = i * me(e, t);\n        0 === o && (o = 1);\n        var a = i / o;\n        s += e.geometry.coordinates[0] * a, u += e.geometry.coordinates[1] * a, l += a;\n      }\n    }), c < 1) throw new Error(\"no features to measure\");\n    var h = s / l,\n      p = u / l;\n    return 1 === c || 0 === i || Math.abs(h - e[0]) < o && Math.abs(p - e[1]) < o ? a([h, p], {\n      medianCandidates: r.medianCandidates\n    }) : (r.medianCandidates.push([h, p]), ka([h, p], t, n, r, i - 1));\n  }\n  function Ga(t, e) {\n    return {\n      x: t[0] - e[0],\n      y: t[1] - e[1]\n    };\n  }\n  function qa(t, e) {\n    var n = 0,\n      r = 0;\n    R(t, function (i, o, s, a, u) {\n      u > n && (n = u, r = o, e.push([]));\n      var l = o - r,\n        c = t.coordinates[u][l + 1],\n        h = i[0],\n        p = i[1],\n        f = c[0],\n        g = c[1];\n      e[u].push([.75 * h + .25 * f, .75 * p + .25 * g]), e[u].push([.25 * h + .75 * f, .25 * p + .75 * g]);\n    }, !0), e.forEach(function (t) {\n      t.push(t[0]);\n    });\n  }\n  function Ba(t, e) {\n    var n = 0,\n      r = 0,\n      i = 0;\n    R(t, function (o, s, a, u, l) {\n      u > i && (i = u, r = s, e.push([[]])), l > n && (n = l, r = s, e[u].push([]));\n      var c = s - r,\n        h = t.coordinates[u][l][c + 1],\n        p = o[0],\n        f = o[1],\n        g = h[0],\n        d = h[1];\n      e[u][l].push([.75 * p + .25 * g, .75 * f + .25 * d]), e[u][l].push([.25 * p + .75 * g, .25 * f + .75 * d]);\n    }, !0), e.forEach(function (t) {\n      t.forEach(function (t) {\n        t.push(t[0]);\n      });\n    });\n  }\n  function za(t, e, n) {\n    void 0 === n && (n = 2);\n    var r = K(t),\n      i = K(e),\n      o = r[0] - i[0],\n      s = r[1] - i[1];\n    return 1 === n ? Math.abs(o) + Math.abs(s) : Math.pow(Math.pow(o, n) + Math.pow(s, n), 1 / n);\n  }\n  function ja(t, e) {\n    var n = (e = e || {}).threshold || 1e4,\n      r = e.p || 2,\n      i = e.binary || !1,\n      o = e.alpha || -1,\n      s = e.standardization || !1,\n      a = [];\n    F(t, function (t) {\n      a.push(En(t));\n    });\n    for (var u = [], l = 0; l < a.length; l++) u[l] = [];\n    for (l = 0; l < a.length; l++) for (var c = l; c < a.length; c++) {\n      l === c && (u[l][c] = 0);\n      var h = za(a[l], a[c], r);\n      u[l][c] = h, u[c][l] = h;\n    }\n    for (l = 0; l < a.length; l++) for (c = 0; c < a.length; c++) {\n      0 !== (h = u[l][c]) && (u[l][c] = i ? h <= n ? 1 : 0 : h <= n ? Math.pow(h, o) : 0);\n    }\n    if (s) for (l = 0; l < a.length; l++) {\n      var p = u[l].reduce(function (t, e) {\n        return t + e;\n      }, 0);\n      for (c = 0; c < a.length; c++) u[l][c] = u[l][c] / p;\n    }\n    return u;\n  }\n  function Ua(t) {\n    for (var e = 0, n = 0, r = t; n < r.length; n++) {\n      e += r[n];\n    }\n    return e / t.length;\n  }\n  function Va(t, e) {\n    return void 0 === e && (e = {}), Ya(t, \"mercator\", e);\n  }\n  function Xa(t, e) {\n    return void 0 === e && (e = {}), Ya(t, \"wgs84\", e);\n  }\n  function Ya(t, e, n) {\n    void 0 === n && (n = {});\n    var r = (n = n || {}).mutate;\n    if (!t) throw new Error(\"geojson is required\");\n    return Array.isArray(t) && C(t[0]) ? t = \"mercator\" === e ? Ha(t) : Wa(t) : (!0 !== r && (t = Ie(t)), R(t, function (t) {\n      var n = \"mercator\" === e ? Ha(t) : Wa(t);\n      t[0] = n[0], t[1] = n[1];\n    })), t;\n  }\n  function Ha(t) {\n    var e = Math.PI / 180,\n      n = 6378137,\n      r = 20037508.342789244,\n      i = [n * (Math.abs(t[0]) <= 180 ? t[0] : t[0] - 360 * function (t) {\n        return t < 0 ? -1 : t > 0 ? 1 : 0;\n      }(t[0])) * e, n * Math.log(Math.tan(.25 * Math.PI + .5 * t[1] * e))];\n    return i[0] > r && (i[0] = r), i[0] < -r && (i[0] = -r), i[1] > r && (i[1] = r), i[1] < -r && (i[1] = -r), i;\n  }\n  function Wa(t) {\n    var e = 180 / Math.PI,\n      n = 6378137;\n    return [t[0] * e / n, (.5 * Math.PI - 2 * Math.atan(Math.exp(-t[1] / n))) * e];\n  }\n  Ra.prototype = {\n    constructor: Ra,\n    polygons: function polygons() {\n      var t = this.edges;\n      return this.cells.map(function (e) {\n        var n = e.halfedges.map(function (n) {\n          return ca(e, t[n]);\n        });\n        return n.data = e.site.data, n;\n      });\n    },\n    triangles: function triangles() {\n      var t = [],\n        e = this.edges;\n      return this.cells.forEach(function (n, r) {\n        if (o = (i = n.halfedges).length) for (var i, o, s, a, u, l, c = n.site, h = -1, p = e[i[o - 1]], f = p.left === c ? p.right : p.left; ++h < o;) s = f, f = (p = e[i[h]]).left === c ? p.right : p.left, s && f && r < s.index && r < f.index && (u = s, l = f, ((a = c)[0] - l[0]) * (u[1] - a[1]) - (a[0] - u[0]) * (l[1] - a[1]) < 0) && t.push([c.data, s.data, f.data]);\n      }), t;\n    },\n    links: function links() {\n      return this.edges.filter(function (t) {\n        return t.right;\n      }).map(function (t) {\n        return {\n          source: t.left.data,\n          target: t.right.data\n        };\n      });\n    },\n    find: function find(t, e, n) {\n      for (var r, i, o = this, s = o._found || 0, a = o.cells.length; !(i = o.cells[s]);) if (++s >= a) return null;\n      var u = t - i.site[0],\n        l = e - i.site[1],\n        c = u * u + l * l;\n      do {\n        i = o.cells[r = s], s = null, i.halfedges.forEach(function (n) {\n          var r = o.edges[n],\n            a = r.left;\n          if (a !== i.site && a || (a = r.right)) {\n            var u = t - a[0],\n              l = e - a[1],\n              h = u * u + l * l;\n            h < c && (c = h, s = a.index);\n          }\n        });\n      } while (null !== s);\n      return o._found = r, null == n || c <= n * n ? i.site : null;\n    }\n  };\n  var Ja = Object.freeze({\n      __proto__: null,\n      toMercator: Va,\n      toWgs84: Xa\n    }),\n    Za = function Za() {\n      for (var t = 0, e = 0, n = arguments.length; e < n; e++) t += arguments[e].length;\n      var r = Array(t),\n        i = 0;\n      for (e = 0; e < n; e++) for (var o = arguments[e], s = 0, a = o.length; s < a; s++, i++) r[i] = o[s];\n      return r;\n    };\n  function Ka(t) {\n    return Array.isArray(t) ? nu(t) : t && t.bbox ? nu(t.bbox) : [360 * eu(), 180 * eu()];\n  }\n  function Qa(t, e) {\n    void 0 === e && (e = {}), null == t && (t = 1);\n    for (var n = [], r = 0; r < t; r++) n.push(a(Ka(e.bbox)));\n    return f(n);\n  }\n  function $a(t, e) {\n    void 0 === e && (e = {}), null == t && (t = 1), C(e.num_vertices) && void 0 !== e.num_vertices || (e.num_vertices = 10), C(e.max_radial_length) && void 0 !== e.max_radial_length || (e.max_radial_length = 10);\n    for (var n = [], r = function r(t) {\n        var r,\n          i = [],\n          o = Za(Array(e.num_vertices + 1)).map(Math.random);\n        o.forEach(function (t, e, n) {\n          n[e] = e > 0 ? t + n[e - 1] : t;\n        }), o.forEach(function (t) {\n          t = 2 * t * Math.PI / o[o.length - 1];\n          var n = Math.random();\n          i.push([n * (e.max_radial_length || 10) * Math.sin(t), n * (e.max_radial_length || 10) * Math.cos(t)]);\n        }), i[i.length - 1] = i[0], i = i.map((r = Ka(e.bbox), function (t) {\n          return [t[0] + r[0], t[1] + r[1]];\n        })), n.push(l([i]));\n      }, i = 0; i < t; i++) r();\n    return f(n);\n  }\n  function tu(t, e) {\n    if (void 0 === e && (e = {}), !P(e = e || {})) throw new Error(\"options is invalid\");\n    var n = e.bbox,\n      r = e.num_vertices,\n      i = e.max_length,\n      o = e.max_rotation;\n    null == t && (t = 1), (!C(r) || void 0 === r || r < 2) && (r = 10), C(i) && void 0 !== i || (i = 1e-4), C(o) && void 0 !== o || (o = Math.PI / 8);\n    for (var s = [], a = 0; a < t; a++) {\n      for (var u = [Ka(n)], l = 0; l < r - 1; l++) {\n        var c = (0 === l ? 2 * Math.random() * Math.PI : Math.tan((u[l][1] - u[l - 1][1]) / (u[l][0] - u[l - 1][0]))) + (Math.random() - .5) * o * 2,\n          p = Math.random() * i;\n        u.push([u[l][0] + p * Math.cos(c), u[l][1] + p * Math.sin(c)]);\n      }\n      s.push(h(u));\n    }\n    return f(s);\n  }\n  function eu() {\n    return Math.random() - .5;\n  }\n  function nu(t) {\n    return [Math.random() * (t[2] - t[0]) + t[0], Math.random() * (t[3] - t[1]) + t[1]];\n  }\n  var ru = Object.freeze({\n    __proto__: null,\n    randomPosition: Ka,\n    randomPoint: Qa,\n    randomPolygon: $a,\n    randomLineString: tu\n  });\n  function iu(t, e) {\n    if (!t) throw new Error(\"geojson is required\");\n    if (\"FeatureCollection\" !== t.type) throw new Error(\"geojson must be a FeatureCollection\");\n    if (null == e) throw new Error(\"filter is required\");\n    var n = [];\n    return F(t, function (t) {\n      uu(t.properties, e) && n.push(t);\n    }), f(n);\n  }\n  function ou(t, e, n) {\n    if (!t) throw new Error(\"geojson is required\");\n    if (\"FeatureCollection\" !== t.type) throw new Error(\"geojson must be a FeatureCollection\");\n    if (null == e) throw new Error(\"property is required\");\n    for (var r = au(t, e), i = Object.keys(r), o = 0; o < i.length; o++) {\n      for (var s = i[o], a = r[s], u = [], l = 0; l < a.length; l++) u.push(t.features[a[l]]);\n      n(f(u), s, o);\n    }\n  }\n  function su(t, e, n, r) {\n    var i = r;\n    return ou(t, e, function (t, e, o) {\n      i = 0 === o && void 0 === r ? t : n(i, t, e, o);\n    }), i;\n  }\n  function au(t, e) {\n    var n = {};\n    return F(t, function (t, r) {\n      var i = t.properties || {};\n      if (Object.prototype.hasOwnProperty.call(i, String(e))) {\n        var o = i[e];\n        Object.prototype.hasOwnProperty.call(n, o) ? n[o].push(r) : n[o] = [r];\n      }\n    }), n;\n  }\n  function uu(t, e) {\n    if (void 0 === t) return !1;\n    var n = typeof e;\n    if (\"number\" === n || \"string\" === n) return Object.prototype.hasOwnProperty.call(t, e);\n    if (Array.isArray(e)) {\n      for (var r = 0; r < e.length; r++) if (!uu(t, e[r])) return !1;\n      return !0;\n    }\n    return lu(t, e);\n  }\n  function lu(t, e) {\n    for (var n = Object.keys(e), r = 0; r < n.length; r++) {\n      var i = n[r];\n      if (t[i] !== e[i]) return !1;\n    }\n    return !0;\n  }\n  function cu(t, e) {\n    if (!e) return {};\n    if (!e.length) return {};\n    for (var n = {}, r = 0; r < e.length; r++) {\n      var i = e[r];\n      Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);\n    }\n    return n;\n  }\n  var hu = Object.freeze({\n      __proto__: null,\n      getCluster: iu,\n      clusterEach: ou,\n      clusterReduce: su,\n      createBins: au,\n      applyFilter: uu,\n      propertiesContainsFilter: lu,\n      filterProperties: cu\n    }),\n    pu = function pu(t, e) {\n      this.next = null, this.key = t, this.data = e, this.left = null, this.right = null;\n    };\n  /**\n       * splaytree v3.1.0\n       * Fast Splay tree for Node and browser\n       *\n       * @author Alexander Milevski <info@w8r.name>\n       * @license MIT\n       * @preserve\n       */\n  function fu(t, e) {\n    return t > e ? 1 : t < e ? -1 : 0;\n  }\n  function gu(t, e, n) {\n    for (var r = new pu(null, null), i = r, o = r;;) {\n      var s = n(t, e.key);\n      if (s < 0) {\n        if (null === e.left) break;\n        if (n(t, e.left.key) < 0) {\n          var a = e.left;\n          if (e.left = a.right, a.right = e, null === (e = a).left) break;\n        }\n        o.left = e, o = e, e = e.left;\n      } else {\n        if (!(s > 0)) break;\n        if (null === e.right) break;\n        if (n(t, e.right.key) > 0) {\n          a = e.right;\n          if (e.right = a.left, a.left = e, null === (e = a).right) break;\n        }\n        i.right = e, i = e, e = e.right;\n      }\n    }\n    return i.right = e.left, o.left = e.right, e.left = r.right, e.right = r.left, e;\n  }\n  function du(t, e, n, r) {\n    var i = new pu(t, e);\n    if (null === n) return i.left = i.right = null, i;\n    var o = r(t, (n = gu(t, n, r)).key);\n    return o < 0 ? (i.left = n.left, i.right = n, n.left = null) : o >= 0 && (i.right = n.right, i.left = n, n.right = null), i;\n  }\n  function yu(t, e, n) {\n    var r = null,\n      i = null;\n    if (e) {\n      var o = n((e = gu(t, e, n)).key, t);\n      0 === o ? (r = e.left, i = e.right) : o < 0 ? (i = e.right, e.right = null, r = e) : (r = e.left, e.left = null, i = e);\n    }\n    return {\n      left: r,\n      right: i\n    };\n  }\n  function vu(t, e, n, r, i) {\n    if (t) {\n      r(e + (n ? \" \" : \" \") + i(t) + \"\\n\");\n      var o = e + (n ? \"    \" : \"   \");\n      t.left && vu(t.left, o, !1, r, i), t.right && vu(t.right, o, !0, r, i);\n    }\n  }\n  var _u = function () {\n    function t(t) {\n      void 0 === t && (t = fu), this._root = null, this._size = 0, this._comparator = t;\n    }\n    return t.prototype.insert = function (t, e) {\n      return this._size++, this._root = du(t, e, this._root, this._comparator);\n    }, t.prototype.add = function (t, e) {\n      var n = new pu(t, e);\n      null === this._root && (n.left = n.right = null, this._size++, this._root = n);\n      var r = this._comparator,\n        i = gu(t, this._root, r),\n        o = r(t, i.key);\n      return 0 === o ? this._root = i : (o < 0 ? (n.left = i.left, n.right = i, i.left = null) : o > 0 && (n.right = i.right, n.left = i, i.right = null), this._size++, this._root = n), this._root;\n    }, t.prototype.remove = function (t) {\n      this._root = this._remove(t, this._root, this._comparator);\n    }, t.prototype._remove = function (t, e, n) {\n      var r;\n      return null === e ? null : 0 === n(t, (e = gu(t, e, n)).key) ? (null === e.left ? r = e.right : (r = gu(t, e.left, n)).right = e.right, this._size--, r) : e;\n    }, t.prototype.pop = function () {\n      var t = this._root;\n      if (t) {\n        for (; t.left;) t = t.left;\n        return this._root = gu(t.key, this._root, this._comparator), this._root = this._remove(t.key, this._root, this._comparator), {\n          key: t.key,\n          data: t.data\n        };\n      }\n      return null;\n    }, t.prototype.findStatic = function (t) {\n      for (var e = this._root, n = this._comparator; e;) {\n        var r = n(t, e.key);\n        if (0 === r) return e;\n        e = r < 0 ? e.left : e.right;\n      }\n      return null;\n    }, t.prototype.find = function (t) {\n      return this._root && (this._root = gu(t, this._root, this._comparator), 0 !== this._comparator(t, this._root.key)) ? null : this._root;\n    }, t.prototype.contains = function (t) {\n      for (var e = this._root, n = this._comparator; e;) {\n        var r = n(t, e.key);\n        if (0 === r) return !0;\n        e = r < 0 ? e.left : e.right;\n      }\n      return !1;\n    }, t.prototype.forEach = function (t, e) {\n      for (var n = this._root, r = [], i = !1; !i;) null !== n ? (r.push(n), n = n.left) : 0 !== r.length ? (n = r.pop(), t.call(e, n), n = n.right) : i = !0;\n      return this;\n    }, t.prototype.range = function (t, e, n, r) {\n      for (var i = [], o = this._comparator, s = this._root; 0 !== i.length || s;) if (s) i.push(s), s = s.left;else {\n        if (o((s = i.pop()).key, e) > 0) break;\n        if (o(s.key, t) >= 0 && n.call(r, s)) return this;\n        s = s.right;\n      }\n      return this;\n    }, t.prototype.keys = function () {\n      var t = [];\n      return this.forEach(function (e) {\n        var n = e.key;\n        return t.push(n);\n      }), t;\n    }, t.prototype.values = function () {\n      var t = [];\n      return this.forEach(function (e) {\n        var n = e.data;\n        return t.push(n);\n      }), t;\n    }, t.prototype.min = function () {\n      return this._root ? this.minNode(this._root).key : null;\n    }, t.prototype.max = function () {\n      return this._root ? this.maxNode(this._root).key : null;\n    }, t.prototype.minNode = function (t) {\n      if (void 0 === t && (t = this._root), t) for (; t.left;) t = t.left;\n      return t;\n    }, t.prototype.maxNode = function (t) {\n      if (void 0 === t && (t = this._root), t) for (; t.right;) t = t.right;\n      return t;\n    }, t.prototype.at = function (t) {\n      for (var e = this._root, n = !1, r = 0, i = []; !n;) if (e) i.push(e), e = e.left;else if (i.length > 0) {\n        if (e = i.pop(), r === t) return e;\n        r++, e = e.right;\n      } else n = !0;\n      return null;\n    }, t.prototype.next = function (t) {\n      var e = this._root,\n        n = null;\n      if (t.right) {\n        for (n = t.right; n.left;) n = n.left;\n        return n;\n      }\n      for (var r = this._comparator; e;) {\n        var i = r(t.key, e.key);\n        if (0 === i) break;\n        i < 0 ? (n = e, e = e.left) : e = e.right;\n      }\n      return n;\n    }, t.prototype.prev = function (t) {\n      var e = this._root,\n        n = null;\n      if (null !== t.left) {\n        for (n = t.left; n.right;) n = n.right;\n        return n;\n      }\n      for (var r = this._comparator; e;) {\n        var i = r(t.key, e.key);\n        if (0 === i) break;\n        i < 0 ? e = e.left : (n = e, e = e.right);\n      }\n      return n;\n    }, t.prototype.clear = function () {\n      return this._root = null, this._size = 0, this;\n    }, t.prototype.toList = function () {\n      return function (t) {\n        var e = t,\n          n = [],\n          r = !1,\n          i = new pu(null, null),\n          o = i;\n        for (; !r;) e ? (n.push(e), e = e.left) : n.length > 0 ? e = (e = o = o.next = n.pop()).right : r = !0;\n        return o.next = null, i.next;\n      }(this._root);\n    }, t.prototype.load = function (t, e, n) {\n      void 0 === e && (e = []), void 0 === n && (n = !1);\n      var r = t.length,\n        i = this._comparator;\n      if (n && Eu(t, e, 0, r - 1, i), null === this._root) this._root = mu(t, e, 0, r), this._size = r;else {\n        var o = function (t, e, n) {\n          var r = new pu(null, null),\n            i = r,\n            o = t,\n            s = e;\n          for (; null !== o && null !== s;) n(o.key, s.key) < 0 ? (i.next = o, o = o.next) : (i.next = s, s = s.next), i = i.next;\n          null !== o ? i.next = o : null !== s && (i.next = s);\n          return r.next;\n        }(this.toList(), function (t, e) {\n          for (var n = new pu(null, null), r = n, i = 0; i < t.length; i++) r = r.next = new pu(t[i], e[i]);\n          return r.next = null, n.next;\n        }(t, e), i);\n        r = this._size + r, this._root = xu({\n          head: o\n        }, 0, r);\n      }\n      return this;\n    }, t.prototype.isEmpty = function () {\n      return null === this._root;\n    }, Object.defineProperty(t.prototype, \"size\", {\n      get: function get() {\n        return this._size;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"root\", {\n      get: function get() {\n        return this._root;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), t.prototype.toString = function (t) {\n      void 0 === t && (t = function t(_t2) {\n        return String(_t2.key);\n      });\n      var e = [];\n      return vu(this._root, \"\", !0, function (t) {\n        return e.push(t);\n      }, t), e.join(\"\");\n    }, t.prototype.update = function (t, e, n) {\n      var r = this._comparator,\n        i = yu(t, this._root, r),\n        o = i.left,\n        s = i.right;\n      r(t, e) < 0 ? s = du(e, n, s, r) : o = du(e, n, o, r), this._root = function (t, e, n) {\n        return null === e ? t : (null === t || ((e = gu(t.key, e, n)).left = t), e);\n      }(o, s, r);\n    }, t.prototype.split = function (t) {\n      return yu(t, this._root, this._comparator);\n    }, t;\n  }();\n  function mu(t, e, n, r) {\n    var i = r - n;\n    if (i > 0) {\n      var o = n + Math.floor(i / 2),\n        s = t[o],\n        a = e[o],\n        u = new pu(s, a);\n      return u.left = mu(t, e, n, o), u.right = mu(t, e, o + 1, r), u;\n    }\n    return null;\n  }\n  function xu(t, e, n) {\n    var r = n - e;\n    if (r > 0) {\n      var i = e + Math.floor(r / 2),\n        o = xu(t, e, i),\n        s = t.head;\n      return s.left = o, t.head = t.head.next, s.right = xu(t, i + 1, n), s;\n    }\n    return null;\n  }\n  function Eu(t, e, n, r, i) {\n    if (!(n >= r)) {\n      for (var o = t[n + r >> 1], s = n - 1, a = r + 1;;) {\n        do {\n          s++;\n        } while (i(t[s], o) < 0);\n        do {\n          a--;\n        } while (i(t[a], o) > 0);\n        if (s >= a) break;\n        var u = t[s];\n        t[s] = t[a], t[a] = u, u = e[s], e[s] = e[a], e[a] = u;\n      }\n      Eu(t, e, n, a, i), Eu(t, e, a + 1, r, i);\n    }\n  }\n  function bu(t, e) {\n    if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n  function wu(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n    }\n  }\n  function Iu(t, e, n) {\n    return e && wu(t.prototype, e), n && wu(t, n), t;\n  }\n  var Nu = function Nu(t, e) {\n      return t.ll.x <= e.x && e.x <= t.ur.x && t.ll.y <= e.y && e.y <= t.ur.y;\n    },\n    Su = function Su(t, e) {\n      if (e.ur.x < t.ll.x || t.ur.x < e.ll.x || e.ur.y < t.ll.y || t.ur.y < e.ll.y) return null;\n      var n = t.ll.x < e.ll.x ? e.ll.x : t.ll.x,\n        r = t.ur.x < e.ur.x ? t.ur.x : e.ur.x;\n      return {\n        ll: {\n          x: n,\n          y: t.ll.y < e.ll.y ? e.ll.y : t.ll.y\n        },\n        ur: {\n          x: r,\n          y: t.ur.y < e.ur.y ? t.ur.y : e.ur.y\n        }\n      };\n    },\n    Cu = Number.EPSILON;\n  void 0 === Cu && (Cu = Math.pow(2, -52));\n  var Pu = Cu * Cu,\n    Mu = function Mu(t, e) {\n      if (-Cu < t && t < Cu && -Cu < e && e < Cu) return 0;\n      var n = t - e;\n      return n * n < Pu * t * e ? 0 : t < e ? -1 : 1;\n    },\n    Lu = function () {\n      function t() {\n        bu(this, t), this.reset();\n      }\n      return Iu(t, [{\n        key: \"reset\",\n        value: function value() {\n          this.xRounder = new Ou(), this.yRounder = new Ou();\n        }\n      }, {\n        key: \"round\",\n        value: function value(t, e) {\n          return {\n            x: this.xRounder.round(t),\n            y: this.yRounder.round(e)\n          };\n        }\n      }]), t;\n    }(),\n    Ou = function () {\n      function t() {\n        bu(this, t), this.tree = new _u(), this.round(0);\n      }\n      return Iu(t, [{\n        key: \"round\",\n        value: function value(t) {\n          var e = this.tree.add(t),\n            n = this.tree.prev(e);\n          if (null !== n && 0 === Mu(e.key, n.key)) return this.tree.remove(t), n.key;\n          var r = this.tree.next(e);\n          return null !== r && 0 === Mu(e.key, r.key) ? (this.tree.remove(t), r.key) : t;\n        }\n      }]), t;\n    }(),\n    Ru = new Lu(),\n    Tu = function Tu(t, e) {\n      return t.x * e.y - t.y * e.x;\n    },\n    Au = function Au(t, e) {\n      return t.x * e.x + t.y * e.y;\n    },\n    Du = function Du(t, e, n) {\n      var r = {\n          x: e.x - t.x,\n          y: e.y - t.y\n        },\n        i = {\n          x: n.x - t.x,\n          y: n.y - t.y\n        },\n        o = Tu(r, i);\n      return Mu(o, 0);\n    },\n    Fu = function Fu(t) {\n      return Math.sqrt(Au(t, t));\n    },\n    ku = function ku(t, e, n) {\n      var r = {\n          x: e.x - t.x,\n          y: e.y - t.y\n        },\n        i = {\n          x: n.x - t.x,\n          y: n.y - t.y\n        };\n      return Au(i, r) / Fu(i) / Fu(r);\n    },\n    Gu = function Gu(t, e, n) {\n      return 0 === e.y ? null : {\n        x: t.x + e.x / e.y * (n - t.y),\n        y: n\n      };\n    },\n    qu = function qu(t, e, n) {\n      return 0 === e.x ? null : {\n        x: n,\n        y: t.y + e.y / e.x * (n - t.x)\n      };\n    },\n    Bu = function () {\n      function t(e, n) {\n        bu(this, t), void 0 === e.events ? e.events = [this] : e.events.push(this), this.point = e, this.isLeft = n;\n      }\n      return Iu(t, null, [{\n        key: \"compare\",\n        value: function value(e, n) {\n          var r = t.comparePoints(e.point, n.point);\n          return 0 !== r ? r : (e.point !== n.point && e.link(n), e.isLeft !== n.isLeft ? e.isLeft ? 1 : -1 : ju.compare(e.segment, n.segment));\n        }\n      }, {\n        key: \"comparePoints\",\n        value: function value(t, e) {\n          return t.x < e.x ? -1 : t.x > e.x ? 1 : t.y < e.y ? -1 : t.y > e.y ? 1 : 0;\n        }\n      }]), Iu(t, [{\n        key: \"link\",\n        value: function value(t) {\n          if (t.point === this.point) throw new Error(\"Tried to link already linked events\");\n          for (var e = t.point.events, n = 0, r = e.length; n < r; n++) {\n            var i = e[n];\n            this.point.events.push(i), i.point = this.point;\n          }\n          this.checkForConsuming();\n        }\n      }, {\n        key: \"checkForConsuming\",\n        value: function value() {\n          for (var t = this.point.events.length, e = 0; e < t; e++) {\n            var n = this.point.events[e];\n            if (void 0 === n.segment.consumedBy) for (var r = e + 1; r < t; r++) {\n              var i = this.point.events[r];\n              void 0 === i.consumedBy && n.otherSE.point.events === i.otherSE.point.events && n.segment.consume(i.segment);\n            }\n          }\n        }\n      }, {\n        key: \"getAvailableLinkedEvents\",\n        value: function value() {\n          for (var t = [], e = 0, n = this.point.events.length; e < n; e++) {\n            var r = this.point.events[e];\n            r !== this && !r.segment.ringOut && r.segment.isInResult() && t.push(r);\n          }\n          return t;\n        }\n      }, {\n        key: \"getLeftmostComparator\",\n        value: function value(t) {\n          var e = this,\n            n = new Map(),\n            r = function r(_r2) {\n              var i,\n                o,\n                s,\n                a,\n                u,\n                l = _r2.otherSE;\n              n.set(_r2, {\n                sine: (i = e.point, o = t.point, s = l.point, a = {\n                  x: o.x - i.x,\n                  y: o.y - i.y\n                }, u = {\n                  x: s.x - i.x,\n                  y: s.y - i.y\n                }, Tu(u, a) / Fu(u) / Fu(a)),\n                cosine: ku(e.point, t.point, l.point)\n              });\n            };\n          return function (t, e) {\n            n.has(t) || r(t), n.has(e) || r(e);\n            var i = n.get(t),\n              o = i.sine,\n              s = i.cosine,\n              a = n.get(e),\n              u = a.sine,\n              l = a.cosine;\n            return o >= 0 && u >= 0 ? s < l ? 1 : s > l ? -1 : 0 : o < 0 && u < 0 ? s < l ? -1 : s > l ? 1 : 0 : u < o ? -1 : u > o ? 1 : 0;\n          };\n        }\n      }]), t;\n    }(),\n    zu = 0,\n    ju = function () {\n      function t(e, n, r, i) {\n        bu(this, t), this.id = ++zu, this.leftSE = e, e.segment = this, e.otherSE = n, this.rightSE = n, n.segment = this, n.otherSE = e, this.rings = r, this.windings = i;\n      }\n      return Iu(t, null, [{\n        key: \"compare\",\n        value: function value(t, e) {\n          var n = t.leftSE.point.x,\n            r = e.leftSE.point.x,\n            i = t.rightSE.point.x,\n            o = e.rightSE.point.x;\n          if (o < n) return 1;\n          if (i < r) return -1;\n          var s = t.leftSE.point.y,\n            a = e.leftSE.point.y,\n            u = t.rightSE.point.y,\n            l = e.rightSE.point.y;\n          if (n < r) {\n            if (a < s && a < u) return 1;\n            if (a > s && a > u) return -1;\n            var c = t.comparePoint(e.leftSE.point);\n            if (c < 0) return 1;\n            if (c > 0) return -1;\n            var h = e.comparePoint(t.rightSE.point);\n            return 0 !== h ? h : -1;\n          }\n          if (n > r) {\n            if (s < a && s < l) return -1;\n            if (s > a && s > l) return 1;\n            var p = e.comparePoint(t.leftSE.point);\n            if (0 !== p) return p;\n            var f = t.comparePoint(e.rightSE.point);\n            return f < 0 ? 1 : f > 0 ? -1 : 1;\n          }\n          if (s < a) return -1;\n          if (s > a) return 1;\n          if (i < o) {\n            var g = e.comparePoint(t.rightSE.point);\n            if (0 !== g) return g;\n          }\n          if (i > o) {\n            var d = t.comparePoint(e.rightSE.point);\n            if (d < 0) return 1;\n            if (d > 0) return -1;\n          }\n          if (i !== o) {\n            var y = u - s,\n              v = i - n,\n              _ = l - a,\n              m = o - r;\n            if (y > v && _ < m) return 1;\n            if (y < v && _ > m) return -1;\n          }\n          return i > o ? 1 : i < o || u < l ? -1 : u > l ? 1 : t.id < e.id ? -1 : t.id > e.id ? 1 : 0;\n        }\n      }]), Iu(t, [{\n        key: \"replaceRightSE\",\n        value: function value(t) {\n          this.rightSE = t, this.rightSE.segment = this, this.rightSE.otherSE = this.leftSE, this.leftSE.otherSE = this.rightSE;\n        }\n      }, {\n        key: \"bbox\",\n        value: function value() {\n          var t = this.leftSE.point.y,\n            e = this.rightSE.point.y;\n          return {\n            ll: {\n              x: this.leftSE.point.x,\n              y: t < e ? t : e\n            },\n            ur: {\n              x: this.rightSE.point.x,\n              y: t > e ? t : e\n            }\n          };\n        }\n      }, {\n        key: \"vector\",\n        value: function value() {\n          return {\n            x: this.rightSE.point.x - this.leftSE.point.x,\n            y: this.rightSE.point.y - this.leftSE.point.y\n          };\n        }\n      }, {\n        key: \"isAnEndpoint\",\n        value: function value(t) {\n          return t.x === this.leftSE.point.x && t.y === this.leftSE.point.y || t.x === this.rightSE.point.x && t.y === this.rightSE.point.y;\n        }\n      }, {\n        key: \"comparePoint\",\n        value: function value(t) {\n          if (this.isAnEndpoint(t)) return 0;\n          var e = this.leftSE.point,\n            n = this.rightSE.point,\n            r = this.vector();\n          if (e.x === n.x) return t.x === e.x ? 0 : t.x < e.x ? 1 : -1;\n          var i = (t.y - e.y) / r.y,\n            o = e.x + i * r.x;\n          if (t.x === o) return 0;\n          var s = (t.x - e.x) / r.x,\n            a = e.y + s * r.y;\n          return t.y === a ? 0 : t.y < a ? -1 : 1;\n        }\n      }, {\n        key: \"getIntersection\",\n        value: function value(t) {\n          var e = this.bbox(),\n            n = t.bbox(),\n            r = Su(e, n);\n          if (null === r) return null;\n          var i = this.leftSE.point,\n            o = this.rightSE.point,\n            s = t.leftSE.point,\n            a = t.rightSE.point,\n            u = Nu(e, s) && 0 === this.comparePoint(s),\n            l = Nu(n, i) && 0 === t.comparePoint(i),\n            c = Nu(e, a) && 0 === this.comparePoint(a),\n            h = Nu(n, o) && 0 === t.comparePoint(o);\n          if (l && u) return h && !c ? o : !h && c ? a : null;\n          if (l) return c && i.x === a.x && i.y === a.y ? null : i;\n          if (u) return h && o.x === s.x && o.y === s.y ? null : s;\n          if (h && c) return null;\n          if (h) return o;\n          if (c) return a;\n          var p = function (t, e, n, r) {\n            if (0 === e.x) return qu(n, r, t.x);\n            if (0 === r.x) return qu(t, e, n.x);\n            if (0 === e.y) return Gu(n, r, t.y);\n            if (0 === r.y) return Gu(t, e, n.y);\n            var i = Tu(e, r);\n            if (0 == i) return null;\n            var o = {\n                x: n.x - t.x,\n                y: n.y - t.y\n              },\n              s = Tu(o, e) / i,\n              a = Tu(o, r) / i;\n            return {\n              x: (t.x + a * e.x + (n.x + s * r.x)) / 2,\n              y: (t.y + a * e.y + (n.y + s * r.y)) / 2\n            };\n          }(i, this.vector(), s, t.vector());\n          return null === p ? null : Nu(r, p) ? Ru.round(p.x, p.y) : null;\n        }\n      }, {\n        key: \"split\",\n        value: function value(e) {\n          var n = [],\n            r = void 0 !== e.events,\n            i = new Bu(e, !0),\n            o = new Bu(e, !1),\n            s = this.rightSE;\n          this.replaceRightSE(o), n.push(o), n.push(i);\n          var a = new t(i, s, this.rings.slice(), this.windings.slice());\n          return Bu.comparePoints(a.leftSE.point, a.rightSE.point) > 0 && a.swapEvents(), Bu.comparePoints(this.leftSE.point, this.rightSE.point) > 0 && this.swapEvents(), r && (i.checkForConsuming(), o.checkForConsuming()), n;\n        }\n      }, {\n        key: \"swapEvents\",\n        value: function value() {\n          var t = this.rightSE;\n          this.rightSE = this.leftSE, this.leftSE = t, this.leftSE.isLeft = !0, this.rightSE.isLeft = !1;\n          for (var e = 0, n = this.windings.length; e < n; e++) this.windings[e] *= -1;\n        }\n      }, {\n        key: \"consume\",\n        value: function value(e) {\n          for (var n = this, r = e; n.consumedBy;) n = n.consumedBy;\n          for (; r.consumedBy;) r = r.consumedBy;\n          var i = t.compare(n, r);\n          if (0 !== i) {\n            if (i > 0) {\n              var o = n;\n              n = r, r = o;\n            }\n            if (n.prev === r) {\n              var s = n;\n              n = r, r = s;\n            }\n            for (var a = 0, u = r.rings.length; a < u; a++) {\n              var l = r.rings[a],\n                c = r.windings[a],\n                h = n.rings.indexOf(l);\n              -1 === h ? (n.rings.push(l), n.windings.push(c)) : n.windings[h] += c;\n            }\n            r.rings = null, r.windings = null, r.consumedBy = n, r.leftSE.consumedBy = n.leftSE, r.rightSE.consumedBy = n.rightSE;\n          }\n        }\n      }, {\n        key: \"prevInResult\",\n        value: function value() {\n          return void 0 !== this._prevInResult || (this.prev ? this.prev.isInResult() ? this._prevInResult = this.prev : this._prevInResult = this.prev.prevInResult() : this._prevInResult = null), this._prevInResult;\n        }\n      }, {\n        key: \"beforeState\",\n        value: function value() {\n          if (void 0 !== this._beforeState) return this._beforeState;\n          if (this.prev) {\n            var t = this.prev.consumedBy || this.prev;\n            this._beforeState = t.afterState();\n          } else this._beforeState = {\n            rings: [],\n            windings: [],\n            multiPolys: []\n          };\n          return this._beforeState;\n        }\n      }, {\n        key: \"afterState\",\n        value: function value() {\n          if (void 0 !== this._afterState) return this._afterState;\n          var t = this.beforeState();\n          this._afterState = {\n            rings: t.rings.slice(0),\n            windings: t.windings.slice(0),\n            multiPolys: []\n          };\n          for (var e = this._afterState.rings, n = this._afterState.windings, r = this._afterState.multiPolys, i = 0, o = this.rings.length; i < o; i++) {\n            var s = this.rings[i],\n              a = this.windings[i],\n              u = e.indexOf(s);\n            -1 === u ? (e.push(s), n.push(a)) : n[u] += a;\n          }\n          for (var l = [], c = [], h = 0, p = e.length; h < p; h++) if (0 !== n[h]) {\n            var f = e[h],\n              g = f.poly;\n            if (-1 === c.indexOf(g)) if (f.isExterior) l.push(g);else {\n              -1 === c.indexOf(g) && c.push(g);\n              var d = l.indexOf(f.poly);\n              -1 !== d && l.splice(d, 1);\n            }\n          }\n          for (var y = 0, v = l.length; y < v; y++) {\n            var _ = l[y].multiPoly;\n            -1 === r.indexOf(_) && r.push(_);\n          }\n          return this._afterState;\n        }\n      }, {\n        key: \"isInResult\",\n        value: function value() {\n          if (this.consumedBy) return !1;\n          if (void 0 !== this._isInResult) return this._isInResult;\n          var t = this.beforeState().multiPolys,\n            e = this.afterState().multiPolys;\n          switch (Qu.type) {\n            case \"union\":\n              var n = 0 === t.length,\n                r = 0 === e.length;\n              this._isInResult = n !== r;\n              break;\n            case \"intersection\":\n              var i, o;\n              t.length < e.length ? (i = t.length, o = e.length) : (i = e.length, o = t.length), this._isInResult = o === Qu.numMultiPolys && i < o;\n              break;\n            case \"xor\":\n              var s = Math.abs(t.length - e.length);\n              this._isInResult = s % 2 == 1;\n              break;\n            case \"difference\":\n              var a = function a(t) {\n                return 1 === t.length && t[0].isSubject;\n              };\n              this._isInResult = a(t) !== a(e);\n              break;\n            default:\n              throw new Error(\"Unrecognized operation type found \".concat(Qu.type));\n          }\n          return this._isInResult;\n        }\n      }], [{\n        key: \"fromRing\",\n        value: function value(e, n, r) {\n          var i,\n            o,\n            s,\n            a = Bu.comparePoints(e, n);\n          if (a < 0) i = e, o = n, s = 1;else {\n            if (!(a > 0)) throw new Error(\"Tried to create degenerate segment at [\".concat(e.x, \", \").concat(e.y, \"]\"));\n            i = n, o = e, s = -1;\n          }\n          return new t(new Bu(i, !0), new Bu(o, !1), [r], [s]);\n        }\n      }]), t;\n    }(),\n    Uu = function () {\n      function t(e, n, r) {\n        if (bu(this, t), !Array.isArray(e) || 0 === e.length) throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n        if (this.poly = n, this.isExterior = r, this.segments = [], \"number\" != typeof e[0][0] || \"number\" != typeof e[0][1]) throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n        var i = Ru.round(e[0][0], e[0][1]);\n        this.bbox = {\n          ll: {\n            x: i.x,\n            y: i.y\n          },\n          ur: {\n            x: i.x,\n            y: i.y\n          }\n        };\n        for (var o = i, s = 1, a = e.length; s < a; s++) {\n          if (\"number\" != typeof e[s][0] || \"number\" != typeof e[s][1]) throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n          var u = Ru.round(e[s][0], e[s][1]);\n          u.x === o.x && u.y === o.y || (this.segments.push(ju.fromRing(o, u, this)), u.x < this.bbox.ll.x && (this.bbox.ll.x = u.x), u.y < this.bbox.ll.y && (this.bbox.ll.y = u.y), u.x > this.bbox.ur.x && (this.bbox.ur.x = u.x), u.y > this.bbox.ur.y && (this.bbox.ur.y = u.y), o = u);\n        }\n        i.x === o.x && i.y === o.y || this.segments.push(ju.fromRing(o, i, this));\n      }\n      return Iu(t, [{\n        key: \"getSweepEvents\",\n        value: function value() {\n          for (var t = [], e = 0, n = this.segments.length; e < n; e++) {\n            var r = this.segments[e];\n            t.push(r.leftSE), t.push(r.rightSE);\n          }\n          return t;\n        }\n      }]), t;\n    }(),\n    Vu = function () {\n      function t(e, n) {\n        if (bu(this, t), !Array.isArray(e)) throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n        this.exteriorRing = new Uu(e[0], this, !0), this.bbox = {\n          ll: {\n            x: this.exteriorRing.bbox.ll.x,\n            y: this.exteriorRing.bbox.ll.y\n          },\n          ur: {\n            x: this.exteriorRing.bbox.ur.x,\n            y: this.exteriorRing.bbox.ur.y\n          }\n        }, this.interiorRings = [];\n        for (var r = 1, i = e.length; r < i; r++) {\n          var o = new Uu(e[r], this, !1);\n          o.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = o.bbox.ll.x), o.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = o.bbox.ll.y), o.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = o.bbox.ur.x), o.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = o.bbox.ur.y), this.interiorRings.push(o);\n        }\n        this.multiPoly = n;\n      }\n      return Iu(t, [{\n        key: \"getSweepEvents\",\n        value: function value() {\n          for (var t = this.exteriorRing.getSweepEvents(), e = 0, n = this.interiorRings.length; e < n; e++) for (var r = this.interiorRings[e].getSweepEvents(), i = 0, o = r.length; i < o; i++) t.push(r[i]);\n          return t;\n        }\n      }]), t;\n    }(),\n    Xu = function () {\n      function t(e, n) {\n        if (bu(this, t), !Array.isArray(e)) throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n        try {\n          \"number\" == typeof e[0][0][0] && (e = [e]);\n        } catch (t) {}\n        this.polys = [], this.bbox = {\n          ll: {\n            x: Number.POSITIVE_INFINITY,\n            y: Number.POSITIVE_INFINITY\n          },\n          ur: {\n            x: Number.NEGATIVE_INFINITY,\n            y: Number.NEGATIVE_INFINITY\n          }\n        };\n        for (var r = 0, i = e.length; r < i; r++) {\n          var o = new Vu(e[r], this);\n          o.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = o.bbox.ll.x), o.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = o.bbox.ll.y), o.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = o.bbox.ur.x), o.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = o.bbox.ur.y), this.polys.push(o);\n        }\n        this.isSubject = n;\n      }\n      return Iu(t, [{\n        key: \"getSweepEvents\",\n        value: function value() {\n          for (var t = [], e = 0, n = this.polys.length; e < n; e++) for (var r = this.polys[e].getSweepEvents(), i = 0, o = r.length; i < o; i++) t.push(r[i]);\n          return t;\n        }\n      }]), t;\n    }(),\n    Yu = function () {\n      function t(e) {\n        bu(this, t), this.events = e;\n        for (var n = 0, r = e.length; n < r; n++) e[n].segment.ringOut = this;\n        this.poly = null;\n      }\n      return Iu(t, null, [{\n        key: \"factory\",\n        value: function value(e) {\n          for (var n = [], r = 0, i = e.length; r < i; r++) {\n            var o = e[r];\n            if (o.isInResult() && !o.ringOut) {\n              for (var s = null, a = o.leftSE, u = o.rightSE, l = [a], c = a.point, h = []; s = a, a = u, l.push(a), a.point !== c;) for (;;) {\n                var p = a.getAvailableLinkedEvents();\n                if (0 === p.length) {\n                  var f = l[0].point,\n                    g = l[l.length - 1].point;\n                  throw new Error(\"Unable to complete output ring starting at [\".concat(f.x, \",\") + \" \".concat(f.y, \"]. Last matching segment found ends at\") + \" [\".concat(g.x, \", \").concat(g.y, \"].\"));\n                }\n                if (1 === p.length) {\n                  u = p[0].otherSE;\n                  break;\n                }\n                for (var d = null, y = 0, v = h.length; y < v; y++) if (h[y].point === a.point) {\n                  d = y;\n                  break;\n                }\n                if (null === d) {\n                  h.push({\n                    index: l.length,\n                    point: a.point\n                  });\n                  var _ = a.getLeftmostComparator(s);\n                  u = p.sort(_)[0].otherSE;\n                  break;\n                }\n                var m = h.splice(d)[0],\n                  x = l.splice(m.index);\n                x.unshift(x[0].otherSE), n.push(new t(x.reverse()));\n              }\n              n.push(new t(l));\n            }\n          }\n          return n;\n        }\n      }]), Iu(t, [{\n        key: \"getGeom\",\n        value: function value() {\n          for (var t = this.events[0].point, e = [t], n = 1, r = this.events.length - 1; n < r; n++) {\n            var i = this.events[n].point,\n              o = this.events[n + 1].point;\n            0 !== Du(i, t, o) && (e.push(i), t = i);\n          }\n          if (1 === e.length) return null;\n          var s = e[0],\n            a = e[1];\n          0 === Du(s, t, a) && e.shift(), e.push(e[0]);\n          for (var u = this.isExteriorRing() ? 1 : -1, l = this.isExteriorRing() ? 0 : e.length - 1, c = this.isExteriorRing() ? e.length : -1, h = [], p = l; p != c; p += u) h.push([e[p].x, e[p].y]);\n          return h;\n        }\n      }, {\n        key: \"isExteriorRing\",\n        value: function value() {\n          if (void 0 === this._isExteriorRing) {\n            var t = this.enclosingRing();\n            this._isExteriorRing = !t || !t.isExteriorRing();\n          }\n          return this._isExteriorRing;\n        }\n      }, {\n        key: \"enclosingRing\",\n        value: function value() {\n          return void 0 === this._enclosingRing && (this._enclosingRing = this._calcEnclosingRing()), this._enclosingRing;\n        }\n      }, {\n        key: \"_calcEnclosingRing\",\n        value: function value() {\n          for (var t = this.events[0], e = 1, n = this.events.length; e < n; e++) {\n            var r = this.events[e];\n            Bu.compare(t, r) > 0 && (t = r);\n          }\n          for (var i = t.segment.prevInResult(), o = i ? i.prevInResult() : null;;) {\n            if (!i) return null;\n            if (!o) return i.ringOut;\n            if (o.ringOut !== i.ringOut) return o.ringOut.enclosingRing() !== i.ringOut ? i.ringOut : i.ringOut.enclosingRing();\n            i = o.prevInResult(), o = i ? i.prevInResult() : null;\n          }\n        }\n      }]), t;\n    }(),\n    Hu = function () {\n      function t(e) {\n        bu(this, t), this.exteriorRing = e, e.poly = this, this.interiorRings = [];\n      }\n      return Iu(t, [{\n        key: \"addInterior\",\n        value: function value(t) {\n          this.interiorRings.push(t), t.poly = this;\n        }\n      }, {\n        key: \"getGeom\",\n        value: function value() {\n          var t = [this.exteriorRing.getGeom()];\n          if (null === t[0]) return null;\n          for (var e = 0, n = this.interiorRings.length; e < n; e++) {\n            var r = this.interiorRings[e].getGeom();\n            null !== r && t.push(r);\n          }\n          return t;\n        }\n      }]), t;\n    }(),\n    Wu = function () {\n      function t(e) {\n        bu(this, t), this.rings = e, this.polys = this._composePolys(e);\n      }\n      return Iu(t, [{\n        key: \"getGeom\",\n        value: function value() {\n          for (var t = [], e = 0, n = this.polys.length; e < n; e++) {\n            var r = this.polys[e].getGeom();\n            null !== r && t.push(r);\n          }\n          return t;\n        }\n      }, {\n        key: \"_composePolys\",\n        value: function value(t) {\n          for (var e = [], n = 0, r = t.length; n < r; n++) {\n            var i = t[n];\n            if (!i.poly) if (i.isExteriorRing()) e.push(new Hu(i));else {\n              var o = i.enclosingRing();\n              o.poly || e.push(new Hu(o)), o.poly.addInterior(i);\n            }\n          }\n          return e;\n        }\n      }]), t;\n    }(),\n    Ju = function () {\n      function t(e) {\n        var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ju.compare;\n        bu(this, t), this.queue = e, this.tree = new _u(n), this.segments = [];\n      }\n      return Iu(t, [{\n        key: \"process\",\n        value: function value(t) {\n          var e = t.segment,\n            n = [];\n          if (t.consumedBy) return t.isLeft ? this.queue.remove(t.otherSE) : this.tree.remove(e), n;\n          var r = t.isLeft ? this.tree.insert(e) : this.tree.find(e);\n          if (!r) throw new Error(\"Unable to find segment #\".concat(e.id, \" \") + \"[\".concat(e.leftSE.point.x, \", \").concat(e.leftSE.point.y, \"] -> \") + \"[\".concat(e.rightSE.point.x, \", \").concat(e.rightSE.point.y, \"] \") + \"in SweepLine tree. Please submit a bug report.\");\n          for (var i = r, o = r, s = void 0, a = void 0; void 0 === s;) null === (i = this.tree.prev(i)) ? s = null : void 0 === i.key.consumedBy && (s = i.key);\n          for (; void 0 === a;) null === (o = this.tree.next(o)) ? a = null : void 0 === o.key.consumedBy && (a = o.key);\n          if (t.isLeft) {\n            var u = null;\n            if (s) {\n              var l = s.getIntersection(e);\n              if (null !== l && (e.isAnEndpoint(l) || (u = l), !s.isAnEndpoint(l))) for (var c = this._splitSafely(s, l), h = 0, p = c.length; h < p; h++) n.push(c[h]);\n            }\n            var f = null;\n            if (a) {\n              var g = a.getIntersection(e);\n              if (null !== g && (e.isAnEndpoint(g) || (f = g), !a.isAnEndpoint(g))) for (var d = this._splitSafely(a, g), y = 0, v = d.length; y < v; y++) n.push(d[y]);\n            }\n            if (null !== u || null !== f) {\n              var _ = null;\n              if (null === u) _ = f;else if (null === f) _ = u;else {\n                _ = Bu.comparePoints(u, f) <= 0 ? u : f;\n              }\n              this.queue.remove(e.rightSE), n.push(e.rightSE);\n              for (var m = e.split(_), x = 0, E = m.length; x < E; x++) n.push(m[x]);\n            }\n            n.length > 0 ? (this.tree.remove(e), n.push(t)) : (this.segments.push(e), e.prev = s);\n          } else {\n            if (s && a) {\n              var b = s.getIntersection(a);\n              if (null !== b) {\n                if (!s.isAnEndpoint(b)) for (var w = this._splitSafely(s, b), I = 0, N = w.length; I < N; I++) n.push(w[I]);\n                if (!a.isAnEndpoint(b)) for (var S = this._splitSafely(a, b), C = 0, P = S.length; C < P; C++) n.push(S[C]);\n              }\n            }\n            this.tree.remove(e);\n          }\n          return n;\n        }\n      }, {\n        key: \"_splitSafely\",\n        value: function value(t, e) {\n          this.tree.remove(t);\n          var n = t.rightSE;\n          this.queue.remove(n);\n          var r = t.split(e);\n          return r.push(n), void 0 === t.consumedBy && this.tree.insert(t), r;\n        }\n      }]), t;\n    }(),\n    Zu = \"undefined\" != typeof process && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6,\n    Ku = \"undefined\" != typeof process && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6,\n    Qu = new (function () {\n      function t() {\n        bu(this, t);\n      }\n      return Iu(t, [{\n        key: \"run\",\n        value: function value(t, e, n) {\n          Qu.type = t, Ru.reset();\n          for (var r = [new Xu(e, !0)], i = 0, o = n.length; i < o; i++) r.push(new Xu(n[i], !1));\n          if (Qu.numMultiPolys = r.length, \"difference\" === Qu.type) for (var s = r[0], a = 1; a < r.length;) null !== Su(r[a].bbox, s.bbox) ? a++ : r.splice(a, 1);\n          if (\"intersection\" === Qu.type) for (var u = 0, l = r.length; u < l; u++) for (var c = r[u], h = u + 1, p = r.length; h < p; h++) if (null === Su(c.bbox, r[h].bbox)) return [];\n          for (var f = new _u(Bu.compare), g = 0, d = r.length; g < d; g++) for (var y = r[g].getSweepEvents(), v = 0, _ = y.length; v < _; v++) if (f.insert(y[v]), f.size > Zu) throw new Error(\"Infinite loop when putting segment endpoints in a priority queue (queue size too big). Please file a bug report.\");\n          for (var m = new Ju(f), x = f.size, E = f.pop(); E;) {\n            var b = E.key;\n            if (f.size === x) {\n              var w = b.segment;\n              throw new Error(\"Unable to pop() \".concat(b.isLeft ? \"left\" : \"right\", \" SweepEvent \") + \"[\".concat(b.point.x, \", \").concat(b.point.y, \"] from segment #\").concat(w.id, \" \") + \"[\".concat(w.leftSE.point.x, \", \").concat(w.leftSE.point.y, \"] -> \") + \"[\".concat(w.rightSE.point.x, \", \").concat(w.rightSE.point.y, \"] from queue. \") + \"Please file a bug report.\");\n            }\n            if (f.size > Zu) throw new Error(\"Infinite loop when passing sweep line over endpoints (queue size too big). Please file a bug report.\");\n            if (m.segments.length > Ku) throw new Error(\"Infinite loop when passing sweep line over endpoints (too many sweep line segments). Please file a bug report.\");\n            for (var I = m.process(b), N = 0, S = I.length; N < S; N++) {\n              var C = I[N];\n              void 0 === C.consumedBy && f.insert(C);\n            }\n            x = f.size, E = f.pop();\n          }\n          Ru.reset();\n          var P = Yu.factory(m.segments);\n          return new Wu(P).getGeom();\n        }\n      }]), t;\n    }())(),\n    $u = {\n      union: function union(t) {\n        for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];\n        return Qu.run(\"union\", t, n);\n      },\n      intersection: function intersection(t) {\n        for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];\n        return Qu.run(\"intersection\", t, n);\n      },\n      xor: function xor(t) {\n        for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];\n        return Qu.run(\"xor\", t, n);\n      },\n      difference: function difference(t) {\n        for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];\n        return Qu.run(\"difference\", t, n);\n      }\n    };\n  \"fill\" in Array.prototype || Object.defineProperty(Array.prototype, \"fill\", {\n    configurable: !0,\n    value: function value(t) {\n      if (null == this) throw new TypeError(this + \" is not an object\");\n      var e = Object(this),\n        n = Math.max(Math.min(e.length, 9007199254740991), 0) || 0,\n        r = 1 in arguments && parseInt(Number(arguments[1]), 10) || 0;\n      r = r < 0 ? Math.max(n + r, 0) : Math.min(r, n);\n      var i = 2 in arguments && void 0 !== arguments[2] ? parseInt(Number(arguments[2]), 10) || 0 : n;\n      for (i = i < 0 ? Math.max(n + arguments[2], 0) : Math.min(i, n); r < i;) e[r] = t, ++r;\n      return e;\n    },\n    writable: !0\n  }), Number.isFinite = Number.isFinite || function (t) {\n    return \"number\" == typeof t && isFinite(t);\n  }, Number.isInteger = Number.isInteger || function (t) {\n    return \"number\" == typeof t && isFinite(t) && Math.floor(t) === t;\n  }, Number.parseFloat = Number.parseFloat || parseFloat, Number.isNaN = Number.isNaN || function (t) {\n    return t != t;\n  }, Math.trunc = Math.trunc || function (t) {\n    return t < 0 ? Math.ceil(t) : Math.floor(t);\n  };\n  var tl = function tl() {};\n  tl.prototype.interfaces_ = function () {\n    return [];\n  }, tl.prototype.getClass = function () {\n    return tl;\n  }, tl.prototype.equalsWithTolerance = function (t, e, n) {\n    return Math.abs(t - e) <= n;\n  };\n  var el = function (t) {\n      function e(e) {\n        t.call(this, e), this.name = \"IllegalArgumentException\", this.message = e, this.stack = new t().stack;\n      }\n      return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e;\n    }(Error),\n    nl = function nl() {},\n    rl = {\n      MAX_VALUE: {\n        configurable: !0\n      }\n    };\n  nl.isNaN = function (t) {\n    return Number.isNaN(t);\n  }, nl.doubleToLongBits = function (t) {\n    return t;\n  }, nl.longBitsToDouble = function (t) {\n    return t;\n  }, nl.isInfinite = function (t) {\n    return !Number.isFinite(t);\n  }, rl.MAX_VALUE.get = function () {\n    return Number.MAX_VALUE;\n  }, Object.defineProperties(nl, rl);\n  var il = function il() {},\n    ol = function ol() {},\n    sl = function sl() {};\n  function al() {}\n  var ul = function t() {\n      if (this.x = null, this.y = null, this.z = null, 0 === arguments.length) this.x = 0, this.y = 0, this.z = t.NULL_ORDINATE;else if (1 === arguments.length) {\n        var e = arguments[0];\n        this.x = e.x, this.y = e.y, this.z = e.z;\n      } else 2 === arguments.length ? (this.x = arguments[0], this.y = arguments[1], this.z = t.NULL_ORDINATE) : 3 === arguments.length && (this.x = arguments[0], this.y = arguments[1], this.z = arguments[2]);\n    },\n    ll = {\n      DimensionalComparator: {\n        configurable: !0\n      },\n      serialVersionUID: {\n        configurable: !0\n      },\n      NULL_ORDINATE: {\n        configurable: !0\n      },\n      X: {\n        configurable: !0\n      },\n      Y: {\n        configurable: !0\n      },\n      Z: {\n        configurable: !0\n      }\n    };\n  ul.prototype.setOrdinate = function (t, e) {\n    switch (t) {\n      case ul.X:\n        this.x = e;\n        break;\n      case ul.Y:\n        this.y = e;\n        break;\n      case ul.Z:\n        this.z = e;\n        break;\n      default:\n        throw new el(\"Invalid ordinate index: \" + t);\n    }\n  }, ul.prototype.equals2D = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return this.x === t.x && this.y === t.y;\n    }\n    if (2 === arguments.length) {\n      var e = arguments[0],\n        n = arguments[1];\n      return !!tl.equalsWithTolerance(this.x, e.x, n) && !!tl.equalsWithTolerance(this.y, e.y, n);\n    }\n  }, ul.prototype.getOrdinate = function (t) {\n    switch (t) {\n      case ul.X:\n        return this.x;\n      case ul.Y:\n        return this.y;\n      case ul.Z:\n        return this.z;\n    }\n    throw new el(\"Invalid ordinate index: \" + t);\n  }, ul.prototype.equals3D = function (t) {\n    return this.x === t.x && this.y === t.y && (this.z === t.z || nl.isNaN(this.z)) && nl.isNaN(t.z);\n  }, ul.prototype.equals = function (t) {\n    return t instanceof ul && this.equals2D(t);\n  }, ul.prototype.equalInZ = function (t, e) {\n    return tl.equalsWithTolerance(this.z, t.z, e);\n  }, ul.prototype.compareTo = function (t) {\n    var e = t;\n    return this.x < e.x ? -1 : this.x > e.x ? 1 : this.y < e.y ? -1 : this.y > e.y ? 1 : 0;\n  }, ul.prototype.clone = function () {}, ul.prototype.copy = function () {\n    return new ul(this);\n  }, ul.prototype.toString = function () {\n    return \"(\" + this.x + \", \" + this.y + \", \" + this.z + \")\";\n  }, ul.prototype.distance3D = function (t) {\n    var e = this.x - t.x,\n      n = this.y - t.y,\n      r = this.z - t.z;\n    return Math.sqrt(e * e + n * n + r * r);\n  }, ul.prototype.distance = function (t) {\n    var e = this.x - t.x,\n      n = this.y - t.y;\n    return Math.sqrt(e * e + n * n);\n  }, ul.prototype.hashCode = function () {\n    var t = 17;\n    return t = 37 * (t = 37 * t + ul.hashCode(this.x)) + ul.hashCode(this.y);\n  }, ul.prototype.setCoordinate = function (t) {\n    this.x = t.x, this.y = t.y, this.z = t.z;\n  }, ul.prototype.interfaces_ = function () {\n    return [il, ol, al];\n  }, ul.prototype.getClass = function () {\n    return ul;\n  }, ul.hashCode = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0],\n        e = nl.doubleToLongBits(t);\n      return Math.trunc((e ^ e) >>> 32);\n    }\n  }, ll.DimensionalComparator.get = function () {\n    return cl;\n  }, ll.serialVersionUID.get = function () {\n    return 0x5cbf2c235c7e5800;\n  }, ll.NULL_ORDINATE.get = function () {\n    return nl.NaN;\n  }, ll.X.get = function () {\n    return 0;\n  }, ll.Y.get = function () {\n    return 1;\n  }, ll.Z.get = function () {\n    return 2;\n  }, Object.defineProperties(ul, ll);\n  var cl = function cl(t) {\n    if (this._dimensionsToTest = 2, 0 === arguments.length) ;else if (1 === arguments.length) {\n      var e = arguments[0];\n      if (2 !== e && 3 !== e) throw new el(\"only 2 or 3 dimensions may be specified\");\n      this._dimensionsToTest = e;\n    }\n  };\n  cl.prototype.compare = function (t, e) {\n    var n = t,\n      r = e,\n      i = cl.compare(n.x, r.x);\n    if (0 !== i) return i;\n    var o = cl.compare(n.y, r.y);\n    return 0 !== o ? o : this._dimensionsToTest <= 2 ? 0 : cl.compare(n.z, r.z);\n  }, cl.prototype.interfaces_ = function () {\n    return [sl];\n  }, cl.prototype.getClass = function () {\n    return cl;\n  }, cl.compare = function (t, e) {\n    return t < e ? -1 : t > e ? 1 : nl.isNaN(t) ? nl.isNaN(e) ? 0 : -1 : nl.isNaN(e) ? 1 : 0;\n  };\n  var hl = function hl() {};\n  hl.prototype.create = function () {}, hl.prototype.interfaces_ = function () {\n    return [];\n  }, hl.prototype.getClass = function () {\n    return hl;\n  };\n  var pl = function pl() {},\n    fl = {\n      INTERIOR: {\n        configurable: !0\n      },\n      BOUNDARY: {\n        configurable: !0\n      },\n      EXTERIOR: {\n        configurable: !0\n      },\n      NONE: {\n        configurable: !0\n      }\n    };\n  pl.prototype.interfaces_ = function () {\n    return [];\n  }, pl.prototype.getClass = function () {\n    return pl;\n  }, pl.toLocationSymbol = function (t) {\n    switch (t) {\n      case pl.EXTERIOR:\n        return \"e\";\n      case pl.BOUNDARY:\n        return \"b\";\n      case pl.INTERIOR:\n        return \"i\";\n      case pl.NONE:\n        return \"-\";\n    }\n    throw new el(\"Unknown location value: \" + t);\n  }, fl.INTERIOR.get = function () {\n    return 0;\n  }, fl.BOUNDARY.get = function () {\n    return 1;\n  }, fl.EXTERIOR.get = function () {\n    return 2;\n  }, fl.NONE.get = function () {\n    return -1;\n  }, Object.defineProperties(pl, fl);\n  var gl = function gl(t, e) {\n      return t.interfaces_ && t.interfaces_().indexOf(e) > -1;\n    },\n    dl = function dl() {},\n    yl = {\n      LOG_10: {\n        configurable: !0\n      }\n    };\n  dl.prototype.interfaces_ = function () {\n    return [];\n  }, dl.prototype.getClass = function () {\n    return dl;\n  }, dl.log10 = function (t) {\n    var e = Math.log(t);\n    return nl.isInfinite(e) || nl.isNaN(e) ? e : e / dl.LOG_10;\n  }, dl.min = function (t, e, n, r) {\n    var i = t;\n    return e < i && (i = e), n < i && (i = n), r < i && (i = r), i;\n  }, dl.clamp = function () {\n    if (\"number\" == typeof arguments[2] && \"number\" == typeof arguments[0] && \"number\" == typeof arguments[1]) {\n      var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2];\n      return t < e ? e : t > n ? n : t;\n    }\n    if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n      var r = arguments[0],\n        i = arguments[1],\n        o = arguments[2];\n      return r < i ? i : r > o ? o : r;\n    }\n  }, dl.wrap = function (t, e) {\n    return t < 0 ? e - -t % e : t % e;\n  }, dl.max = function () {\n    if (3 === arguments.length) {\n      var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2],\n        r = t;\n      return e > r && (r = e), n > r && (r = n), r;\n    }\n    if (4 === arguments.length) {\n      var i = arguments[0],\n        o = arguments[1],\n        s = arguments[2],\n        a = arguments[3],\n        u = i;\n      return o > u && (u = o), s > u && (u = s), a > u && (u = a), u;\n    }\n  }, dl.average = function (t, e) {\n    return (t + e) / 2;\n  }, yl.LOG_10.get = function () {\n    return Math.log(10);\n  }, Object.defineProperties(dl, yl);\n  var vl = function vl(t) {\n    this.str = t;\n  };\n  vl.prototype.append = function (t) {\n    this.str += t;\n  }, vl.prototype.setCharAt = function (t, e) {\n    this.str = this.str.substr(0, t) + e + this.str.substr(t + 1);\n  }, vl.prototype.toString = function (t) {\n    return this.str;\n  };\n  var _l = function _l(t) {\n    this.value = t;\n  };\n  _l.prototype.intValue = function () {\n    return this.value;\n  }, _l.prototype.compareTo = function (t) {\n    return this.value < t ? -1 : this.value > t ? 1 : 0;\n  }, _l.isNaN = function (t) {\n    return Number.isNaN(t);\n  };\n  var ml = function ml() {};\n  ml.isWhitespace = function (t) {\n    return t <= 32 && t >= 0 || 127 === t;\n  }, ml.toUpperCase = function (t) {\n    return t.toUpperCase();\n  };\n  var xl = function t() {\n      if (this._hi = 0, this._lo = 0, 0 === arguments.length) this.init(0);else if (1 === arguments.length) {\n        if (\"number\" == typeof arguments[0]) {\n          var e = arguments[0];\n          this.init(e);\n        } else if (arguments[0] instanceof t) {\n          var n = arguments[0];\n          this.init(n);\n        } else if (\"string\" == typeof arguments[0]) {\n          var r = arguments[0];\n          t.call(this, t.parse(r));\n        }\n      } else if (2 === arguments.length) {\n        var i = arguments[0],\n          o = arguments[1];\n        this.init(i, o);\n      }\n    },\n    El = {\n      PI: {\n        configurable: !0\n      },\n      TWO_PI: {\n        configurable: !0\n      },\n      PI_2: {\n        configurable: !0\n      },\n      E: {\n        configurable: !0\n      },\n      NaN: {\n        configurable: !0\n      },\n      EPS: {\n        configurable: !0\n      },\n      SPLIT: {\n        configurable: !0\n      },\n      MAX_PRINT_DIGITS: {\n        configurable: !0\n      },\n      TEN: {\n        configurable: !0\n      },\n      ONE: {\n        configurable: !0\n      },\n      SCI_NOT_EXPONENT_CHAR: {\n        configurable: !0\n      },\n      SCI_NOT_ZERO: {\n        configurable: !0\n      }\n    };\n  xl.prototype.le = function (t) {\n    return (this._hi < t._hi || this._hi === t._hi) && this._lo <= t._lo;\n  }, xl.prototype.extractSignificantDigits = function (t, e) {\n    var n = this.abs(),\n      r = xl.magnitude(n._hi),\n      i = xl.TEN.pow(r);\n    (n = n.divide(i)).gt(xl.TEN) ? (n = n.divide(xl.TEN), r += 1) : n.lt(xl.ONE) && (n = n.multiply(xl.TEN), r -= 1);\n    for (var o = r + 1, s = new vl(), a = xl.MAX_PRINT_DIGITS - 1, u = 0; u <= a; u++) {\n      t && u === o && s.append(\".\");\n      var l = Math.trunc(n._hi);\n      if (l < 0) break;\n      var c = !1,\n        h = 0;\n      l > 9 ? (c = !0, h = \"9\") : h = \"0\" + l, s.append(h), n = n.subtract(xl.valueOf(l)).multiply(xl.TEN), c && n.selfAdd(xl.TEN);\n      var p = !0,\n        f = xl.magnitude(n._hi);\n      if (f < 0 && Math.abs(f) >= a - u && (p = !1), !p) break;\n    }\n    return e[0] = r, s.toString();\n  }, xl.prototype.sqr = function () {\n    return this.multiply(this);\n  }, xl.prototype.doubleValue = function () {\n    return this._hi + this._lo;\n  }, xl.prototype.subtract = function () {\n    if (arguments[0] instanceof xl) {\n      var t = arguments[0];\n      return this.add(t.negate());\n    }\n    if (\"number\" == typeof arguments[0]) {\n      var e = arguments[0];\n      return this.add(-e);\n    }\n  }, xl.prototype.equals = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return this._hi === t._hi && this._lo === t._lo;\n    }\n  }, xl.prototype.isZero = function () {\n    return 0 === this._hi && 0 === this._lo;\n  }, xl.prototype.selfSubtract = function () {\n    if (arguments[0] instanceof xl) {\n      var t = arguments[0];\n      return this.isNaN() ? this : this.selfAdd(-t._hi, -t._lo);\n    }\n    if (\"number\" == typeof arguments[0]) {\n      var e = arguments[0];\n      return this.isNaN() ? this : this.selfAdd(-e, 0);\n    }\n  }, xl.prototype.getSpecialNumberString = function () {\n    return this.isZero() ? \"0.0\" : this.isNaN() ? \"NaN \" : null;\n  }, xl.prototype.min = function (t) {\n    return this.le(t) ? this : t;\n  }, xl.prototype.selfDivide = function () {\n    if (1 === arguments.length) {\n      if (arguments[0] instanceof xl) {\n        var t = arguments[0];\n        return this.selfDivide(t._hi, t._lo);\n      }\n      if (\"number\" == typeof arguments[0]) {\n        var e = arguments[0];\n        return this.selfDivide(e, 0);\n      }\n    } else if (2 === arguments.length) {\n      var n = arguments[0],\n        r = arguments[1],\n        i = null,\n        o = null,\n        s = null,\n        a = null,\n        u = null,\n        l = null,\n        c = null,\n        h = null;\n      return u = this._hi / n, h = (i = (l = xl.SPLIT * u) - (i = l - u)) * (s = (h = xl.SPLIT * n) - (s = h - n)) - (c = u * n) + i * (a = n - s) + (o = u - i) * s + o * a, h = u + (l = (this._hi - c - h + this._lo - u * r) / n), this._hi = h, this._lo = u - h + l, this;\n    }\n  }, xl.prototype.dump = function () {\n    return \"DD<\" + this._hi + \", \" + this._lo + \">\";\n  }, xl.prototype.divide = function () {\n    if (arguments[0] instanceof xl) {\n      var t = arguments[0],\n        e = null,\n        n = null,\n        r = null,\n        i = null,\n        o = null,\n        s = null,\n        a = null,\n        u = null;\n      n = (o = this._hi / t._hi) - (e = (s = xl.SPLIT * o) - (e = s - o)), u = e * (r = (u = xl.SPLIT * t._hi) - (r = u - t._hi)) - (a = o * t._hi) + e * (i = t._hi - r) + n * r + n * i;\n      var l = u = o + (s = (this._hi - a - u + this._lo - o * t._lo) / t._hi),\n        c = o - u + s;\n      return new xl(l, c);\n    }\n    if (\"number\" == typeof arguments[0]) {\n      var h = arguments[0];\n      return nl.isNaN(h) ? xl.createNaN() : xl.copy(this).selfDivide(h, 0);\n    }\n  }, xl.prototype.ge = function (t) {\n    return (this._hi > t._hi || this._hi === t._hi) && this._lo >= t._lo;\n  }, xl.prototype.pow = function (t) {\n    if (0 === t) return xl.valueOf(1);\n    var e = new xl(this),\n      n = xl.valueOf(1),\n      r = Math.abs(t);\n    if (r > 1) for (; r > 0;) r % 2 == 1 && n.selfMultiply(e), (r /= 2) > 0 && (e = e.sqr());else n = e;\n    return t < 0 ? n.reciprocal() : n;\n  }, xl.prototype.ceil = function () {\n    if (this.isNaN()) return xl.NaN;\n    var t = Math.ceil(this._hi),\n      e = 0;\n    return t === this._hi && (e = Math.ceil(this._lo)), new xl(t, e);\n  }, xl.prototype.compareTo = function (t) {\n    var e = t;\n    return this._hi < e._hi ? -1 : this._hi > e._hi ? 1 : this._lo < e._lo ? -1 : this._lo > e._lo ? 1 : 0;\n  }, xl.prototype.rint = function () {\n    return this.isNaN() ? this : this.add(.5).floor();\n  }, xl.prototype.setValue = function () {\n    if (arguments[0] instanceof xl) {\n      var t = arguments[0];\n      return this.init(t), this;\n    }\n    if (\"number\" == typeof arguments[0]) {\n      var e = arguments[0];\n      return this.init(e), this;\n    }\n  }, xl.prototype.max = function (t) {\n    return this.ge(t) ? this : t;\n  }, xl.prototype.sqrt = function () {\n    if (this.isZero()) return xl.valueOf(0);\n    if (this.isNegative()) return xl.NaN;\n    var t = 1 / Math.sqrt(this._hi),\n      e = this._hi * t,\n      n = xl.valueOf(e),\n      r = this.subtract(n.sqr())._hi * (.5 * t);\n    return n.add(r);\n  }, xl.prototype.selfAdd = function () {\n    if (1 === arguments.length) {\n      if (arguments[0] instanceof xl) {\n        var t = arguments[0];\n        return this.selfAdd(t._hi, t._lo);\n      }\n      if (\"number\" == typeof arguments[0]) {\n        var e = arguments[0],\n          n = null,\n          r = null,\n          i = null,\n          o = null,\n          s = null,\n          a = null;\n        return o = (i = this._hi + e) - (s = i - this._hi), r = (a = (o = e - s + (this._hi - o)) + this._lo) + (i - (n = i + a)), this._hi = n + r, this._lo = r + (n - this._hi), this;\n      }\n    } else if (2 === arguments.length) {\n      var u = arguments[0],\n        l = arguments[1],\n        c = null,\n        h = null,\n        p = null,\n        f = null,\n        g = null,\n        d = null,\n        y = null;\n      f = this._hi + u, h = this._lo + l, g = f - (d = f - this._hi), p = h - (y = h - this._lo);\n      var v = (c = f + (d = (g = u - d + (this._hi - g)) + h)) + (d = (p = l - y + (this._lo - p)) + (d + (f - c))),\n        _ = d + (c - v);\n      return this._hi = v, this._lo = _, this;\n    }\n  }, xl.prototype.selfMultiply = function () {\n    if (1 === arguments.length) {\n      if (arguments[0] instanceof xl) {\n        var t = arguments[0];\n        return this.selfMultiply(t._hi, t._lo);\n      }\n      if (\"number\" == typeof arguments[0]) {\n        var e = arguments[0];\n        return this.selfMultiply(e, 0);\n      }\n    } else if (2 === arguments.length) {\n      var n = arguments[0],\n        r = arguments[1],\n        i = null,\n        o = null,\n        s = null,\n        a = null,\n        u = null,\n        l = null;\n      i = (u = xl.SPLIT * this._hi) - this._hi, l = xl.SPLIT * n, i = u - i, o = this._hi - i, s = l - n;\n      var c = (u = this._hi * n) + (l = i * (s = l - s) - u + i * (a = n - s) + o * s + o * a + (this._hi * r + this._lo * n)),\n        h = l + (i = u - c);\n      return this._hi = c, this._lo = h, this;\n    }\n  }, xl.prototype.selfSqr = function () {\n    return this.selfMultiply(this);\n  }, xl.prototype.floor = function () {\n    if (this.isNaN()) return xl.NaN;\n    var t = Math.floor(this._hi),\n      e = 0;\n    return t === this._hi && (e = Math.floor(this._lo)), new xl(t, e);\n  }, xl.prototype.negate = function () {\n    return this.isNaN() ? this : new xl(-this._hi, -this._lo);\n  }, xl.prototype.clone = function () {}, xl.prototype.multiply = function () {\n    if (arguments[0] instanceof xl) {\n      var t = arguments[0];\n      return t.isNaN() ? xl.createNaN() : xl.copy(this).selfMultiply(t);\n    }\n    if (\"number\" == typeof arguments[0]) {\n      var e = arguments[0];\n      return nl.isNaN(e) ? xl.createNaN() : xl.copy(this).selfMultiply(e, 0);\n    }\n  }, xl.prototype.isNaN = function () {\n    return nl.isNaN(this._hi);\n  }, xl.prototype.intValue = function () {\n    return Math.trunc(this._hi);\n  }, xl.prototype.toString = function () {\n    var t = xl.magnitude(this._hi);\n    return t >= -3 && t <= 20 ? this.toStandardNotation() : this.toSciNotation();\n  }, xl.prototype.toStandardNotation = function () {\n    var t = this.getSpecialNumberString();\n    if (null !== t) return t;\n    var e = new Array(1).fill(null),\n      n = this.extractSignificantDigits(!0, e),\n      r = e[0] + 1,\n      i = n;\n    if (\".\" === n.charAt(0)) i = \"0\" + n;else if (r < 0) i = \"0.\" + xl.stringOfChar(\"0\", -r) + n;else if (-1 === n.indexOf(\".\")) {\n      var o = r - n.length;\n      i = n + xl.stringOfChar(\"0\", o) + \".0\";\n    }\n    return this.isNegative() ? \"-\" + i : i;\n  }, xl.prototype.reciprocal = function () {\n    var t,\n      e,\n      n,\n      r,\n      i = null,\n      o = null,\n      s = null,\n      a = null;\n    t = (n = 1 / this._hi) - (i = (s = xl.SPLIT * n) - (i = s - n)), o = (a = xl.SPLIT * this._hi) - this._hi;\n    var u = n + (s = (1 - (r = n * this._hi) - (a = i * (o = a - o) - r + i * (e = this._hi - o) + t * o + t * e) - n * this._lo) / this._hi);\n    return new xl(u, n - u + s);\n  }, xl.prototype.toSciNotation = function () {\n    if (this.isZero()) return xl.SCI_NOT_ZERO;\n    var t = this.getSpecialNumberString();\n    if (null !== t) return t;\n    var e = new Array(1).fill(null),\n      n = this.extractSignificantDigits(!1, e),\n      r = xl.SCI_NOT_EXPONENT_CHAR + e[0];\n    if (\"0\" === n.charAt(0)) throw new Error(\"Found leading zero: \" + n);\n    var i = \"\";\n    n.length > 1 && (i = n.substring(1));\n    var o = n.charAt(0) + \".\" + i;\n    return this.isNegative() ? \"-\" + o + r : o + r;\n  }, xl.prototype.abs = function () {\n    return this.isNaN() ? xl.NaN : this.isNegative() ? this.negate() : new xl(this);\n  }, xl.prototype.isPositive = function () {\n    return (this._hi > 0 || 0 === this._hi) && this._lo > 0;\n  }, xl.prototype.lt = function (t) {\n    return (this._hi < t._hi || this._hi === t._hi) && this._lo < t._lo;\n  }, xl.prototype.add = function () {\n    if (arguments[0] instanceof xl) {\n      var t = arguments[0];\n      return xl.copy(this).selfAdd(t);\n    }\n    if (\"number\" == typeof arguments[0]) {\n      var e = arguments[0];\n      return xl.copy(this).selfAdd(e);\n    }\n  }, xl.prototype.init = function () {\n    if (1 === arguments.length) {\n      if (\"number\" == typeof arguments[0]) {\n        var t = arguments[0];\n        this._hi = t, this._lo = 0;\n      } else if (arguments[0] instanceof xl) {\n        var e = arguments[0];\n        this._hi = e._hi, this._lo = e._lo;\n      }\n    } else if (2 === arguments.length) {\n      var n = arguments[0],\n        r = arguments[1];\n      this._hi = n, this._lo = r;\n    }\n  }, xl.prototype.gt = function (t) {\n    return (this._hi > t._hi || this._hi === t._hi) && this._lo > t._lo;\n  }, xl.prototype.isNegative = function () {\n    return (this._hi < 0 || 0 === this._hi) && this._lo < 0;\n  }, xl.prototype.trunc = function () {\n    return this.isNaN() ? xl.NaN : this.isPositive() ? this.floor() : this.ceil();\n  }, xl.prototype.signum = function () {\n    return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0;\n  }, xl.prototype.interfaces_ = function () {\n    return [al, il, ol];\n  }, xl.prototype.getClass = function () {\n    return xl;\n  }, xl.sqr = function (t) {\n    return xl.valueOf(t).selfMultiply(t);\n  }, xl.valueOf = function () {\n    if (\"string\" == typeof arguments[0]) {\n      var t = arguments[0];\n      return xl.parse(t);\n    }\n    if (\"number\" == typeof arguments[0]) {\n      var e = arguments[0];\n      return new xl(e);\n    }\n  }, xl.sqrt = function (t) {\n    return xl.valueOf(t).sqrt();\n  }, xl.parse = function (t) {\n    for (var e = 0, n = t.length; ml.isWhitespace(t.charAt(e));) e++;\n    var r = !1;\n    if (e < n) {\n      var i = t.charAt(e);\n      \"-\" !== i && \"+\" !== i || (e++, \"-\" === i && (r = !0));\n    }\n    for (var o = new xl(), s = 0, a = 0, u = 0; !(e >= n);) {\n      var l = t.charAt(e);\n      if (e++, ml.isDigit(l)) {\n        var c = l - \"0\";\n        o.selfMultiply(xl.TEN), o.selfAdd(c), s++;\n      } else {\n        if (\".\" !== l) {\n          if (\"e\" === l || \"E\" === l) {\n            var h = t.substring(e);\n            try {\n              u = _l.parseInt(h);\n            } catch (e) {\n              throw e instanceof Error ? new Error(\"Invalid exponent \" + h + \" in string \" + t) : e;\n            }\n            break;\n          }\n          throw new Error(\"Unexpected character '\" + l + \"' at position \" + e + \" in string \" + t);\n        }\n        a = s;\n      }\n    }\n    var p = o,\n      f = s - a - u;\n    if (0 === f) p = o;else if (f > 0) {\n      var g = xl.TEN.pow(f);\n      p = o.divide(g);\n    } else if (f < 0) {\n      var d = xl.TEN.pow(-f);\n      p = o.multiply(d);\n    }\n    return r ? p.negate() : p;\n  }, xl.createNaN = function () {\n    return new xl(nl.NaN, nl.NaN);\n  }, xl.copy = function (t) {\n    return new xl(t);\n  }, xl.magnitude = function (t) {\n    var e = Math.abs(t),\n      n = Math.log(e) / Math.log(10),\n      r = Math.trunc(Math.floor(n));\n    return 10 * Math.pow(10, r) <= e && (r += 1), r;\n  }, xl.stringOfChar = function (t, e) {\n    for (var n = new vl(), r = 0; r < e; r++) n.append(t);\n    return n.toString();\n  }, El.PI.get = function () {\n    return new xl(3.141592653589793, 12246467991473532e-32);\n  }, El.TWO_PI.get = function () {\n    return new xl(6.283185307179586, 24492935982947064e-32);\n  }, El.PI_2.get = function () {\n    return new xl(1.5707963267948966, 6123233995736766e-32);\n  }, El.E.get = function () {\n    return new xl(2.718281828459045, 14456468917292502e-32);\n  }, El.NaN.get = function () {\n    return new xl(nl.NaN, nl.NaN);\n  }, El.EPS.get = function () {\n    return 123259516440783e-46;\n  }, El.SPLIT.get = function () {\n    return 134217729;\n  }, El.MAX_PRINT_DIGITS.get = function () {\n    return 32;\n  }, El.TEN.get = function () {\n    return xl.valueOf(10);\n  }, El.ONE.get = function () {\n    return xl.valueOf(1);\n  }, El.SCI_NOT_EXPONENT_CHAR.get = function () {\n    return \"E\";\n  }, El.SCI_NOT_ZERO.get = function () {\n    return \"0.0E0\";\n  }, Object.defineProperties(xl, El);\n  var bl = function bl() {},\n    wl = {\n      DP_SAFE_EPSILON: {\n        configurable: !0\n      }\n    };\n  bl.prototype.interfaces_ = function () {\n    return [];\n  }, bl.prototype.getClass = function () {\n    return bl;\n  }, bl.orientationIndex = function (t, e, n) {\n    var r = bl.orientationIndexFilter(t, e, n);\n    if (r <= 1) return r;\n    var i = xl.valueOf(e.x).selfAdd(-t.x),\n      o = xl.valueOf(e.y).selfAdd(-t.y),\n      s = xl.valueOf(n.x).selfAdd(-e.x),\n      a = xl.valueOf(n.y).selfAdd(-e.y);\n    return i.selfMultiply(a).selfSubtract(o.selfMultiply(s)).signum();\n  }, bl.signOfDet2x2 = function (t, e, n, r) {\n    return t.multiply(r).selfSubtract(e.multiply(n)).signum();\n  }, bl.intersection = function (t, e, n, r) {\n    var i = xl.valueOf(r.y).selfSubtract(n.y).selfMultiply(xl.valueOf(e.x).selfSubtract(t.x)),\n      o = xl.valueOf(r.x).selfSubtract(n.x).selfMultiply(xl.valueOf(e.y).selfSubtract(t.y)),\n      s = i.subtract(o),\n      a = xl.valueOf(r.x).selfSubtract(n.x).selfMultiply(xl.valueOf(t.y).selfSubtract(n.y)),\n      u = xl.valueOf(r.y).selfSubtract(n.y).selfMultiply(xl.valueOf(t.x).selfSubtract(n.x)),\n      l = a.subtract(u).selfDivide(s).doubleValue(),\n      c = xl.valueOf(t.x).selfAdd(xl.valueOf(e.x).selfSubtract(t.x).selfMultiply(l)).doubleValue(),\n      h = xl.valueOf(e.x).selfSubtract(t.x).selfMultiply(xl.valueOf(t.y).selfSubtract(n.y)),\n      p = xl.valueOf(e.y).selfSubtract(t.y).selfMultiply(xl.valueOf(t.x).selfSubtract(n.x)),\n      f = h.subtract(p).selfDivide(s).doubleValue(),\n      g = xl.valueOf(n.y).selfAdd(xl.valueOf(r.y).selfSubtract(n.y).selfMultiply(f)).doubleValue();\n    return new ul(c, g);\n  }, bl.orientationIndexFilter = function (t, e, n) {\n    var r = null,\n      i = (t.x - n.x) * (e.y - n.y),\n      o = (t.y - n.y) * (e.x - n.x),\n      s = i - o;\n    if (i > 0) {\n      if (o <= 0) return bl.signum(s);\n      r = i + o;\n    } else {\n      if (!(i < 0)) return bl.signum(s);\n      if (o >= 0) return bl.signum(s);\n      r = -i - o;\n    }\n    var a = bl.DP_SAFE_EPSILON * r;\n    return s >= a || -s >= a ? bl.signum(s) : 2;\n  }, bl.signum = function (t) {\n    return t > 0 ? 1 : t < 0 ? -1 : 0;\n  }, wl.DP_SAFE_EPSILON.get = function () {\n    return 1e-15;\n  }, Object.defineProperties(bl, wl);\n  var Il = function Il() {},\n    Nl = {\n      X: {\n        configurable: !0\n      },\n      Y: {\n        configurable: !0\n      },\n      Z: {\n        configurable: !0\n      },\n      M: {\n        configurable: !0\n      }\n    };\n  Nl.X.get = function () {\n    return 0;\n  }, Nl.Y.get = function () {\n    return 1;\n  }, Nl.Z.get = function () {\n    return 2;\n  }, Nl.M.get = function () {\n    return 3;\n  }, Il.prototype.setOrdinate = function (t, e, n) {}, Il.prototype.size = function () {}, Il.prototype.getOrdinate = function (t, e) {}, Il.prototype.getCoordinate = function () {}, Il.prototype.getCoordinateCopy = function (t) {}, Il.prototype.getDimension = function () {}, Il.prototype.getX = function (t) {}, Il.prototype.clone = function () {}, Il.prototype.expandEnvelope = function (t) {}, Il.prototype.copy = function () {}, Il.prototype.getY = function (t) {}, Il.prototype.toCoordinateArray = function () {}, Il.prototype.interfaces_ = function () {\n    return [ol];\n  }, Il.prototype.getClass = function () {\n    return Il;\n  }, Object.defineProperties(Il, Nl);\n  var Sl = function Sl() {},\n    Cl = function (t) {\n      function e() {\n        t.call(this, \"Projective point not representable on the Cartesian plane.\");\n      }\n      return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.interfaces_ = function () {\n        return [];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, e;\n    }(Sl),\n    Pl = function Pl() {};\n  Pl.arraycopy = function (t, e, n, r, i) {\n    for (var o = 0, s = e; s < e + i; s++) n[r + o] = t[s], o++;\n  }, Pl.getProperty = function (t) {\n    return {\n      \"line.separator\": \"\\n\"\n    }[t];\n  };\n  var Ml = function t() {\n    if (this.x = null, this.y = null, this.w = null, 0 === arguments.length) this.x = 0, this.y = 0, this.w = 1;else if (1 === arguments.length) {\n      var e = arguments[0];\n      this.x = e.x, this.y = e.y, this.w = 1;\n    } else if (2 === arguments.length) {\n      if (\"number\" == typeof arguments[0] && \"number\" == typeof arguments[1]) {\n        var n = arguments[0],\n          r = arguments[1];\n        this.x = n, this.y = r, this.w = 1;\n      } else if (arguments[0] instanceof t && arguments[1] instanceof t) {\n        var i = arguments[0],\n          o = arguments[1];\n        this.x = i.y * o.w - o.y * i.w, this.y = o.x * i.w - i.x * o.w, this.w = i.x * o.y - o.x * i.y;\n      } else if (arguments[0] instanceof ul && arguments[1] instanceof ul) {\n        var s = arguments[0],\n          a = arguments[1];\n        this.x = s.y - a.y, this.y = a.x - s.x, this.w = s.x * a.y - a.x * s.y;\n      }\n    } else if (3 === arguments.length) {\n      var u = arguments[0],\n        l = arguments[1],\n        c = arguments[2];\n      this.x = u, this.y = l, this.w = c;\n    } else if (4 === arguments.length) {\n      var h = arguments[0],\n        p = arguments[1],\n        f = arguments[2],\n        g = arguments[3],\n        d = h.y - p.y,\n        y = p.x - h.x,\n        v = h.x * p.y - p.x * h.y,\n        _ = f.y - g.y,\n        m = g.x - f.x,\n        x = f.x * g.y - g.x * f.y;\n      this.x = y * x - m * v, this.y = _ * v - d * x, this.w = d * m - _ * y;\n    }\n  };\n  Ml.prototype.getY = function () {\n    var t = this.y / this.w;\n    if (nl.isNaN(t) || nl.isInfinite(t)) throw new Cl();\n    return t;\n  }, Ml.prototype.getX = function () {\n    var t = this.x / this.w;\n    if (nl.isNaN(t) || nl.isInfinite(t)) throw new Cl();\n    return t;\n  }, Ml.prototype.getCoordinate = function () {\n    var t = new ul();\n    return t.x = this.getX(), t.y = this.getY(), t;\n  }, Ml.prototype.interfaces_ = function () {\n    return [];\n  }, Ml.prototype.getClass = function () {\n    return Ml;\n  }, Ml.intersection = function (t, e, n, r) {\n    var i = t.y - e.y,\n      o = e.x - t.x,\n      s = t.x * e.y - e.x * t.y,\n      a = n.y - r.y,\n      u = r.x - n.x,\n      l = n.x * r.y - r.x * n.y,\n      c = i * u - a * o,\n      h = (o * l - u * s) / c,\n      p = (a * s - i * l) / c;\n    if (nl.isNaN(h) || nl.isInfinite(h) || nl.isNaN(p) || nl.isInfinite(p)) throw new Cl();\n    return new ul(h, p);\n  };\n  var Ll = function t() {\n      if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, 0 === arguments.length) this.init();else if (1 === arguments.length) {\n        if (arguments[0] instanceof ul) {\n          var e = arguments[0];\n          this.init(e.x, e.x, e.y, e.y);\n        } else if (arguments[0] instanceof t) {\n          var n = arguments[0];\n          this.init(n);\n        }\n      } else if (2 === arguments.length) {\n        var r = arguments[0],\n          i = arguments[1];\n        this.init(r.x, i.x, r.y, i.y);\n      } else if (4 === arguments.length) {\n        var o = arguments[0],\n          s = arguments[1],\n          a = arguments[2],\n          u = arguments[3];\n        this.init(o, s, a, u);\n      }\n    },\n    Ol = {\n      serialVersionUID: {\n        configurable: !0\n      }\n    };\n  Ll.prototype.getArea = function () {\n    return this.getWidth() * this.getHeight();\n  }, Ll.prototype.equals = function (t) {\n    if (!(t instanceof Ll)) return !1;\n    var e = t;\n    return this.isNull() ? e.isNull() : this._maxx === e.getMaxX() && this._maxy === e.getMaxY() && this._minx === e.getMinX() && this._miny === e.getMinY();\n  }, Ll.prototype.intersection = function (t) {\n    if (this.isNull() || t.isNull() || !this.intersects(t)) return new Ll();\n    var e = this._minx > t._minx ? this._minx : t._minx,\n      n = this._miny > t._miny ? this._miny : t._miny,\n      r = this._maxx < t._maxx ? this._maxx : t._maxx,\n      i = this._maxy < t._maxy ? this._maxy : t._maxy;\n    return new Ll(e, r, n, i);\n  }, Ll.prototype.isNull = function () {\n    return this._maxx < this._minx;\n  }, Ll.prototype.getMaxX = function () {\n    return this._maxx;\n  }, Ll.prototype.covers = function () {\n    if (1 === arguments.length) {\n      if (arguments[0] instanceof ul) {\n        var t = arguments[0];\n        return this.covers(t.x, t.y);\n      }\n      if (arguments[0] instanceof Ll) {\n        var e = arguments[0];\n        return !this.isNull() && !e.isNull() && e.getMinX() >= this._minx && e.getMaxX() <= this._maxx && e.getMinY() >= this._miny && e.getMaxY() <= this._maxy;\n      }\n    } else if (2 === arguments.length) {\n      var n = arguments[0],\n        r = arguments[1];\n      return !this.isNull() && n >= this._minx && n <= this._maxx && r >= this._miny && r <= this._maxy;\n    }\n  }, Ll.prototype.intersects = function () {\n    if (1 === arguments.length) {\n      if (arguments[0] instanceof Ll) {\n        var t = arguments[0];\n        return !this.isNull() && !t.isNull() && !(t._minx > this._maxx || t._maxx < this._minx || t._miny > this._maxy || t._maxy < this._miny);\n      }\n      if (arguments[0] instanceof ul) {\n        var e = arguments[0];\n        return this.intersects(e.x, e.y);\n      }\n    } else if (2 === arguments.length) {\n      var n = arguments[0],\n        r = arguments[1];\n      return !this.isNull() && !(n > this._maxx || n < this._minx || r > this._maxy || r < this._miny);\n    }\n  }, Ll.prototype.getMinY = function () {\n    return this._miny;\n  }, Ll.prototype.getMinX = function () {\n    return this._minx;\n  }, Ll.prototype.expandToInclude = function () {\n    if (1 === arguments.length) {\n      if (arguments[0] instanceof ul) {\n        var t = arguments[0];\n        this.expandToInclude(t.x, t.y);\n      } else if (arguments[0] instanceof Ll) {\n        var e = arguments[0];\n        if (e.isNull()) return null;\n        this.isNull() ? (this._minx = e.getMinX(), this._maxx = e.getMaxX(), this._miny = e.getMinY(), this._maxy = e.getMaxY()) : (e._minx < this._minx && (this._minx = e._minx), e._maxx > this._maxx && (this._maxx = e._maxx), e._miny < this._miny && (this._miny = e._miny), e._maxy > this._maxy && (this._maxy = e._maxy));\n      }\n    } else if (2 === arguments.length) {\n      var n = arguments[0],\n        r = arguments[1];\n      this.isNull() ? (this._minx = n, this._maxx = n, this._miny = r, this._maxy = r) : (n < this._minx && (this._minx = n), n > this._maxx && (this._maxx = n), r < this._miny && (this._miny = r), r > this._maxy && (this._maxy = r));\n    }\n  }, Ll.prototype.minExtent = function () {\n    if (this.isNull()) return 0;\n    var t = this.getWidth(),\n      e = this.getHeight();\n    return t < e ? t : e;\n  }, Ll.prototype.getWidth = function () {\n    return this.isNull() ? 0 : this._maxx - this._minx;\n  }, Ll.prototype.compareTo = function (t) {\n    var e = t;\n    return this.isNull() ? e.isNull() ? 0 : -1 : e.isNull() ? 1 : this._minx < e._minx ? -1 : this._minx > e._minx ? 1 : this._miny < e._miny ? -1 : this._miny > e._miny ? 1 : this._maxx < e._maxx ? -1 : this._maxx > e._maxx ? 1 : this._maxy < e._maxy ? -1 : this._maxy > e._maxy ? 1 : 0;\n  }, Ll.prototype.translate = function (t, e) {\n    if (this.isNull()) return null;\n    this.init(this.getMinX() + t, this.getMaxX() + t, this.getMinY() + e, this.getMaxY() + e);\n  }, Ll.prototype.toString = function () {\n    return \"Env[\" + this._minx + \" : \" + this._maxx + \", \" + this._miny + \" : \" + this._maxy + \"]\";\n  }, Ll.prototype.setToNull = function () {\n    this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1;\n  }, Ll.prototype.getHeight = function () {\n    return this.isNull() ? 0 : this._maxy - this._miny;\n  }, Ll.prototype.maxExtent = function () {\n    if (this.isNull()) return 0;\n    var t = this.getWidth(),\n      e = this.getHeight();\n    return t > e ? t : e;\n  }, Ll.prototype.expandBy = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      this.expandBy(t, t);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n        n = arguments[1];\n      if (this.isNull()) return null;\n      this._minx -= e, this._maxx += e, this._miny -= n, this._maxy += n, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull();\n    }\n  }, Ll.prototype.contains = function () {\n    if (1 === arguments.length) {\n      if (arguments[0] instanceof Ll) {\n        var t = arguments[0];\n        return this.covers(t);\n      }\n      if (arguments[0] instanceof ul) {\n        var e = arguments[0];\n        return this.covers(e);\n      }\n    } else if (2 === arguments.length) {\n      var n = arguments[0],\n        r = arguments[1];\n      return this.covers(n, r);\n    }\n  }, Ll.prototype.centre = function () {\n    return this.isNull() ? null : new ul((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);\n  }, Ll.prototype.init = function () {\n    if (0 === arguments.length) this.setToNull();else if (1 === arguments.length) {\n      if (arguments[0] instanceof ul) {\n        var t = arguments[0];\n        this.init(t.x, t.x, t.y, t.y);\n      } else if (arguments[0] instanceof Ll) {\n        var e = arguments[0];\n        this._minx = e._minx, this._maxx = e._maxx, this._miny = e._miny, this._maxy = e._maxy;\n      }\n    } else if (2 === arguments.length) {\n      var n = arguments[0],\n        r = arguments[1];\n      this.init(n.x, r.x, n.y, r.y);\n    } else if (4 === arguments.length) {\n      var i = arguments[0],\n        o = arguments[1],\n        s = arguments[2],\n        a = arguments[3];\n      i < o ? (this._minx = i, this._maxx = o) : (this._minx = o, this._maxx = i), s < a ? (this._miny = s, this._maxy = a) : (this._miny = a, this._maxy = s);\n    }\n  }, Ll.prototype.getMaxY = function () {\n    return this._maxy;\n  }, Ll.prototype.distance = function (t) {\n    if (this.intersects(t)) return 0;\n    var e = 0;\n    this._maxx < t._minx ? e = t._minx - this._maxx : this._minx > t._maxx && (e = this._minx - t._maxx);\n    var n = 0;\n    return this._maxy < t._miny ? n = t._miny - this._maxy : this._miny > t._maxy && (n = this._miny - t._maxy), 0 === e ? n : 0 === n ? e : Math.sqrt(e * e + n * n);\n  }, Ll.prototype.hashCode = function () {\n    var t = 17;\n    return t = 37 * (t = 37 * (t = 37 * (t = 37 * t + ul.hashCode(this._minx)) + ul.hashCode(this._maxx)) + ul.hashCode(this._miny)) + ul.hashCode(this._maxy);\n  }, Ll.prototype.interfaces_ = function () {\n    return [il, al];\n  }, Ll.prototype.getClass = function () {\n    return Ll;\n  }, Ll.intersects = function () {\n    if (3 === arguments.length) {\n      var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2];\n      return n.x >= (t.x < e.x ? t.x : e.x) && n.x <= (t.x > e.x ? t.x : e.x) && n.y >= (t.y < e.y ? t.y : e.y) && n.y <= (t.y > e.y ? t.y : e.y);\n    }\n    if (4 === arguments.length) {\n      var r = arguments[0],\n        i = arguments[1],\n        o = arguments[2],\n        s = arguments[3],\n        a = Math.min(o.x, s.x),\n        u = Math.max(o.x, s.x),\n        l = Math.min(r.x, i.x),\n        c = Math.max(r.x, i.x);\n      return !(l > u) && !(c < a) && (a = Math.min(o.y, s.y), u = Math.max(o.y, s.y), l = Math.min(r.y, i.y), c = Math.max(r.y, i.y), !(l > u) && !(c < a));\n    }\n  }, Ol.serialVersionUID.get = function () {\n    return 0x51845cd552189800;\n  }, Object.defineProperties(Ll, Ol);\n  var Rl = {\n      typeStr: /^\\s*(\\w+)\\s*\\(\\s*(.*)\\s*\\)\\s*$/,\n      emptyTypeStr: /^\\s*(\\w+)\\s*EMPTY\\s*$/,\n      spaces: /\\s+/,\n      parenComma: /\\)\\s*,\\s*\\(/,\n      doubleParenComma: /\\)\\s*\\)\\s*,\\s*\\(\\s*\\(/,\n      trimParens: /^\\s*\\(?(.*?)\\)?\\s*$/\n    },\n    Tl = function Tl(t) {\n      this.geometryFactory = t || new _h();\n    };\n  Tl.prototype.read = function (t) {\n    var e, n, r;\n    t = t.replace(/[\\n\\r]/g, \" \");\n    var i = Rl.typeStr.exec(t);\n    if (-1 !== t.search(\"EMPTY\") && ((i = Rl.emptyTypeStr.exec(t))[2] = void 0), i && (n = i[1].toLowerCase(), r = i[2], Dl[n] && (e = Dl[n].apply(this, [r]))), void 0 === e) throw new Error(\"Could not parse WKT \" + t);\n    return e;\n  }, Tl.prototype.write = function (t) {\n    return this.extractGeometry(t);\n  }, Tl.prototype.extractGeometry = function (t) {\n    var e = t.getGeometryType().toLowerCase();\n    if (!Al[e]) return null;\n    var n = e.toUpperCase();\n    return t.isEmpty() ? n + \" EMPTY\" : n + \"(\" + Al[e].apply(this, [t]) + \")\";\n  };\n  var Al = {\n      coordinate: function coordinate(t) {\n        return t.x + \" \" + t.y;\n      },\n      point: function point(t) {\n        return Al.coordinate.call(this, t._coordinates._coordinates[0]);\n      },\n      multipoint: function multipoint(t) {\n        for (var e = [], n = 0, r = t._geometries.length; n < r; ++n) e.push(\"(\" + Al.point.apply(this, [t._geometries[n]]) + \")\");\n        return e.join(\",\");\n      },\n      linestring: function linestring(t) {\n        for (var e = [], n = 0, r = t._points._coordinates.length; n < r; ++n) e.push(Al.coordinate.apply(this, [t._points._coordinates[n]]));\n        return e.join(\",\");\n      },\n      linearring: function linearring(t) {\n        for (var e = [], n = 0, r = t._points._coordinates.length; n < r; ++n) e.push(Al.coordinate.apply(this, [t._points._coordinates[n]]));\n        return e.join(\",\");\n      },\n      multilinestring: function multilinestring(t) {\n        for (var e = [], n = 0, r = t._geometries.length; n < r; ++n) e.push(\"(\" + Al.linestring.apply(this, [t._geometries[n]]) + \")\");\n        return e.join(\",\");\n      },\n      polygon: function polygon(t) {\n        var e = [];\n        e.push(\"(\" + Al.linestring.apply(this, [t._shell]) + \")\");\n        for (var n = 0, r = t._holes.length; n < r; ++n) e.push(\"(\" + Al.linestring.apply(this, [t._holes[n]]) + \")\");\n        return e.join(\",\");\n      },\n      multipolygon: function multipolygon(t) {\n        for (var e = [], n = 0, r = t._geometries.length; n < r; ++n) e.push(\"(\" + Al.polygon.apply(this, [t._geometries[n]]) + \")\");\n        return e.join(\",\");\n      },\n      geometrycollection: function geometrycollection(t) {\n        for (var e = [], n = 0, r = t._geometries.length; n < r; ++n) e.push(this.extractGeometry(t._geometries[n]));\n        return e.join(\",\");\n      }\n    },\n    Dl = {\n      point: function point(t) {\n        if (void 0 === t) return this.geometryFactory.createPoint();\n        var e = t.trim().split(Rl.spaces);\n        return this.geometryFactory.createPoint(new ul(Number.parseFloat(e[0]), Number.parseFloat(e[1])));\n      },\n      multipoint: function multipoint(t) {\n        var e;\n        if (void 0 === t) return this.geometryFactory.createMultiPoint();\n        for (var n = t.trim().split(\",\"), r = [], i = 0, o = n.length; i < o; ++i) e = n[i].replace(Rl.trimParens, \"$1\"), r.push(Dl.point.apply(this, [e]));\n        return this.geometryFactory.createMultiPoint(r);\n      },\n      linestring: function linestring(t) {\n        if (void 0 === t) return this.geometryFactory.createLineString();\n        for (var e, n = t.trim().split(\",\"), r = [], i = 0, o = n.length; i < o; ++i) e = n[i].trim().split(Rl.spaces), r.push(new ul(Number.parseFloat(e[0]), Number.parseFloat(e[1])));\n        return this.geometryFactory.createLineString(r);\n      },\n      linearring: function linearring(t) {\n        if (void 0 === t) return this.geometryFactory.createLinearRing();\n        for (var e, n = t.trim().split(\",\"), r = [], i = 0, o = n.length; i < o; ++i) e = n[i].trim().split(Rl.spaces), r.push(new ul(Number.parseFloat(e[0]), Number.parseFloat(e[1])));\n        return this.geometryFactory.createLinearRing(r);\n      },\n      multilinestring: function multilinestring(t) {\n        var e;\n        if (void 0 === t) return this.geometryFactory.createMultiLineString();\n        for (var n = t.trim().split(Rl.parenComma), r = [], i = 0, o = n.length; i < o; ++i) e = n[i].replace(Rl.trimParens, \"$1\"), r.push(Dl.linestring.apply(this, [e]));\n        return this.geometryFactory.createMultiLineString(r);\n      },\n      polygon: function polygon(t) {\n        var e, n, r;\n        if (void 0 === t) return this.geometryFactory.createPolygon();\n        for (var i, o = t.trim().split(Rl.parenComma), s = [], a = 0, u = o.length; a < u; ++a) e = o[a].replace(Rl.trimParens, \"$1\"), n = Dl.linestring.apply(this, [e]), r = this.geometryFactory.createLinearRing(n._points), 0 === a ? i = r : s.push(r);\n        return this.geometryFactory.createPolygon(i, s);\n      },\n      multipolygon: function multipolygon(t) {\n        var e;\n        if (void 0 === t) return this.geometryFactory.createMultiPolygon();\n        for (var n = t.trim().split(Rl.doubleParenComma), r = [], i = 0, o = n.length; i < o; ++i) e = n[i].replace(Rl.trimParens, \"$1\"), r.push(Dl.polygon.apply(this, [e]));\n        return this.geometryFactory.createMultiPolygon(r);\n      },\n      geometrycollection: function geometrycollection(t) {\n        if (void 0 === t) return this.geometryFactory.createGeometryCollection();\n        for (var e = (t = t.replace(/,\\s*([A-Za-z])/g, \"|$1\")).trim().split(\"|\"), n = [], r = 0, i = e.length; r < i; ++r) n.push(this.read(e[r]));\n        return this.geometryFactory.createGeometryCollection(n);\n      }\n    },\n    Fl = function Fl(t) {\n      this.parser = new Tl(t);\n    };\n  Fl.prototype.write = function (t) {\n    return this.parser.write(t);\n  }, Fl.toLineString = function (t, e) {\n    if (2 !== arguments.length) throw new Error(\"Not implemented\");\n    return \"LINESTRING ( \" + t.x + \" \" + t.y + \", \" + e.x + \" \" + e.y + \" )\";\n  };\n  var kl = function (t) {\n      function e(e) {\n        t.call(this, e), this.name = \"RuntimeException\", this.message = e, this.stack = new t().stack;\n      }\n      return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e;\n    }(Error),\n    Gl = function (t) {\n      function e() {\n        if (t.call(this), 0 === arguments.length) t.call(this);else if (1 === arguments.length) {\n          var e = arguments[0];\n          t.call(this, e);\n        }\n      }\n      return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.interfaces_ = function () {\n        return [];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, e;\n    }(kl),\n    ql = function ql() {};\n  ql.prototype.interfaces_ = function () {\n    return [];\n  }, ql.prototype.getClass = function () {\n    return ql;\n  }, ql.shouldNeverReachHere = function () {\n    if (0 === arguments.length) ql.shouldNeverReachHere(null);else if (1 === arguments.length) {\n      var t = arguments[0];\n      throw new Gl(\"Should never reach here\" + (null !== t ? \": \" + t : \"\"));\n    }\n  }, ql.isTrue = function () {\n    var t;\n    if (1 === arguments.length) ql.isTrue(arguments[0], null);else if (2 === arguments.length && (t = arguments[1], !arguments[0])) throw null === t ? new Gl() : new Gl(t);\n  }, ql.equals = function () {\n    var t, e, n;\n    if (2 === arguments.length) ql.equals(t = arguments[0], e = arguments[1], null);else if (3 === arguments.length && (t = arguments[0], n = arguments[2], !(e = arguments[1]).equals(t))) throw new Gl(\"Expected \" + t + \" but encountered \" + e + (null !== n ? \": \" + n : \"\"));\n  };\n  var Bl = function Bl() {\n      this._result = null, this._inputLines = Array(2).fill().map(function () {\n        return Array(2);\n      }), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new ul(), this._intPt[1] = new ul(), this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0;\n    },\n    zl = {\n      DONT_INTERSECT: {\n        configurable: !0\n      },\n      DO_INTERSECT: {\n        configurable: !0\n      },\n      COLLINEAR: {\n        configurable: !0\n      },\n      NO_INTERSECTION: {\n        configurable: !0\n      },\n      POINT_INTERSECTION: {\n        configurable: !0\n      },\n      COLLINEAR_INTERSECTION: {\n        configurable: !0\n      }\n    };\n  Bl.prototype.getIndexAlongSegment = function (t, e) {\n    return this.computeIntLineIndex(), this._intLineIndex[t][e];\n  }, Bl.prototype.getTopologySummary = function () {\n    var t = new vl();\n    return this.isEndPoint() && t.append(\" endpoint\"), this._isProper && t.append(\" proper\"), this.isCollinear() && t.append(\" collinear\"), t.toString();\n  }, Bl.prototype.computeIntersection = function (t, e, n, r) {\n    this._inputLines[0][0] = t, this._inputLines[0][1] = e, this._inputLines[1][0] = n, this._inputLines[1][1] = r, this._result = this.computeIntersect(t, e, n, r);\n  }, Bl.prototype.getIntersectionNum = function () {\n    return this._result;\n  }, Bl.prototype.computeIntLineIndex = function () {\n    if (0 === arguments.length) null === this._intLineIndex && (this._intLineIndex = Array(2).fill().map(function () {\n      return Array(2);\n    }), this.computeIntLineIndex(0), this.computeIntLineIndex(1));else if (1 === arguments.length) {\n      var t = arguments[0],\n        e = this.getEdgeDistance(t, 0),\n        n = this.getEdgeDistance(t, 1);\n      e > n ? (this._intLineIndex[t][0] = 0, this._intLineIndex[t][1] = 1) : (this._intLineIndex[t][0] = 1, this._intLineIndex[t][1] = 0);\n    }\n  }, Bl.prototype.isProper = function () {\n    return this.hasIntersection() && this._isProper;\n  }, Bl.prototype.setPrecisionModel = function (t) {\n    this._precisionModel = t;\n  }, Bl.prototype.isInteriorIntersection = function () {\n    var t = this;\n    if (0 === arguments.length) return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);\n    if (1 === arguments.length) {\n      for (var e = arguments[0], n = 0; n < this._result; n++) if (!t._intPt[n].equals2D(t._inputLines[e][0]) && !t._intPt[n].equals2D(t._inputLines[e][1])) return !0;\n      return !1;\n    }\n  }, Bl.prototype.getIntersection = function (t) {\n    return this._intPt[t];\n  }, Bl.prototype.isEndPoint = function () {\n    return this.hasIntersection() && !this._isProper;\n  }, Bl.prototype.hasIntersection = function () {\n    return this._result !== Bl.NO_INTERSECTION;\n  }, Bl.prototype.getEdgeDistance = function (t, e) {\n    return Bl.computeEdgeDistance(this._intPt[e], this._inputLines[t][0], this._inputLines[t][1]);\n  }, Bl.prototype.isCollinear = function () {\n    return this._result === Bl.COLLINEAR_INTERSECTION;\n  }, Bl.prototype.toString = function () {\n    return Fl.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + \" - \" + Fl.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();\n  }, Bl.prototype.getEndpoint = function (t, e) {\n    return this._inputLines[t][e];\n  }, Bl.prototype.isIntersection = function (t) {\n    for (var e = 0; e < this._result; e++) if (this._intPt[e].equals2D(t)) return !0;\n    return !1;\n  }, Bl.prototype.getIntersectionAlongSegment = function (t, e) {\n    return this.computeIntLineIndex(), this._intPt[this._intLineIndex[t][e]];\n  }, Bl.prototype.interfaces_ = function () {\n    return [];\n  }, Bl.prototype.getClass = function () {\n    return Bl;\n  }, Bl.computeEdgeDistance = function (t, e, n) {\n    var r = Math.abs(n.x - e.x),\n      i = Math.abs(n.y - e.y),\n      o = -1;\n    if (t.equals(e)) o = 0;else if (t.equals(n)) o = r > i ? r : i;else {\n      var s = Math.abs(t.x - e.x),\n        a = Math.abs(t.y - e.y);\n      0 !== (o = r > i ? s : a) || t.equals(e) || (o = Math.max(s, a));\n    }\n    return ql.isTrue(!(0 === o && !t.equals(e)), \"Bad distance calculation\"), o;\n  }, Bl.nonRobustComputeEdgeDistance = function (t, e, n) {\n    var r = t.x - e.x,\n      i = t.y - e.y,\n      o = Math.sqrt(r * r + i * i);\n    return ql.isTrue(!(0 === o && !t.equals(e)), \"Invalid distance calculation\"), o;\n  }, zl.DONT_INTERSECT.get = function () {\n    return 0;\n  }, zl.DO_INTERSECT.get = function () {\n    return 1;\n  }, zl.COLLINEAR.get = function () {\n    return 2;\n  }, zl.NO_INTERSECTION.get = function () {\n    return 0;\n  }, zl.POINT_INTERSECTION.get = function () {\n    return 1;\n  }, zl.COLLINEAR_INTERSECTION.get = function () {\n    return 2;\n  }, Object.defineProperties(Bl, zl);\n  var jl = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.isInSegmentEnvelopes = function (t) {\n        var e = new Ll(this._inputLines[0][0], this._inputLines[0][1]),\n          n = new Ll(this._inputLines[1][0], this._inputLines[1][1]);\n        return e.contains(t) && n.contains(t);\n      }, e.prototype.computeIntersection = function () {\n        if (3 !== arguments.length) return t.prototype.computeIntersection.apply(this, arguments);\n        var e = arguments[0],\n          n = arguments[1],\n          r = arguments[2];\n        if (this._isProper = !1, Ll.intersects(n, r, e) && 0 === Xl.orientationIndex(n, r, e) && 0 === Xl.orientationIndex(r, n, e)) return this._isProper = !0, (e.equals(n) || e.equals(r)) && (this._isProper = !1), this._result = t.POINT_INTERSECTION, null;\n        this._result = t.NO_INTERSECTION;\n      }, e.prototype.normalizeToMinimum = function (t, e, n, r, i) {\n        i.x = this.smallestInAbsValue(t.x, e.x, n.x, r.x), i.y = this.smallestInAbsValue(t.y, e.y, n.y, r.y), t.x -= i.x, t.y -= i.y, e.x -= i.x, e.y -= i.y, n.x -= i.x, n.y -= i.y, r.x -= i.x, r.y -= i.y;\n      }, e.prototype.safeHCoordinateIntersection = function (t, n, r, i) {\n        var o = null;\n        try {\n          o = Ml.intersection(t, n, r, i);\n        } catch (s) {\n          if (!(s instanceof Cl)) throw s;\n          o = e.nearestEndpoint(t, n, r, i);\n        }\n        return o;\n      }, e.prototype.intersection = function (t, n, r, i) {\n        var o = this.intersectionWithNormalization(t, n, r, i);\n        return this.isInSegmentEnvelopes(o) || (o = new ul(e.nearestEndpoint(t, n, r, i))), null !== this._precisionModel && this._precisionModel.makePrecise(o), o;\n      }, e.prototype.smallestInAbsValue = function (t, e, n, r) {\n        var i = t,\n          o = Math.abs(i);\n        return Math.abs(e) < o && (i = e, o = Math.abs(e)), Math.abs(n) < o && (i = n, o = Math.abs(n)), Math.abs(r) < o && (i = r), i;\n      }, e.prototype.checkDD = function (t, e, n, r, i) {\n        var o = bl.intersection(t, e, n, r),\n          s = this.isInSegmentEnvelopes(o);\n        Pl.out.println(\"DD in env = \" + s + \"  --------------------- \" + o), i.distance(o) > 1e-4 && Pl.out.println(\"Distance = \" + i.distance(o));\n      }, e.prototype.intersectionWithNormalization = function (t, e, n, r) {\n        var i = new ul(t),\n          o = new ul(e),\n          s = new ul(n),\n          a = new ul(r),\n          u = new ul();\n        this.normalizeToEnvCentre(i, o, s, a, u);\n        var l = this.safeHCoordinateIntersection(i, o, s, a);\n        return l.x += u.x, l.y += u.y, l;\n      }, e.prototype.computeCollinearIntersection = function (e, n, r, i) {\n        var o = Ll.intersects(e, n, r),\n          s = Ll.intersects(e, n, i),\n          a = Ll.intersects(r, i, e),\n          u = Ll.intersects(r, i, n);\n        return o && s ? (this._intPt[0] = r, this._intPt[1] = i, t.COLLINEAR_INTERSECTION) : a && u ? (this._intPt[0] = e, this._intPt[1] = n, t.COLLINEAR_INTERSECTION) : o && a ? (this._intPt[0] = r, this._intPt[1] = e, !r.equals(e) || s || u ? t.COLLINEAR_INTERSECTION : t.POINT_INTERSECTION) : o && u ? (this._intPt[0] = r, this._intPt[1] = n, !r.equals(n) || s || a ? t.COLLINEAR_INTERSECTION : t.POINT_INTERSECTION) : s && a ? (this._intPt[0] = i, this._intPt[1] = e, !i.equals(e) || o || u ? t.COLLINEAR_INTERSECTION : t.POINT_INTERSECTION) : s && u ? (this._intPt[0] = i, this._intPt[1] = n, !i.equals(n) || o || a ? t.COLLINEAR_INTERSECTION : t.POINT_INTERSECTION) : t.NO_INTERSECTION;\n      }, e.prototype.normalizeToEnvCentre = function (t, e, n, r, i) {\n        var o = t.x < e.x ? t.x : e.x,\n          s = t.y < e.y ? t.y : e.y,\n          a = t.x > e.x ? t.x : e.x,\n          u = t.y > e.y ? t.y : e.y,\n          l = n.x < r.x ? n.x : r.x,\n          c = n.y < r.y ? n.y : r.y,\n          h = n.x > r.x ? n.x : r.x,\n          p = n.y > r.y ? n.y : r.y,\n          f = ((o > l ? o : l) + (a < h ? a : h)) / 2,\n          g = ((s > c ? s : c) + (u < p ? u : p)) / 2;\n        i.x = f, i.y = g, t.x -= i.x, t.y -= i.y, e.x -= i.x, e.y -= i.y, n.x -= i.x, n.y -= i.y, r.x -= i.x, r.y -= i.y;\n      }, e.prototype.computeIntersect = function (e, n, r, i) {\n        if (this._isProper = !1, !Ll.intersects(e, n, r, i)) return t.NO_INTERSECTION;\n        var o = Xl.orientationIndex(e, n, r),\n          s = Xl.orientationIndex(e, n, i);\n        if (o > 0 && s > 0 || o < 0 && s < 0) return t.NO_INTERSECTION;\n        var a = Xl.orientationIndex(r, i, e),\n          u = Xl.orientationIndex(r, i, n);\n        return a > 0 && u > 0 || a < 0 && u < 0 ? t.NO_INTERSECTION : 0 === o && 0 === s && 0 === a && 0 === u ? this.computeCollinearIntersection(e, n, r, i) : (0 === o || 0 === s || 0 === a || 0 === u ? (this._isProper = !1, e.equals2D(r) || e.equals2D(i) ? this._intPt[0] = e : n.equals2D(r) || n.equals2D(i) ? this._intPt[0] = n : 0 === o ? this._intPt[0] = new ul(r) : 0 === s ? this._intPt[0] = new ul(i) : 0 === a ? this._intPt[0] = new ul(e) : 0 === u && (this._intPt[0] = new ul(n))) : (this._isProper = !0, this._intPt[0] = this.intersection(e, n, r, i)), t.POINT_INTERSECTION);\n      }, e.prototype.interfaces_ = function () {\n        return [];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, e.nearestEndpoint = function (t, e, n, r) {\n        var i = t,\n          o = Xl.distancePointLine(t, n, r),\n          s = Xl.distancePointLine(e, n, r);\n        return s < o && (o = s, i = e), (s = Xl.distancePointLine(n, t, e)) < o && (o = s, i = n), (s = Xl.distancePointLine(r, t, e)) < o && (o = s, i = r), i;\n      }, e;\n    }(Bl),\n    Ul = function Ul() {};\n  Ul.prototype.interfaces_ = function () {\n    return [];\n  }, Ul.prototype.getClass = function () {\n    return Ul;\n  }, Ul.orientationIndex = function (t, e, n) {\n    var r = e.x - t.x,\n      i = e.y - t.y,\n      o = n.x - e.x,\n      s = n.y - e.y;\n    return Ul.signOfDet2x2(r, i, o, s);\n  }, Ul.signOfDet2x2 = function (t, e, n, r) {\n    var i = null,\n      o = null,\n      s = null;\n    if (i = 1, 0 === t || 0 === r) return 0 === e || 0 === n ? 0 : e > 0 ? n > 0 ? -i : i : n > 0 ? i : -i;\n    if (0 === e || 0 === n) return r > 0 ? t > 0 ? i : -i : t > 0 ? -i : i;\n    if (e > 0 ? r > 0 ? e <= r || (i = -i, o = t, t = n, n = o, o = e, e = r, r = o) : e <= -r ? (i = -i, n = -n, r = -r) : (o = t, t = -n, n = o, o = e, e = -r, r = o) : r > 0 ? -e <= r ? (i = -i, t = -t, e = -e) : (o = -t, t = n, n = o, o = -e, e = r, r = o) : e >= r ? (t = -t, e = -e, n = -n, r = -r) : (i = -i, o = -t, t = -n, n = o, o = -e, e = -r, r = o), t > 0) {\n      if (!(n > 0)) return i;\n      if (!(t <= n)) return i;\n    } else {\n      if (n > 0) return -i;\n      if (!(t >= n)) return -i;\n      i = -i, t = -t, n = -n;\n    }\n    for (;;) {\n      if ((r -= (s = Math.floor(n / t)) * e) < 0) return -i;\n      if (r > e) return i;\n      if (t > (n -= s * t) + n) {\n        if (e < r + r) return i;\n      } else {\n        if (e > r + r) return -i;\n        n = t - n, r = e - r, i = -i;\n      }\n      if (0 === r) return 0 === n ? 0 : -i;\n      if (0 === n) return i;\n      if ((e -= (s = Math.floor(t / n)) * r) < 0) return i;\n      if (e > r) return -i;\n      if (n > (t -= s * n) + t) {\n        if (r < e + e) return -i;\n      } else {\n        if (r > e + e) return i;\n        t = n - t, e = r - e, i = -i;\n      }\n      if (0 === e) return 0 === t ? 0 : i;\n      if (0 === t) return -i;\n    }\n  };\n  var Vl = function Vl() {\n    this._p = null, this._crossingCount = 0, this._isPointOnSegment = !1;\n    var t = arguments[0];\n    this._p = t;\n  };\n  Vl.prototype.countSegment = function (t, e) {\n    if (t.x < this._p.x && e.x < this._p.x) return null;\n    if (this._p.x === e.x && this._p.y === e.y) return this._isPointOnSegment = !0, null;\n    if (t.y === this._p.y && e.y === this._p.y) {\n      var n = t.x,\n        r = e.x;\n      return n > r && (n = e.x, r = t.x), this._p.x >= n && this._p.x <= r && (this._isPointOnSegment = !0), null;\n    }\n    if (t.y > this._p.y && e.y <= this._p.y || e.y > this._p.y && t.y <= this._p.y) {\n      var i = t.x - this._p.x,\n        o = t.y - this._p.y,\n        s = e.x - this._p.x,\n        a = e.y - this._p.y,\n        u = Ul.signOfDet2x2(i, o, s, a);\n      if (0 === u) return this._isPointOnSegment = !0, null;\n      a < o && (u = -u), u > 0 && this._crossingCount++;\n    }\n  }, Vl.prototype.isPointInPolygon = function () {\n    return this.getLocation() !== pl.EXTERIOR;\n  }, Vl.prototype.getLocation = function () {\n    return this._isPointOnSegment ? pl.BOUNDARY : this._crossingCount % 2 == 1 ? pl.INTERIOR : pl.EXTERIOR;\n  }, Vl.prototype.isOnSegment = function () {\n    return this._isPointOnSegment;\n  }, Vl.prototype.interfaces_ = function () {\n    return [];\n  }, Vl.prototype.getClass = function () {\n    return Vl;\n  }, Vl.locatePointInRing = function () {\n    if (arguments[0] instanceof ul && gl(arguments[1], Il)) {\n      for (var t = arguments[0], e = arguments[1], n = new Vl(t), r = new ul(), i = new ul(), o = 1; o < e.size(); o++) if (e.getCoordinate(o, r), e.getCoordinate(o - 1, i), n.countSegment(r, i), n.isOnSegment()) return n.getLocation();\n      return n.getLocation();\n    }\n    if (arguments[0] instanceof ul && arguments[1] instanceof Array) {\n      for (var s = arguments[0], a = arguments[1], u = new Vl(s), l = 1; l < a.length; l++) {\n        var c = a[l],\n          h = a[l - 1];\n        if (u.countSegment(c, h), u.isOnSegment()) return u.getLocation();\n      }\n      return u.getLocation();\n    }\n  };\n  var Xl = function Xl() {},\n    Yl = {\n      CLOCKWISE: {\n        configurable: !0\n      },\n      RIGHT: {\n        configurable: !0\n      },\n      COUNTERCLOCKWISE: {\n        configurable: !0\n      },\n      LEFT: {\n        configurable: !0\n      },\n      COLLINEAR: {\n        configurable: !0\n      },\n      STRAIGHT: {\n        configurable: !0\n      }\n    };\n  Xl.prototype.interfaces_ = function () {\n    return [];\n  }, Xl.prototype.getClass = function () {\n    return Xl;\n  }, Xl.orientationIndex = function (t, e, n) {\n    return bl.orientationIndex(t, e, n);\n  }, Xl.signedArea = function () {\n    if (arguments[0] instanceof Array) {\n      var t = arguments[0];\n      if (t.length < 3) return 0;\n      for (var e = 0, n = t[0].x, r = 1; r < t.length - 1; r++) {\n        var i = t[r].x - n,\n          o = t[r + 1].y,\n          s = t[r - 1].y;\n        e += i * (s - o);\n      }\n      return e / 2;\n    }\n    if (gl(arguments[0], Il)) {\n      var a = arguments[0],\n        u = a.size();\n      if (u < 3) return 0;\n      var l = new ul(),\n        c = new ul(),\n        h = new ul();\n      a.getCoordinate(0, c), a.getCoordinate(1, h);\n      var p = c.x;\n      h.x -= p;\n      for (var f = 0, g = 1; g < u - 1; g++) l.y = c.y, c.x = h.x, c.y = h.y, a.getCoordinate(g + 1, h), h.x -= p, f += c.x * (l.y - h.y);\n      return f / 2;\n    }\n  }, Xl.distanceLineLine = function (t, e, n, r) {\n    if (t.equals(e)) return Xl.distancePointLine(t, n, r);\n    if (n.equals(r)) return Xl.distancePointLine(r, t, e);\n    var i = !1;\n    if (Ll.intersects(t, e, n, r)) {\n      var o = (e.x - t.x) * (r.y - n.y) - (e.y - t.y) * (r.x - n.x);\n      if (0 === o) i = !0;else {\n        var s = (t.y - n.y) * (r.x - n.x) - (t.x - n.x) * (r.y - n.y),\n          a = ((t.y - n.y) * (e.x - t.x) - (t.x - n.x) * (e.y - t.y)) / o,\n          u = s / o;\n        (u < 0 || u > 1 || a < 0 || a > 1) && (i = !0);\n      }\n    } else i = !0;\n    return i ? dl.min(Xl.distancePointLine(t, n, r), Xl.distancePointLine(e, n, r), Xl.distancePointLine(n, t, e), Xl.distancePointLine(r, t, e)) : 0;\n  }, Xl.isPointInRing = function (t, e) {\n    return Xl.locatePointInRing(t, e) !== pl.EXTERIOR;\n  }, Xl.computeLength = function (t) {\n    var e = t.size();\n    if (e <= 1) return 0;\n    var n = 0,\n      r = new ul();\n    t.getCoordinate(0, r);\n    for (var i = r.x, o = r.y, s = 1; s < e; s++) {\n      t.getCoordinate(s, r);\n      var a = r.x,\n        u = r.y,\n        l = a - i,\n        c = u - o;\n      n += Math.sqrt(l * l + c * c), i = a, o = u;\n    }\n    return n;\n  }, Xl.isCCW = function (t) {\n    var e = t.length - 1;\n    if (e < 3) throw new el(\"Ring has fewer than 4 points, so orientation cannot be determined\");\n    for (var n = t[0], r = 0, i = 1; i <= e; i++) {\n      var o = t[i];\n      o.y > n.y && (n = o, r = i);\n    }\n    var s = r;\n    do {\n      (s -= 1) < 0 && (s = e);\n    } while (t[s].equals2D(n) && s !== r);\n    var a = r;\n    do {\n      a = (a + 1) % e;\n    } while (t[a].equals2D(n) && a !== r);\n    var u = t[s],\n      l = t[a];\n    if (u.equals2D(n) || l.equals2D(n) || u.equals2D(l)) return !1;\n    var c = Xl.computeOrientation(u, n, l),\n      h = !1;\n    return h = 0 === c ? u.x > l.x : c > 0, h;\n  }, Xl.locatePointInRing = function (t, e) {\n    return Vl.locatePointInRing(t, e);\n  }, Xl.distancePointLinePerpendicular = function (t, e, n) {\n    var r = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y),\n      i = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / r;\n    return Math.abs(i) * Math.sqrt(r);\n  }, Xl.computeOrientation = function (t, e, n) {\n    return Xl.orientationIndex(t, e, n);\n  }, Xl.distancePointLine = function () {\n    if (2 === arguments.length) {\n      var t = arguments[0],\n        e = arguments[1];\n      if (0 === e.length) throw new el(\"Line array must contain at least one vertex\");\n      for (var n = t.distance(e[0]), r = 0; r < e.length - 1; r++) {\n        var i = Xl.distancePointLine(t, e[r], e[r + 1]);\n        i < n && (n = i);\n      }\n      return n;\n    }\n    if (3 === arguments.length) {\n      var o = arguments[0],\n        s = arguments[1],\n        a = arguments[2];\n      if (s.x === a.x && s.y === a.y) return o.distance(s);\n      var u = (a.x - s.x) * (a.x - s.x) + (a.y - s.y) * (a.y - s.y),\n        l = ((o.x - s.x) * (a.x - s.x) + (o.y - s.y) * (a.y - s.y)) / u;\n      if (l <= 0) return o.distance(s);\n      if (l >= 1) return o.distance(a);\n      var c = ((s.y - o.y) * (a.x - s.x) - (s.x - o.x) * (a.y - s.y)) / u;\n      return Math.abs(c) * Math.sqrt(u);\n    }\n  }, Xl.isOnLine = function (t, e) {\n    for (var n = new jl(), r = 1; r < e.length; r++) {\n      var i = e[r - 1],\n        o = e[r];\n      if (n.computeIntersection(t, i, o), n.hasIntersection()) return !0;\n    }\n    return !1;\n  }, Yl.CLOCKWISE.get = function () {\n    return -1;\n  }, Yl.RIGHT.get = function () {\n    return Xl.CLOCKWISE;\n  }, Yl.COUNTERCLOCKWISE.get = function () {\n    return 1;\n  }, Yl.LEFT.get = function () {\n    return Xl.COUNTERCLOCKWISE;\n  }, Yl.COLLINEAR.get = function () {\n    return 0;\n  }, Yl.STRAIGHT.get = function () {\n    return Xl.COLLINEAR;\n  }, Object.defineProperties(Xl, Yl);\n  var Hl = function Hl() {};\n  Hl.prototype.filter = function (t) {}, Hl.prototype.interfaces_ = function () {\n    return [];\n  }, Hl.prototype.getClass = function () {\n    return Hl;\n  };\n  var Wl = function Wl() {\n      var t = arguments[0];\n      this._envelope = null, this._factory = null, this._SRID = null, this._userData = null, this._factory = t, this._SRID = t.getSRID();\n    },\n    Jl = {\n      serialVersionUID: {\n        configurable: !0\n      },\n      SORTINDEX_POINT: {\n        configurable: !0\n      },\n      SORTINDEX_MULTIPOINT: {\n        configurable: !0\n      },\n      SORTINDEX_LINESTRING: {\n        configurable: !0\n      },\n      SORTINDEX_LINEARRING: {\n        configurable: !0\n      },\n      SORTINDEX_MULTILINESTRING: {\n        configurable: !0\n      },\n      SORTINDEX_POLYGON: {\n        configurable: !0\n      },\n      SORTINDEX_MULTIPOLYGON: {\n        configurable: !0\n      },\n      SORTINDEX_GEOMETRYCOLLECTION: {\n        configurable: !0\n      },\n      geometryChangedFilter: {\n        configurable: !0\n      }\n    };\n  Wl.prototype.isGeometryCollection = function () {\n    return this.getSortIndex() === Wl.SORTINDEX_GEOMETRYCOLLECTION;\n  }, Wl.prototype.getFactory = function () {\n    return this._factory;\n  }, Wl.prototype.getGeometryN = function (t) {\n    return this;\n  }, Wl.prototype.getArea = function () {\n    return 0;\n  }, Wl.prototype.isRectangle = function () {\n    return !1;\n  }, Wl.prototype.equals = function () {\n    if (arguments[0] instanceof Wl) {\n      var t = arguments[0];\n      return null !== t && this.equalsTopo(t);\n    }\n    if (arguments[0] instanceof Object) {\n      var e = arguments[0];\n      if (!(e instanceof Wl)) return !1;\n      var n = e;\n      return this.equalsExact(n);\n    }\n  }, Wl.prototype.equalsExact = function (t) {\n    return this === t || this.equalsExact(t, 0);\n  }, Wl.prototype.geometryChanged = function () {\n    this.apply(Wl.geometryChangedFilter);\n  }, Wl.prototype.geometryChangedAction = function () {\n    this._envelope = null;\n  }, Wl.prototype.equalsNorm = function (t) {\n    return null !== t && this.norm().equalsExact(t.norm());\n  }, Wl.prototype.getLength = function () {\n    return 0;\n  }, Wl.prototype.getNumGeometries = function () {\n    return 1;\n  }, Wl.prototype.compareTo = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0],\n        e = t;\n      return this.getSortIndex() !== e.getSortIndex() ? this.getSortIndex() - e.getSortIndex() : this.isEmpty() && e.isEmpty() ? 0 : this.isEmpty() ? -1 : e.isEmpty() ? 1 : this.compareToSameClass(t);\n    }\n    if (2 === arguments.length) {\n      var n = arguments[0],\n        r = arguments[1];\n      return this.getSortIndex() !== n.getSortIndex() ? this.getSortIndex() - n.getSortIndex() : this.isEmpty() && n.isEmpty() ? 0 : this.isEmpty() ? -1 : n.isEmpty() ? 1 : this.compareToSameClass(n, r);\n    }\n  }, Wl.prototype.getUserData = function () {\n    return this._userData;\n  }, Wl.prototype.getSRID = function () {\n    return this._SRID;\n  }, Wl.prototype.getEnvelope = function () {\n    return this.getFactory().toGeometry(this.getEnvelopeInternal());\n  }, Wl.prototype.checkNotGeometryCollection = function (t) {\n    if (t.getSortIndex() === Wl.SORTINDEX_GEOMETRYCOLLECTION) throw new el(\"This method does not support GeometryCollection arguments\");\n  }, Wl.prototype.equal = function (t, e, n) {\n    return 0 === n ? t.equals(e) : t.distance(e) <= n;\n  }, Wl.prototype.norm = function () {\n    var t = this.copy();\n    return t.normalize(), t;\n  }, Wl.prototype.getPrecisionModel = function () {\n    return this._factory.getPrecisionModel();\n  }, Wl.prototype.getEnvelopeInternal = function () {\n    return null === this._envelope && (this._envelope = this.computeEnvelopeInternal()), new Ll(this._envelope);\n  }, Wl.prototype.setSRID = function (t) {\n    this._SRID = t;\n  }, Wl.prototype.setUserData = function (t) {\n    this._userData = t;\n  }, Wl.prototype.compare = function (t, e) {\n    for (var n = t.iterator(), r = e.iterator(); n.hasNext() && r.hasNext();) {\n      var i = n.next(),\n        o = r.next(),\n        s = i.compareTo(o);\n      if (0 !== s) return s;\n    }\n    return n.hasNext() ? 1 : r.hasNext() ? -1 : 0;\n  }, Wl.prototype.hashCode = function () {\n    return this.getEnvelopeInternal().hashCode();\n  }, Wl.prototype.isGeometryCollectionOrDerived = function () {\n    return this.getSortIndex() === Wl.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === Wl.SORTINDEX_MULTIPOINT || this.getSortIndex() === Wl.SORTINDEX_MULTILINESTRING || this.getSortIndex() === Wl.SORTINDEX_MULTIPOLYGON;\n  }, Wl.prototype.interfaces_ = function () {\n    return [ol, il, al];\n  }, Wl.prototype.getClass = function () {\n    return Wl;\n  }, Wl.hasNonEmptyElements = function (t) {\n    for (var e = 0; e < t.length; e++) if (!t[e].isEmpty()) return !0;\n    return !1;\n  }, Wl.hasNullElements = function (t) {\n    for (var e = 0; e < t.length; e++) if (null === t[e]) return !0;\n    return !1;\n  }, Jl.serialVersionUID.get = function () {\n    return 0x799ea46522854c00;\n  }, Jl.SORTINDEX_POINT.get = function () {\n    return 0;\n  }, Jl.SORTINDEX_MULTIPOINT.get = function () {\n    return 1;\n  }, Jl.SORTINDEX_LINESTRING.get = function () {\n    return 2;\n  }, Jl.SORTINDEX_LINEARRING.get = function () {\n    return 3;\n  }, Jl.SORTINDEX_MULTILINESTRING.get = function () {\n    return 4;\n  }, Jl.SORTINDEX_POLYGON.get = function () {\n    return 5;\n  }, Jl.SORTINDEX_MULTIPOLYGON.get = function () {\n    return 6;\n  }, Jl.SORTINDEX_GEOMETRYCOLLECTION.get = function () {\n    return 7;\n  }, Jl.geometryChangedFilter.get = function () {\n    return Zl;\n  }, Object.defineProperties(Wl, Jl);\n  var Zl = function Zl() {};\n  Zl.interfaces_ = function () {\n    return [Hl];\n  }, Zl.filter = function (t) {\n    t.geometryChangedAction();\n  };\n  var Kl = function Kl() {};\n  Kl.prototype.filter = function (t) {}, Kl.prototype.interfaces_ = function () {\n    return [];\n  }, Kl.prototype.getClass = function () {\n    return Kl;\n  };\n  var Ql = function Ql() {},\n    $l = {\n      Mod2BoundaryNodeRule: {\n        configurable: !0\n      },\n      EndPointBoundaryNodeRule: {\n        configurable: !0\n      },\n      MultiValentEndPointBoundaryNodeRule: {\n        configurable: !0\n      },\n      MonoValentEndPointBoundaryNodeRule: {\n        configurable: !0\n      },\n      MOD2_BOUNDARY_RULE: {\n        configurable: !0\n      },\n      ENDPOINT_BOUNDARY_RULE: {\n        configurable: !0\n      },\n      MULTIVALENT_ENDPOINT_BOUNDARY_RULE: {\n        configurable: !0\n      },\n      MONOVALENT_ENDPOINT_BOUNDARY_RULE: {\n        configurable: !0\n      },\n      OGC_SFS_BOUNDARY_RULE: {\n        configurable: !0\n      }\n    };\n  Ql.prototype.isInBoundary = function (t) {}, Ql.prototype.interfaces_ = function () {\n    return [];\n  }, Ql.prototype.getClass = function () {\n    return Ql;\n  }, $l.Mod2BoundaryNodeRule.get = function () {\n    return tc;\n  }, $l.EndPointBoundaryNodeRule.get = function () {\n    return ec;\n  }, $l.MultiValentEndPointBoundaryNodeRule.get = function () {\n    return nc;\n  }, $l.MonoValentEndPointBoundaryNodeRule.get = function () {\n    return rc;\n  }, $l.MOD2_BOUNDARY_RULE.get = function () {\n    return new tc();\n  }, $l.ENDPOINT_BOUNDARY_RULE.get = function () {\n    return new ec();\n  }, $l.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get = function () {\n    return new nc();\n  }, $l.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get = function () {\n    return new rc();\n  }, $l.OGC_SFS_BOUNDARY_RULE.get = function () {\n    return Ql.MOD2_BOUNDARY_RULE;\n  }, Object.defineProperties(Ql, $l);\n  var tc = function tc() {};\n  tc.prototype.isInBoundary = function (t) {\n    return t % 2 == 1;\n  }, tc.prototype.interfaces_ = function () {\n    return [Ql];\n  }, tc.prototype.getClass = function () {\n    return tc;\n  };\n  var ec = function ec() {};\n  ec.prototype.isInBoundary = function (t) {\n    return t > 0;\n  }, ec.prototype.interfaces_ = function () {\n    return [Ql];\n  }, ec.prototype.getClass = function () {\n    return ec;\n  };\n  var nc = function nc() {};\n  nc.prototype.isInBoundary = function (t) {\n    return t > 1;\n  }, nc.prototype.interfaces_ = function () {\n    return [Ql];\n  }, nc.prototype.getClass = function () {\n    return nc;\n  };\n  var rc = function rc() {};\n  rc.prototype.isInBoundary = function (t) {\n    return 1 === t;\n  }, rc.prototype.interfaces_ = function () {\n    return [Ql];\n  }, rc.prototype.getClass = function () {\n    return rc;\n  };\n  var ic = function ic() {};\n  function oc(t) {\n    this.message = t || \"\";\n  }\n  ic.prototype.add = function () {}, ic.prototype.addAll = function () {}, ic.prototype.isEmpty = function () {}, ic.prototype.iterator = function () {}, ic.prototype.size = function () {}, ic.prototype.toArray = function () {}, ic.prototype.remove = function () {}, oc.prototype = new Error(), oc.prototype.name = \"IndexOutOfBoundsException\";\n  var sc = function sc() {};\n  sc.prototype.hasNext = function () {}, sc.prototype.next = function () {}, sc.prototype.remove = function () {};\n  var ac = function (t) {\n    function e() {\n      t.apply(this, arguments);\n    }\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.get = function () {}, e.prototype.set = function () {}, e.prototype.isEmpty = function () {}, e;\n  }(ic);\n  function uc(t) {\n    this.message = t || \"\";\n  }\n  uc.prototype = new Error(), uc.prototype.name = \"NoSuchElementException\";\n  var lc = function (t) {\n      function e() {\n        t.call(this), this.array_ = [], arguments[0] instanceof ic && this.addAll(arguments[0]);\n      }\n      return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.ensureCapacity = function () {}, e.prototype.interfaces_ = function () {\n        return [t, ic];\n      }, e.prototype.add = function (t) {\n        return 1 === arguments.length ? this.array_.push(t) : this.array_.splice(arguments[0], arguments[1]), !0;\n      }, e.prototype.clear = function () {\n        this.array_ = [];\n      }, e.prototype.addAll = function (t) {\n        for (var e = t.iterator(); e.hasNext();) this.add(e.next());\n        return !0;\n      }, e.prototype.set = function (t, e) {\n        var n = this.array_[t];\n        return this.array_[t] = e, n;\n      }, e.prototype.iterator = function () {\n        return new cc(this);\n      }, e.prototype.get = function (t) {\n        if (t < 0 || t >= this.size()) throw new oc();\n        return this.array_[t];\n      }, e.prototype.isEmpty = function () {\n        return 0 === this.array_.length;\n      }, e.prototype.size = function () {\n        return this.array_.length;\n      }, e.prototype.toArray = function () {\n        for (var t = [], e = 0, n = this.array_.length; e < n; e++) t.push(this.array_[e]);\n        return t;\n      }, e.prototype.remove = function (t) {\n        for (var e = !1, n = 0, r = this.array_.length; n < r; n++) if (this.array_[n] === t) {\n          this.array_.splice(n, 1), e = !0;\n          break;\n        }\n        return e;\n      }, e;\n    }(ac),\n    cc = function (t) {\n      function e(e) {\n        t.call(this), this.arrayList_ = e, this.position_ = 0;\n      }\n      return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.next = function () {\n        if (this.position_ === this.arrayList_.size()) throw new uc();\n        return this.arrayList_.get(this.position_++);\n      }, e.prototype.hasNext = function () {\n        return this.position_ < this.arrayList_.size();\n      }, e.prototype.set = function (t) {\n        return this.arrayList_.set(this.position_ - 1, t);\n      }, e.prototype.remove = function () {\n        this.arrayList_.remove(this.arrayList_.get(this.position_));\n      }, e;\n    }(sc),\n    hc = function (t) {\n      function e() {\n        if (t.call(this), 0 === arguments.length) ;else if (1 === arguments.length) {\n          var e = arguments[0];\n          this.ensureCapacity(e.length), this.add(e, !0);\n        } else if (2 === arguments.length) {\n          var n = arguments[0],\n            r = arguments[1];\n          this.ensureCapacity(n.length), this.add(n, r);\n        }\n      }\n      t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;\n      var n = {\n        coordArrayType: {\n          configurable: !0\n        }\n      };\n      return n.coordArrayType.get = function () {\n        return new Array(0).fill(null);\n      }, e.prototype.getCoordinate = function (t) {\n        return this.get(t);\n      }, e.prototype.addAll = function () {\n        var e = this;\n        if (2 === arguments.length) {\n          for (var n = arguments[0], r = arguments[1], i = !1, o = n.iterator(); o.hasNext();) e.add(o.next(), r), i = !0;\n          return i;\n        }\n        return t.prototype.addAll.apply(this, arguments);\n      }, e.prototype.clone = function () {\n        for (var e = t.prototype.clone.call(this), n = 0; n < this.size(); n++) e.add(n, this.get(n).copy());\n        return e;\n      }, e.prototype.toCoordinateArray = function () {\n        return this.toArray(e.coordArrayType);\n      }, e.prototype.add = function () {\n        var e = this;\n        if (1 === arguments.length) {\n          var n = arguments[0];\n          t.prototype.add.call(this, n);\n        } else if (2 === arguments.length) {\n          if (arguments[0] instanceof Array && \"boolean\" == typeof arguments[1]) {\n            var r = arguments[0],\n              i = arguments[1];\n            return this.add(r, i, !0), !0;\n          }\n          if (arguments[0] instanceof ul && \"boolean\" == typeof arguments[1]) {\n            var o = arguments[0],\n              s = arguments[1];\n            if (!s && this.size() >= 1) {\n              var a = this.get(this.size() - 1);\n              if (a.equals2D(o)) return null;\n            }\n            t.prototype.add.call(this, o);\n          } else if (arguments[0] instanceof Object && \"boolean\" == typeof arguments[1]) {\n            var u = arguments[0],\n              l = arguments[1];\n            return this.add(u, l), !0;\n          }\n        } else if (3 === arguments.length) {\n          if (\"boolean\" == typeof arguments[2] && arguments[0] instanceof Array && \"boolean\" == typeof arguments[1]) {\n            var c = arguments[0],\n              h = arguments[1],\n              p = arguments[2];\n            if (p) for (var f = 0; f < c.length; f++) e.add(c[f], h);else for (var g = c.length - 1; g >= 0; g--) e.add(c[g], h);\n            return !0;\n          }\n          if (\"boolean\" == typeof arguments[2] && Number.isInteger(arguments[0]) && arguments[1] instanceof ul) {\n            var d = arguments[0],\n              y = arguments[1],\n              v = arguments[2];\n            if (!v) {\n              var _ = this.size();\n              if (_ > 0) {\n                if (d > 0) {\n                  var m = this.get(d - 1);\n                  if (m.equals2D(y)) return null;\n                }\n                if (d < _) {\n                  var x = this.get(d);\n                  if (x.equals2D(y)) return null;\n                }\n              }\n            }\n            t.prototype.add.call(this, d, y);\n          }\n        } else if (4 === arguments.length) {\n          var E = arguments[0],\n            b = arguments[1],\n            w = arguments[2],\n            I = arguments[3],\n            N = 1;\n          w > I && (N = -1);\n          for (var S = w; S !== I; S += N) e.add(E[S], b);\n          return !0;\n        }\n      }, e.prototype.closeRing = function () {\n        this.size() > 0 && this.add(new ul(this.get(0)), !1);\n      }, e.prototype.interfaces_ = function () {\n        return [];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, Object.defineProperties(e, n), e;\n    }(lc),\n    pc = function pc() {},\n    fc = {\n      ForwardComparator: {\n        configurable: !0\n      },\n      BidirectionalComparator: {\n        configurable: !0\n      },\n      coordArrayType: {\n        configurable: !0\n      }\n    };\n  fc.ForwardComparator.get = function () {\n    return gc;\n  }, fc.BidirectionalComparator.get = function () {\n    return dc;\n  }, fc.coordArrayType.get = function () {\n    return new Array(0).fill(null);\n  }, pc.prototype.interfaces_ = function () {\n    return [];\n  }, pc.prototype.getClass = function () {\n    return pc;\n  }, pc.isRing = function (t) {\n    return !(t.length < 4) && !!t[0].equals2D(t[t.length - 1]);\n  }, pc.ptNotInList = function (t, e) {\n    for (var n = 0; n < t.length; n++) {\n      var r = t[n];\n      if (pc.indexOf(r, e) < 0) return r;\n    }\n    return null;\n  }, pc.scroll = function (t, e) {\n    var n = pc.indexOf(e, t);\n    if (n < 0) return null;\n    var r = new Array(t.length).fill(null);\n    Pl.arraycopy(t, n, r, 0, t.length - n), Pl.arraycopy(t, 0, r, t.length - n, n), Pl.arraycopy(r, 0, t, 0, t.length);\n  }, pc.equals = function () {\n    if (2 === arguments.length) {\n      var t = arguments[0],\n        e = arguments[1];\n      if (t === e) return !0;\n      if (null === t || null === e) return !1;\n      if (t.length !== e.length) return !1;\n      for (var n = 0; n < t.length; n++) if (!t[n].equals(e[n])) return !1;\n      return !0;\n    }\n    if (3 === arguments.length) {\n      var r = arguments[0],\n        i = arguments[1],\n        o = arguments[2];\n      if (r === i) return !0;\n      if (null === r || null === i) return !1;\n      if (r.length !== i.length) return !1;\n      for (var s = 0; s < r.length; s++) if (0 !== o.compare(r[s], i[s])) return !1;\n      return !0;\n    }\n  }, pc.intersection = function (t, e) {\n    for (var n = new hc(), r = 0; r < t.length; r++) e.intersects(t[r]) && n.add(t[r], !0);\n    return n.toCoordinateArray();\n  }, pc.hasRepeatedPoints = function (t) {\n    for (var e = 1; e < t.length; e++) if (t[e - 1].equals(t[e])) return !0;\n    return !1;\n  }, pc.removeRepeatedPoints = function (t) {\n    return pc.hasRepeatedPoints(t) ? new hc(t, !1).toCoordinateArray() : t;\n  }, pc.reverse = function (t) {\n    for (var e = t.length - 1, n = Math.trunc(e / 2), r = 0; r <= n; r++) {\n      var i = t[r];\n      t[r] = t[e - r], t[e - r] = i;\n    }\n  }, pc.removeNull = function (t) {\n    for (var e = 0, n = 0; n < t.length; n++) null !== t[n] && e++;\n    var r = new Array(e).fill(null);\n    if (0 === e) return r;\n    for (var i = 0, o = 0; o < t.length; o++) null !== t[o] && (r[i++] = t[o]);\n    return r;\n  }, pc.copyDeep = function () {\n    if (1 === arguments.length) {\n      for (var t = arguments[0], e = new Array(t.length).fill(null), n = 0; n < t.length; n++) e[n] = new ul(t[n]);\n      return e;\n    }\n    if (5 === arguments.length) for (var r = arguments[0], i = arguments[1], o = arguments[2], s = arguments[3], a = arguments[4], u = 0; u < a; u++) o[s + u] = new ul(r[i + u]);\n  }, pc.isEqualReversed = function (t, e) {\n    for (var n = 0; n < t.length; n++) {\n      var r = t[n],\n        i = e[t.length - n - 1];\n      if (0 !== r.compareTo(i)) return !1;\n    }\n    return !0;\n  }, pc.envelope = function (t) {\n    for (var e = new Ll(), n = 0; n < t.length; n++) e.expandToInclude(t[n]);\n    return e;\n  }, pc.toCoordinateArray = function (t) {\n    return t.toArray(pc.coordArrayType);\n  }, pc.atLeastNCoordinatesOrNothing = function (t, e) {\n    return e.length >= t ? e : [];\n  }, pc.indexOf = function (t, e) {\n    for (var n = 0; n < e.length; n++) if (t.equals(e[n])) return n;\n    return -1;\n  }, pc.increasingDirection = function (t) {\n    for (var e = 0; e < Math.trunc(t.length / 2); e++) {\n      var n = t.length - 1 - e,\n        r = t[e].compareTo(t[n]);\n      if (0 !== r) return r;\n    }\n    return 1;\n  }, pc.compare = function (t, e) {\n    for (var n = 0; n < t.length && n < e.length;) {\n      var r = t[n].compareTo(e[n]);\n      if (0 !== r) return r;\n      n++;\n    }\n    return n < e.length ? -1 : n < t.length ? 1 : 0;\n  }, pc.minCoordinate = function (t) {\n    for (var e = null, n = 0; n < t.length; n++) (null === e || e.compareTo(t[n]) > 0) && (e = t[n]);\n    return e;\n  }, pc.extract = function (t, e, n) {\n    e = dl.clamp(e, 0, t.length);\n    var r = (n = dl.clamp(n, -1, t.length)) - e + 1;\n    n < 0 && (r = 0), e >= t.length && (r = 0), n < e && (r = 0);\n    var i = new Array(r).fill(null);\n    if (0 === r) return i;\n    for (var o = 0, s = e; s <= n; s++) i[o++] = t[s];\n    return i;\n  }, Object.defineProperties(pc, fc);\n  var gc = function gc() {};\n  gc.prototype.compare = function (t, e) {\n    return pc.compare(t, e);\n  }, gc.prototype.interfaces_ = function () {\n    return [sl];\n  }, gc.prototype.getClass = function () {\n    return gc;\n  };\n  var dc = function dc() {};\n  dc.prototype.compare = function (t, e) {\n    var n = t,\n      r = e;\n    if (n.length < r.length) return -1;\n    if (n.length > r.length) return 1;\n    if (0 === n.length) return 0;\n    var i = pc.compare(n, r);\n    return pc.isEqualReversed(n, r) ? 0 : i;\n  }, dc.prototype.OLDcompare = function (t, e) {\n    var n = t,\n      r = e;\n    if (n.length < r.length) return -1;\n    if (n.length > r.length) return 1;\n    if (0 === n.length) return 0;\n    for (var i = pc.increasingDirection(n), o = pc.increasingDirection(r), s = i > 0 ? 0 : n.length - 1, a = o > 0 ? 0 : n.length - 1, u = 0; u < n.length; u++) {\n      var l = n[s].compareTo(r[a]);\n      if (0 !== l) return l;\n      s += i, a += o;\n    }\n    return 0;\n  }, dc.prototype.interfaces_ = function () {\n    return [sl];\n  }, dc.prototype.getClass = function () {\n    return dc;\n  };\n  var yc = function yc() {};\n  yc.prototype.get = function () {}, yc.prototype.put = function () {}, yc.prototype.size = function () {}, yc.prototype.values = function () {}, yc.prototype.entrySet = function () {};\n  var vc = function (t) {\n    function e() {\n      t.apply(this, arguments);\n    }\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e;\n  }(yc);\n  function _c(t) {\n    this.message = t || \"\";\n  }\n  function mc() {}\n  _c.prototype = new Error(), _c.prototype.name = \"OperationNotSupported\", mc.prototype = new ic(), mc.prototype.contains = function () {};\n  var xc = function (t) {\n      function e() {\n        t.call(this), this.array_ = [], arguments[0] instanceof ic && this.addAll(arguments[0]);\n      }\n      return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.contains = function (t) {\n        for (var e = 0, n = this.array_.length; e < n; e++) {\n          if (this.array_[e] === t) return !0;\n        }\n        return !1;\n      }, e.prototype.add = function (t) {\n        return !this.contains(t) && (this.array_.push(t), !0);\n      }, e.prototype.addAll = function (t) {\n        for (var e = t.iterator(); e.hasNext();) this.add(e.next());\n        return !0;\n      }, e.prototype.remove = function (t) {\n        throw new Error();\n      }, e.prototype.size = function () {\n        return this.array_.length;\n      }, e.prototype.isEmpty = function () {\n        return 0 === this.array_.length;\n      }, e.prototype.toArray = function () {\n        for (var t = [], e = 0, n = this.array_.length; e < n; e++) t.push(this.array_[e]);\n        return t;\n      }, e.prototype.iterator = function () {\n        return new Ec(this);\n      }, e;\n    }(mc),\n    Ec = function (t) {\n      function e(e) {\n        t.call(this), this.hashSet_ = e, this.position_ = 0;\n      }\n      return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.next = function () {\n        if (this.position_ === this.hashSet_.size()) throw new uc();\n        return this.hashSet_.array_[this.position_++];\n      }, e.prototype.hasNext = function () {\n        return this.position_ < this.hashSet_.size();\n      }, e.prototype.remove = function () {\n        throw new _c();\n      }, e;\n    }(sc);\n  function bc(t) {\n    return null === t ? 0 : t.color;\n  }\n  function wc(t) {\n    return null === t ? null : t.parent;\n  }\n  function Ic(t, e) {\n    null !== t && (t.color = e);\n  }\n  function Nc(t) {\n    return null === t ? null : t.left;\n  }\n  function Sc(t) {\n    return null === t ? null : t.right;\n  }\n  function Cc() {\n    this.root_ = null, this.size_ = 0;\n  }\n  Cc.prototype = new vc(), Cc.prototype.get = function (t) {\n    for (var e = this.root_; null !== e;) {\n      var n = t.compareTo(e.key);\n      if (n < 0) e = e.left;else {\n        if (!(n > 0)) return e.value;\n        e = e.right;\n      }\n    }\n    return null;\n  }, Cc.prototype.put = function (t, e) {\n    if (null === this.root_) return this.root_ = {\n      key: t,\n      value: e,\n      left: null,\n      right: null,\n      parent: null,\n      color: 0,\n      getValue: function getValue() {\n        return this.value;\n      },\n      getKey: function getKey() {\n        return this.key;\n      }\n    }, this.size_ = 1, null;\n    var n,\n      r,\n      i = this.root_;\n    do {\n      if (n = i, (r = t.compareTo(i.key)) < 0) i = i.left;else {\n        if (!(r > 0)) {\n          var o = i.value;\n          return i.value = e, o;\n        }\n        i = i.right;\n      }\n    } while (null !== i);\n    var s = {\n      key: t,\n      left: null,\n      right: null,\n      value: e,\n      parent: n,\n      color: 0,\n      getValue: function getValue() {\n        return this.value;\n      },\n      getKey: function getKey() {\n        return this.key;\n      }\n    };\n    return r < 0 ? n.left = s : n.right = s, this.fixAfterInsertion(s), this.size_++, null;\n  }, Cc.prototype.fixAfterInsertion = function (t) {\n    var e = this;\n    for (t.color = 1; null != t && t !== this.root_ && 1 === t.parent.color;) if (wc(t) === Nc(wc(wc(t)))) {\n      var n = Sc(wc(wc(t)));\n      1 === bc(n) ? (Ic(wc(t), 0), Ic(n, 0), Ic(wc(wc(t)), 1), t = wc(wc(t))) : (t === Sc(wc(t)) && (t = wc(t), e.rotateLeft(t)), Ic(wc(t), 0), Ic(wc(wc(t)), 1), e.rotateRight(wc(wc(t))));\n    } else {\n      var r = Nc(wc(wc(t)));\n      1 === bc(r) ? (Ic(wc(t), 0), Ic(r, 0), Ic(wc(wc(t)), 1), t = wc(wc(t))) : (t === Nc(wc(t)) && (t = wc(t), e.rotateRight(t)), Ic(wc(t), 0), Ic(wc(wc(t)), 1), e.rotateLeft(wc(wc(t))));\n    }\n    this.root_.color = 0;\n  }, Cc.prototype.values = function () {\n    var t = new lc(),\n      e = this.getFirstEntry();\n    if (null !== e) for (t.add(e.value); null !== (e = Cc.successor(e));) t.add(e.value);\n    return t;\n  }, Cc.prototype.entrySet = function () {\n    var t = new xc(),\n      e = this.getFirstEntry();\n    if (null !== e) for (t.add(e); null !== (e = Cc.successor(e));) t.add(e);\n    return t;\n  }, Cc.prototype.rotateLeft = function (t) {\n    if (null != t) {\n      var e = t.right;\n      t.right = e.left, null != e.left && (e.left.parent = t), e.parent = t.parent, null === t.parent ? this.root_ = e : t.parent.left === t ? t.parent.left = e : t.parent.right = e, e.left = t, t.parent = e;\n    }\n  }, Cc.prototype.rotateRight = function (t) {\n    if (null != t) {\n      var e = t.left;\n      t.left = e.right, null != e.right && (e.right.parent = t), e.parent = t.parent, null === t.parent ? this.root_ = e : t.parent.right === t ? t.parent.right = e : t.parent.left = e, e.right = t, t.parent = e;\n    }\n  }, Cc.prototype.getFirstEntry = function () {\n    var t = this.root_;\n    if (null != t) for (; null != t.left;) t = t.left;\n    return t;\n  }, Cc.successor = function (t) {\n    if (null === t) return null;\n    if (null !== t.right) {\n      for (var e = t.right; null !== e.left;) e = e.left;\n      return e;\n    }\n    for (var n = t.parent, r = t; null !== n && r === n.right;) r = n, n = n.parent;\n    return n;\n  }, Cc.prototype.size = function () {\n    return this.size_;\n  };\n  var Pc = function Pc() {};\n  function Mc() {}\n  function Lc() {\n    this.array_ = [], arguments[0] instanceof ic && this.addAll(arguments[0]);\n  }\n  Pc.prototype.interfaces_ = function () {\n    return [];\n  }, Pc.prototype.getClass = function () {\n    return Pc;\n  }, Mc.prototype = new mc(), Lc.prototype = new Mc(), Lc.prototype.contains = function (t) {\n    for (var e = 0, n = this.array_.length; e < n; e++) {\n      if (0 === this.array_[e].compareTo(t)) return !0;\n    }\n    return !1;\n  }, Lc.prototype.add = function (t) {\n    if (this.contains(t)) return !1;\n    for (var e = 0, n = this.array_.length; e < n; e++) {\n      if (1 === this.array_[e].compareTo(t)) return this.array_.splice(e, 0, t), !0;\n    }\n    return this.array_.push(t), !0;\n  }, Lc.prototype.addAll = function (t) {\n    for (var e = t.iterator(); e.hasNext();) this.add(e.next());\n    return !0;\n  }, Lc.prototype.remove = function (t) {\n    throw new _c();\n  }, Lc.prototype.size = function () {\n    return this.array_.length;\n  }, Lc.prototype.isEmpty = function () {\n    return 0 === this.array_.length;\n  }, Lc.prototype.toArray = function () {\n    for (var t = [], e = 0, n = this.array_.length; e < n; e++) t.push(this.array_[e]);\n    return t;\n  }, Lc.prototype.iterator = function () {\n    return new Oc(this);\n  };\n  var Oc = function Oc(t) {\n    this.treeSet_ = t, this.position_ = 0;\n  };\n  Oc.prototype.next = function () {\n    if (this.position_ === this.treeSet_.size()) throw new uc();\n    return this.treeSet_.array_[this.position_++];\n  }, Oc.prototype.hasNext = function () {\n    return this.position_ < this.treeSet_.size();\n  }, Oc.prototype.remove = function () {\n    throw new _c();\n  };\n  var Rc = function Rc() {};\n  Rc.sort = function () {\n    var t,\n      e,\n      n,\n      r,\n      i = arguments[0];\n    if (1 === arguments.length) r = function r(t, e) {\n      return t.compareTo(e);\n    }, i.sort(r);else if (2 === arguments.length) n = arguments[1], r = function r(t, e) {\n      return n.compare(t, e);\n    }, i.sort(r);else if (3 === arguments.length) {\n      (e = i.slice(arguments[1], arguments[2])).sort();\n      var o = i.slice(0, arguments[1]).concat(e, i.slice(arguments[2], i.length));\n      for (i.splice(0, i.length), t = 0; t < o.length; t++) i.push(o[t]);\n    } else if (4 === arguments.length) for (e = i.slice(arguments[1], arguments[2]), n = arguments[3], r = function r(t, e) {\n      return n.compare(t, e);\n    }, e.sort(r), o = i.slice(0, arguments[1]).concat(e, i.slice(arguments[2], i.length)), i.splice(0, i.length), t = 0; t < o.length; t++) i.push(o[t]);\n  }, Rc.asList = function (t) {\n    for (var e = new lc(), n = 0, r = t.length; n < r; n++) e.add(t[n]);\n    return e;\n  };\n  var Tc = function Tc() {},\n    Ac = {\n      P: {\n        configurable: !0\n      },\n      L: {\n        configurable: !0\n      },\n      A: {\n        configurable: !0\n      },\n      FALSE: {\n        configurable: !0\n      },\n      TRUE: {\n        configurable: !0\n      },\n      DONTCARE: {\n        configurable: !0\n      },\n      SYM_FALSE: {\n        configurable: !0\n      },\n      SYM_TRUE: {\n        configurable: !0\n      },\n      SYM_DONTCARE: {\n        configurable: !0\n      },\n      SYM_P: {\n        configurable: !0\n      },\n      SYM_L: {\n        configurable: !0\n      },\n      SYM_A: {\n        configurable: !0\n      }\n    };\n  Ac.P.get = function () {\n    return 0;\n  }, Ac.L.get = function () {\n    return 1;\n  }, Ac.A.get = function () {\n    return 2;\n  }, Ac.FALSE.get = function () {\n    return -1;\n  }, Ac.TRUE.get = function () {\n    return -2;\n  }, Ac.DONTCARE.get = function () {\n    return -3;\n  }, Ac.SYM_FALSE.get = function () {\n    return \"F\";\n  }, Ac.SYM_TRUE.get = function () {\n    return \"T\";\n  }, Ac.SYM_DONTCARE.get = function () {\n    return \"*\";\n  }, Ac.SYM_P.get = function () {\n    return \"0\";\n  }, Ac.SYM_L.get = function () {\n    return \"1\";\n  }, Ac.SYM_A.get = function () {\n    return \"2\";\n  }, Tc.prototype.interfaces_ = function () {\n    return [];\n  }, Tc.prototype.getClass = function () {\n    return Tc;\n  }, Tc.toDimensionSymbol = function (t) {\n    switch (t) {\n      case Tc.FALSE:\n        return Tc.SYM_FALSE;\n      case Tc.TRUE:\n        return Tc.SYM_TRUE;\n      case Tc.DONTCARE:\n        return Tc.SYM_DONTCARE;\n      case Tc.P:\n        return Tc.SYM_P;\n      case Tc.L:\n        return Tc.SYM_L;\n      case Tc.A:\n        return Tc.SYM_A;\n    }\n    throw new el(\"Unknown dimension value: \" + t);\n  }, Tc.toDimensionValue = function (t) {\n    switch (ml.toUpperCase(t)) {\n      case Tc.SYM_FALSE:\n        return Tc.FALSE;\n      case Tc.SYM_TRUE:\n        return Tc.TRUE;\n      case Tc.SYM_DONTCARE:\n        return Tc.DONTCARE;\n      case Tc.SYM_P:\n        return Tc.P;\n      case Tc.SYM_L:\n        return Tc.L;\n      case Tc.SYM_A:\n        return Tc.A;\n    }\n    throw new el(\"Unknown dimension symbol: \" + t);\n  }, Object.defineProperties(Tc, Ac);\n  var Dc = function Dc() {};\n  Dc.prototype.filter = function (t) {}, Dc.prototype.interfaces_ = function () {\n    return [];\n  }, Dc.prototype.getClass = function () {\n    return Dc;\n  };\n  var Fc = function Fc() {};\n  Fc.prototype.filter = function (t, e) {}, Fc.prototype.isDone = function () {}, Fc.prototype.isGeometryChanged = function () {}, Fc.prototype.interfaces_ = function () {\n    return [];\n  }, Fc.prototype.getClass = function () {\n    return Fc;\n  };\n  var kc = function (t) {\n      function e(e, n) {\n        if (t.call(this, n), this._geometries = e || [], t.hasNullElements(this._geometries)) throw new el(\"geometries must not contain null elements\");\n      }\n      t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;\n      var n = {\n        serialVersionUID: {\n          configurable: !0\n        }\n      };\n      return e.prototype.computeEnvelopeInternal = function () {\n        for (var t = new Ll(), e = 0; e < this._geometries.length; e++) t.expandToInclude(this._geometries[e].getEnvelopeInternal());\n        return t;\n      }, e.prototype.getGeometryN = function (t) {\n        return this._geometries[t];\n      }, e.prototype.getSortIndex = function () {\n        return t.SORTINDEX_GEOMETRYCOLLECTION;\n      }, e.prototype.getCoordinates = function () {\n        for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = 0; n < this._geometries.length; n++) for (var r = this._geometries[n].getCoordinates(), i = 0; i < r.length; i++) t[++e] = r[i];\n        return t;\n      }, e.prototype.getArea = function () {\n        for (var t = 0, e = 0; e < this._geometries.length; e++) t += this._geometries[e].getArea();\n        return t;\n      }, e.prototype.equalsExact = function () {\n        var e = this;\n        if (2 === arguments.length) {\n          var n = arguments[0],\n            r = arguments[1];\n          if (!this.isEquivalentClass(n)) return !1;\n          var i = n;\n          if (this._geometries.length !== i._geometries.length) return !1;\n          for (var o = 0; o < this._geometries.length; o++) if (!e._geometries[o].equalsExact(i._geometries[o], r)) return !1;\n          return !0;\n        }\n        return t.prototype.equalsExact.apply(this, arguments);\n      }, e.prototype.normalize = function () {\n        for (var t = 0; t < this._geometries.length; t++) this._geometries[t].normalize();\n        Rc.sort(this._geometries);\n      }, e.prototype.getCoordinate = function () {\n        return this.isEmpty() ? null : this._geometries[0].getCoordinate();\n      }, e.prototype.getBoundaryDimension = function () {\n        for (var t = Tc.FALSE, e = 0; e < this._geometries.length; e++) t = Math.max(t, this._geometries[e].getBoundaryDimension());\n        return t;\n      }, e.prototype.getDimension = function () {\n        for (var t = Tc.FALSE, e = 0; e < this._geometries.length; e++) t = Math.max(t, this._geometries[e].getDimension());\n        return t;\n      }, e.prototype.getLength = function () {\n        for (var t = 0, e = 0; e < this._geometries.length; e++) t += this._geometries[e].getLength();\n        return t;\n      }, e.prototype.getNumPoints = function () {\n        for (var t = 0, e = 0; e < this._geometries.length; e++) t += this._geometries[e].getNumPoints();\n        return t;\n      }, e.prototype.getNumGeometries = function () {\n        return this._geometries.length;\n      }, e.prototype.reverse = function () {\n        for (var t = this._geometries.length, e = new Array(t).fill(null), n = 0; n < this._geometries.length; n++) e[n] = this._geometries[n].reverse();\n        return this.getFactory().createGeometryCollection(e);\n      }, e.prototype.compareToSameClass = function () {\n        var t = this;\n        if (1 === arguments.length) {\n          var e = arguments[0],\n            n = new Lc(Rc.asList(this._geometries)),\n            r = new Lc(Rc.asList(e._geometries));\n          return this.compare(n, r);\n        }\n        if (2 === arguments.length) {\n          for (var i = arguments[0], o = arguments[1], s = i, a = this.getNumGeometries(), u = s.getNumGeometries(), l = 0; l < a && l < u;) {\n            var c = t.getGeometryN(l),\n              h = s.getGeometryN(l),\n              p = c.compareToSameClass(h, o);\n            if (0 !== p) return p;\n            l++;\n          }\n          return l < a ? 1 : l < u ? -1 : 0;\n        }\n      }, e.prototype.apply = function () {\n        var t = this;\n        if (gl(arguments[0], Kl)) for (var e = arguments[0], n = 0; n < this._geometries.length; n++) t._geometries[n].apply(e);else if (gl(arguments[0], Fc)) {\n          var r = arguments[0];\n          if (0 === this._geometries.length) return null;\n          for (var i = 0; i < this._geometries.length && (t._geometries[i].apply(r), !r.isDone()); i++);\n          r.isGeometryChanged() && this.geometryChanged();\n        } else if (gl(arguments[0], Dc)) {\n          var o = arguments[0];\n          o.filter(this);\n          for (var s = 0; s < this._geometries.length; s++) t._geometries[s].apply(o);\n        } else if (gl(arguments[0], Hl)) {\n          var a = arguments[0];\n          a.filter(this);\n          for (var u = 0; u < this._geometries.length; u++) t._geometries[u].apply(a);\n        }\n      }, e.prototype.getBoundary = function () {\n        return this.checkNotGeometryCollection(this), ql.shouldNeverReachHere(), null;\n      }, e.prototype.clone = function () {\n        var e = t.prototype.clone.call(this);\n        e._geometries = new Array(this._geometries.length).fill(null);\n        for (var n = 0; n < this._geometries.length; n++) e._geometries[n] = this._geometries[n].clone();\n        return e;\n      }, e.prototype.getGeometryType = function () {\n        return \"GeometryCollection\";\n      }, e.prototype.copy = function () {\n        for (var t = new Array(this._geometries.length).fill(null), n = 0; n < t.length; n++) t[n] = this._geometries[n].copy();\n        return new e(t, this._factory);\n      }, e.prototype.isEmpty = function () {\n        for (var t = 0; t < this._geometries.length; t++) if (!this._geometries[t].isEmpty()) return !1;\n        return !0;\n      }, e.prototype.interfaces_ = function () {\n        return [];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, n.serialVersionUID.get = function () {\n        return -0x4f07bcb1f857d800;\n      }, Object.defineProperties(e, n), e;\n    }(Wl),\n    Gc = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;\n      var n = {\n        serialVersionUID: {\n          configurable: !0\n        }\n      };\n      return e.prototype.getSortIndex = function () {\n        return Wl.SORTINDEX_MULTILINESTRING;\n      }, e.prototype.equalsExact = function () {\n        if (2 === arguments.length) {\n          var e = arguments[0],\n            n = arguments[1];\n          return !!this.isEquivalentClass(e) && t.prototype.equalsExact.call(this, e, n);\n        }\n        return t.prototype.equalsExact.apply(this, arguments);\n      }, e.prototype.getBoundaryDimension = function () {\n        return this.isClosed() ? Tc.FALSE : 0;\n      }, e.prototype.isClosed = function () {\n        if (this.isEmpty()) return !1;\n        for (var t = 0; t < this._geometries.length; t++) if (!this._geometries[t].isClosed()) return !1;\n        return !0;\n      }, e.prototype.getDimension = function () {\n        return 1;\n      }, e.prototype.reverse = function () {\n        for (var t = this._geometries.length, e = new Array(t).fill(null), n = 0; n < this._geometries.length; n++) e[t - 1 - n] = this._geometries[n].reverse();\n        return this.getFactory().createMultiLineString(e);\n      }, e.prototype.getBoundary = function () {\n        return new qc(this).getBoundary();\n      }, e.prototype.getGeometryType = function () {\n        return \"MultiLineString\";\n      }, e.prototype.copy = function () {\n        for (var t = new Array(this._geometries.length).fill(null), n = 0; n < t.length; n++) t[n] = this._geometries[n].copy();\n        return new e(t, this._factory);\n      }, e.prototype.interfaces_ = function () {\n        return [Pc];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, n.serialVersionUID.get = function () {\n        return 0x7155d2ab4afa8000;\n      }, Object.defineProperties(e, n), e;\n    }(kc),\n    qc = function qc() {\n      if (this._geom = null, this._geomFact = null, this._bnRule = null, this._endpointMap = null, 1 === arguments.length) {\n        var t = arguments[0],\n          e = Ql.MOD2_BOUNDARY_RULE;\n        this._geom = t, this._geomFact = t.getFactory(), this._bnRule = e;\n      } else if (2 === arguments.length) {\n        var n = arguments[0],\n          r = arguments[1];\n        this._geom = n, this._geomFact = n.getFactory(), this._bnRule = r;\n      }\n    };\n  qc.prototype.boundaryMultiLineString = function (t) {\n    if (this._geom.isEmpty()) return this.getEmptyMultiPoint();\n    var e = this.computeBoundaryCoordinates(t);\n    return 1 === e.length ? this._geomFact.createPoint(e[0]) : this._geomFact.createMultiPointFromCoords(e);\n  }, qc.prototype.getBoundary = function () {\n    return this._geom instanceof Zc ? this.boundaryLineString(this._geom) : this._geom instanceof Gc ? this.boundaryMultiLineString(this._geom) : this._geom.getBoundary();\n  }, qc.prototype.boundaryLineString = function (t) {\n    return this._geom.isEmpty() ? this.getEmptyMultiPoint() : t.isClosed() ? this._bnRule.isInBoundary(2) ? t.getStartPoint() : this._geomFact.createMultiPoint() : this._geomFact.createMultiPoint([t.getStartPoint(), t.getEndPoint()]);\n  }, qc.prototype.getEmptyMultiPoint = function () {\n    return this._geomFact.createMultiPoint();\n  }, qc.prototype.computeBoundaryCoordinates = function (t) {\n    var e = this,\n      n = new lc();\n    this._endpointMap = new Cc();\n    for (var r = 0; r < t.getNumGeometries(); r++) {\n      var i = t.getGeometryN(r);\n      0 !== i.getNumPoints() && (e.addEndpoint(i.getCoordinateN(0)), e.addEndpoint(i.getCoordinateN(i.getNumPoints() - 1)));\n    }\n    for (var o = this._endpointMap.entrySet().iterator(); o.hasNext();) {\n      var s = o.next(),\n        a = s.getValue().count;\n      e._bnRule.isInBoundary(a) && n.add(s.getKey());\n    }\n    return pc.toCoordinateArray(n);\n  }, qc.prototype.addEndpoint = function (t) {\n    var e = this._endpointMap.get(t);\n    null === e && (e = new Bc(), this._endpointMap.put(t, e)), e.count++;\n  }, qc.prototype.interfaces_ = function () {\n    return [];\n  }, qc.prototype.getClass = function () {\n    return qc;\n  }, qc.getBoundary = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0],\n        e = new qc(t);\n      return e.getBoundary();\n    }\n    if (2 === arguments.length) {\n      var n = arguments[0],\n        r = arguments[1],\n        i = new qc(n, r);\n      return i.getBoundary();\n    }\n  };\n  var Bc = function Bc() {\n    this.count = null;\n  };\n  function zc() {}\n  function jc() {}\n  Bc.prototype.interfaces_ = function () {\n    return [];\n  }, Bc.prototype.getClass = function () {\n    return Bc;\n  };\n  var Uc = function Uc() {};\n  function Vc() {}\n  function Xc() {}\n  function Yc() {}\n  var Hc = function Hc() {},\n    Wc = {\n      NEWLINE: {\n        configurable: !0\n      },\n      SIMPLE_ORDINATE_FORMAT: {\n        configurable: !0\n      }\n    };\n  Hc.prototype.interfaces_ = function () {\n    return [];\n  }, Hc.prototype.getClass = function () {\n    return Hc;\n  }, Hc.chars = function (t, e) {\n    for (var n = new Array(e).fill(null), r = 0; r < e; r++) n[r] = t;\n    return String(n);\n  }, Hc.getStackTrace = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0],\n        e = new Vc(),\n        n = new zc(e);\n      return t.printStackTrace(n), e.toString();\n    }\n    if (2 === arguments.length) {\n      for (var r = arguments[0], i = arguments[1], o = \"\", s = new jc(Hc.getStackTrace(r)), a = new Yc(s), u = 0; u < i; u++) try {\n        o += a.readLine() + Hc.NEWLINE;\n      } catch (t) {\n        if (!(t instanceof Xc)) throw t;\n        ql.shouldNeverReachHere();\n      }\n      return o;\n    }\n  }, Hc.split = function (t, e) {\n    for (var n = e.length, r = new lc(), i = \"\" + t, o = i.indexOf(e); o >= 0;) {\n      var s = i.substring(0, o);\n      r.add(s), o = (i = i.substring(o + n)).indexOf(e);\n    }\n    i.length > 0 && r.add(i);\n    for (var a = new Array(r.size()).fill(null), u = 0; u < a.length; u++) a[u] = r.get(u);\n    return a;\n  }, Hc.toString = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return Hc.SIMPLE_ORDINATE_FORMAT.format(t);\n    }\n  }, Hc.spaces = function (t) {\n    return Hc.chars(\" \", t);\n  }, Wc.NEWLINE.get = function () {\n    return Pl.getProperty(\"line.separator\");\n  }, Wc.SIMPLE_ORDINATE_FORMAT.get = function () {\n    return new Uc(\"0.#\");\n  }, Object.defineProperties(Hc, Wc);\n  var Jc = function Jc() {};\n  Jc.prototype.interfaces_ = function () {\n    return [];\n  }, Jc.prototype.getClass = function () {\n    return Jc;\n  }, Jc.copyCoord = function (t, e, n, r) {\n    for (var i = Math.min(t.getDimension(), n.getDimension()), o = 0; o < i; o++) n.setOrdinate(r, o, t.getOrdinate(e, o));\n  }, Jc.isRing = function (t) {\n    var e = t.size();\n    return 0 === e || !(e <= 3) && t.getOrdinate(0, Il.X) === t.getOrdinate(e - 1, Il.X) && t.getOrdinate(0, Il.Y) === t.getOrdinate(e - 1, Il.Y);\n  }, Jc.isEqual = function (t, e) {\n    var n = t.size();\n    if (n !== e.size()) return !1;\n    for (var r = Math.min(t.getDimension(), e.getDimension()), i = 0; i < n; i++) for (var o = 0; o < r; o++) {\n      var s = t.getOrdinate(i, o),\n        a = e.getOrdinate(i, o);\n      if (t.getOrdinate(i, o) !== e.getOrdinate(i, o) && (!nl.isNaN(s) || !nl.isNaN(a))) return !1;\n    }\n    return !0;\n  }, Jc.extend = function (t, e, n) {\n    var r = t.create(n, e.getDimension()),\n      i = e.size();\n    if (Jc.copy(e, 0, r, 0, i), i > 0) for (var o = i; o < n; o++) Jc.copy(e, i - 1, r, o, 1);\n    return r;\n  }, Jc.reverse = function (t) {\n    for (var e = t.size() - 1, n = Math.trunc(e / 2), r = 0; r <= n; r++) Jc.swap(t, r, e - r);\n  }, Jc.swap = function (t, e, n) {\n    if (e === n) return null;\n    for (var r = 0; r < t.getDimension(); r++) {\n      var i = t.getOrdinate(e, r);\n      t.setOrdinate(e, r, t.getOrdinate(n, r)), t.setOrdinate(n, r, i);\n    }\n  }, Jc.copy = function (t, e, n, r, i) {\n    for (var o = 0; o < i; o++) Jc.copyCoord(t, e + o, n, r + o);\n  }, Jc.toString = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0],\n        e = t.size();\n      if (0 === e) return \"()\";\n      var n = t.getDimension(),\n        r = new vl();\n      r.append(\"(\");\n      for (var i = 0; i < e; i++) {\n        i > 0 && r.append(\" \");\n        for (var o = 0; o < n; o++) o > 0 && r.append(\",\"), r.append(Hc.toString(t.getOrdinate(i, o)));\n      }\n      return r.append(\")\"), r.toString();\n    }\n  }, Jc.ensureValidRing = function (t, e) {\n    var n = e.size();\n    return 0 === n ? e : n <= 3 ? Jc.createClosedRing(t, e, 4) : e.getOrdinate(0, Il.X) === e.getOrdinate(n - 1, Il.X) && e.getOrdinate(0, Il.Y) === e.getOrdinate(n - 1, Il.Y) ? e : Jc.createClosedRing(t, e, n + 1);\n  }, Jc.createClosedRing = function (t, e, n) {\n    var r = t.create(n, e.getDimension()),\n      i = e.size();\n    Jc.copy(e, 0, r, 0, i);\n    for (var o = i; o < n; o++) Jc.copy(e, 0, r, o, 1);\n    return r;\n  };\n  var Zc = function (t) {\n      function e(e, n) {\n        t.call(this, n), this._points = null, this.init(e);\n      }\n      t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;\n      var n = {\n        serialVersionUID: {\n          configurable: !0\n        }\n      };\n      return e.prototype.computeEnvelopeInternal = function () {\n        return this.isEmpty() ? new Ll() : this._points.expandEnvelope(new Ll());\n      }, e.prototype.isRing = function () {\n        return this.isClosed() && this.isSimple();\n      }, e.prototype.getSortIndex = function () {\n        return t.SORTINDEX_LINESTRING;\n      }, e.prototype.getCoordinates = function () {\n        return this._points.toCoordinateArray();\n      }, e.prototype.equalsExact = function () {\n        var e = this;\n        if (2 === arguments.length) {\n          var n = arguments[0],\n            r = arguments[1];\n          if (!this.isEquivalentClass(n)) return !1;\n          var i = n;\n          if (this._points.size() !== i._points.size()) return !1;\n          for (var o = 0; o < this._points.size(); o++) if (!e.equal(e._points.getCoordinate(o), i._points.getCoordinate(o), r)) return !1;\n          return !0;\n        }\n        return t.prototype.equalsExact.apply(this, arguments);\n      }, e.prototype.normalize = function () {\n        for (var t = this, e = 0; e < Math.trunc(this._points.size() / 2); e++) {\n          var n = t._points.size() - 1 - e;\n          if (!t._points.getCoordinate(e).equals(t._points.getCoordinate(n))) return t._points.getCoordinate(e).compareTo(t._points.getCoordinate(n)) > 0 && Jc.reverse(t._points), null;\n        }\n      }, e.prototype.getCoordinate = function () {\n        return this.isEmpty() ? null : this._points.getCoordinate(0);\n      }, e.prototype.getBoundaryDimension = function () {\n        return this.isClosed() ? Tc.FALSE : 0;\n      }, e.prototype.isClosed = function () {\n        return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));\n      }, e.prototype.getEndPoint = function () {\n        return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1);\n      }, e.prototype.getDimension = function () {\n        return 1;\n      }, e.prototype.getLength = function () {\n        return Xl.computeLength(this._points);\n      }, e.prototype.getNumPoints = function () {\n        return this._points.size();\n      }, e.prototype.reverse = function () {\n        var t = this._points.copy();\n        return Jc.reverse(t), this.getFactory().createLineString(t);\n      }, e.prototype.compareToSameClass = function () {\n        var t = this;\n        if (1 === arguments.length) {\n          for (var e = arguments[0], n = e, r = 0, i = 0; r < this._points.size() && i < n._points.size();) {\n            var o = t._points.getCoordinate(r).compareTo(n._points.getCoordinate(i));\n            if (0 !== o) return o;\n            r++, i++;\n          }\n          return r < this._points.size() ? 1 : i < n._points.size() ? -1 : 0;\n        }\n        if (2 === arguments.length) {\n          var s = arguments[0],\n            a = arguments[1],\n            u = s;\n          return a.compare(this._points, u._points);\n        }\n      }, e.prototype.apply = function () {\n        var t = this;\n        if (gl(arguments[0], Kl)) for (var e = arguments[0], n = 0; n < this._points.size(); n++) e.filter(t._points.getCoordinate(n));else if (gl(arguments[0], Fc)) {\n          var r = arguments[0];\n          if (0 === this._points.size()) return null;\n          for (var i = 0; i < this._points.size() && (r.filter(t._points, i), !r.isDone()); i++);\n          r.isGeometryChanged() && this.geometryChanged();\n        } else if (gl(arguments[0], Dc)) {\n          var o = arguments[0];\n          o.filter(this);\n        } else if (gl(arguments[0], Hl)) {\n          var s = arguments[0];\n          s.filter(this);\n        }\n      }, e.prototype.getBoundary = function () {\n        return new qc(this).getBoundary();\n      }, e.prototype.isEquivalentClass = function (t) {\n        return t instanceof e;\n      }, e.prototype.clone = function () {\n        var e = t.prototype.clone.call(this);\n        return e._points = this._points.clone(), e;\n      }, e.prototype.getCoordinateN = function (t) {\n        return this._points.getCoordinate(t);\n      }, e.prototype.getGeometryType = function () {\n        return \"LineString\";\n      }, e.prototype.copy = function () {\n        return new e(this._points.copy(), this._factory);\n      }, e.prototype.getCoordinateSequence = function () {\n        return this._points;\n      }, e.prototype.isEmpty = function () {\n        return 0 === this._points.size();\n      }, e.prototype.init = function (t) {\n        if (null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), 1 === t.size()) throw new el(\"Invalid number of points in LineString (found \" + t.size() + \" - must be 0 or >= 2)\");\n        this._points = t;\n      }, e.prototype.isCoordinate = function (t) {\n        for (var e = 0; e < this._points.size(); e++) if (this._points.getCoordinate(e).equals(t)) return !0;\n        return !1;\n      }, e.prototype.getStartPoint = function () {\n        return this.isEmpty() ? null : this.getPointN(0);\n      }, e.prototype.getPointN = function (t) {\n        return this.getFactory().createPoint(this._points.getCoordinate(t));\n      }, e.prototype.interfaces_ = function () {\n        return [Pc];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, n.serialVersionUID.get = function () {\n        return 0x2b2b51ba435c8e00;\n      }, Object.defineProperties(e, n), e;\n    }(Wl),\n    Kc = function Kc() {};\n  Kc.prototype.interfaces_ = function () {\n    return [];\n  }, Kc.prototype.getClass = function () {\n    return Kc;\n  };\n  var Qc = function (t) {\n      function e(e, n) {\n        t.call(this, n), this._coordinates = e || null, this.init(this._coordinates);\n      }\n      t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;\n      var n = {\n        serialVersionUID: {\n          configurable: !0\n        }\n      };\n      return e.prototype.computeEnvelopeInternal = function () {\n        if (this.isEmpty()) return new Ll();\n        var t = new Ll();\n        return t.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), t;\n      }, e.prototype.getSortIndex = function () {\n        return t.SORTINDEX_POINT;\n      }, e.prototype.getCoordinates = function () {\n        return this.isEmpty() ? [] : [this.getCoordinate()];\n      }, e.prototype.equalsExact = function () {\n        if (2 === arguments.length) {\n          var e = arguments[0],\n            n = arguments[1];\n          return !!this.isEquivalentClass(e) && (!(!this.isEmpty() || !e.isEmpty()) || this.isEmpty() === e.isEmpty() && this.equal(e.getCoordinate(), this.getCoordinate(), n));\n        }\n        return t.prototype.equalsExact.apply(this, arguments);\n      }, e.prototype.normalize = function () {}, e.prototype.getCoordinate = function () {\n        return 0 !== this._coordinates.size() ? this._coordinates.getCoordinate(0) : null;\n      }, e.prototype.getBoundaryDimension = function () {\n        return Tc.FALSE;\n      }, e.prototype.getDimension = function () {\n        return 0;\n      }, e.prototype.getNumPoints = function () {\n        return this.isEmpty() ? 0 : 1;\n      }, e.prototype.reverse = function () {\n        return this.copy();\n      }, e.prototype.getX = function () {\n        if (null === this.getCoordinate()) throw new Error(\"getX called on empty Point\");\n        return this.getCoordinate().x;\n      }, e.prototype.compareToSameClass = function () {\n        if (1 === arguments.length) {\n          var t = arguments[0],\n            e = t;\n          return this.getCoordinate().compareTo(e.getCoordinate());\n        }\n        if (2 === arguments.length) {\n          var n = arguments[0],\n            r = arguments[1],\n            i = n;\n          return r.compare(this._coordinates, i._coordinates);\n        }\n      }, e.prototype.apply = function () {\n        if (gl(arguments[0], Kl)) {\n          var t = arguments[0];\n          if (this.isEmpty()) return null;\n          t.filter(this.getCoordinate());\n        } else if (gl(arguments[0], Fc)) {\n          var e = arguments[0];\n          if (this.isEmpty()) return null;\n          e.filter(this._coordinates, 0), e.isGeometryChanged() && this.geometryChanged();\n        } else if (gl(arguments[0], Dc)) {\n          var n = arguments[0];\n          n.filter(this);\n        } else if (gl(arguments[0], Hl)) {\n          var r = arguments[0];\n          r.filter(this);\n        }\n      }, e.prototype.getBoundary = function () {\n        return this.getFactory().createGeometryCollection(null);\n      }, e.prototype.clone = function () {\n        var e = t.prototype.clone.call(this);\n        return e._coordinates = this._coordinates.clone(), e;\n      }, e.prototype.getGeometryType = function () {\n        return \"Point\";\n      }, e.prototype.copy = function () {\n        return new e(this._coordinates.copy(), this._factory);\n      }, e.prototype.getCoordinateSequence = function () {\n        return this._coordinates;\n      }, e.prototype.getY = function () {\n        if (null === this.getCoordinate()) throw new Error(\"getY called on empty Point\");\n        return this.getCoordinate().y;\n      }, e.prototype.isEmpty = function () {\n        return 0 === this._coordinates.size();\n      }, e.prototype.init = function (t) {\n        null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), ql.isTrue(t.size() <= 1), this._coordinates = t;\n      }, e.prototype.isSimple = function () {\n        return !0;\n      }, e.prototype.interfaces_ = function () {\n        return [Kc];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, n.serialVersionUID.get = function () {\n        return 0x44077bad161cbc00;\n      }, Object.defineProperties(e, n), e;\n    }(Wl),\n    $c = function $c() {};\n  $c.prototype.interfaces_ = function () {\n    return [];\n  }, $c.prototype.getClass = function () {\n    return $c;\n  };\n  var th = function (t) {\n      function e(e, n, r) {\n        if (t.call(this, r), this._shell = null, this._holes = null, null === e && (e = this.getFactory().createLinearRing()), null === n && (n = []), t.hasNullElements(n)) throw new el(\"holes must not contain null elements\");\n        if (e.isEmpty() && t.hasNonEmptyElements(n)) throw new el(\"shell is empty but holes are not\");\n        this._shell = e, this._holes = n;\n      }\n      t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;\n      var n = {\n        serialVersionUID: {\n          configurable: !0\n        }\n      };\n      return e.prototype.computeEnvelopeInternal = function () {\n        return this._shell.getEnvelopeInternal();\n      }, e.prototype.getSortIndex = function () {\n        return t.SORTINDEX_POLYGON;\n      }, e.prototype.getCoordinates = function () {\n        if (this.isEmpty()) return [];\n        for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = this._shell.getCoordinates(), r = 0; r < n.length; r++) t[++e] = n[r];\n        for (var i = 0; i < this._holes.length; i++) for (var o = this._holes[i].getCoordinates(), s = 0; s < o.length; s++) t[++e] = o[s];\n        return t;\n      }, e.prototype.getArea = function () {\n        var t = 0;\n        t += Math.abs(Xl.signedArea(this._shell.getCoordinateSequence()));\n        for (var e = 0; e < this._holes.length; e++) t -= Math.abs(Xl.signedArea(this._holes[e].getCoordinateSequence()));\n        return t;\n      }, e.prototype.isRectangle = function () {\n        if (0 !== this.getNumInteriorRing()) return !1;\n        if (null === this._shell) return !1;\n        if (5 !== this._shell.getNumPoints()) return !1;\n        for (var t = this._shell.getCoordinateSequence(), e = this.getEnvelopeInternal(), n = 0; n < 5; n++) {\n          var r = t.getX(n);\n          if (r !== e.getMinX() && r !== e.getMaxX()) return !1;\n          var i = t.getY(n);\n          if (i !== e.getMinY() && i !== e.getMaxY()) return !1;\n        }\n        for (var o = t.getX(0), s = t.getY(0), a = 1; a <= 4; a++) {\n          var u = t.getX(a),\n            l = t.getY(a);\n          if (u !== o === (l !== s)) return !1;\n          o = u, s = l;\n        }\n        return !0;\n      }, e.prototype.equalsExact = function () {\n        var e = this;\n        if (2 === arguments.length) {\n          var n = arguments[0],\n            r = arguments[1];\n          if (!this.isEquivalentClass(n)) return !1;\n          var i = n,\n            o = this._shell,\n            s = i._shell;\n          if (!o.equalsExact(s, r)) return !1;\n          if (this._holes.length !== i._holes.length) return !1;\n          for (var a = 0; a < this._holes.length; a++) if (!e._holes[a].equalsExact(i._holes[a], r)) return !1;\n          return !0;\n        }\n        return t.prototype.equalsExact.apply(this, arguments);\n      }, e.prototype.normalize = function () {\n        var t = this;\n        if (0 === arguments.length) {\n          this.normalize(this._shell, !0);\n          for (var e = 0; e < this._holes.length; e++) t.normalize(t._holes[e], !1);\n          Rc.sort(this._holes);\n        } else if (2 === arguments.length) {\n          var n = arguments[0],\n            r = arguments[1];\n          if (n.isEmpty()) return null;\n          var i = new Array(n.getCoordinates().length - 1).fill(null);\n          Pl.arraycopy(n.getCoordinates(), 0, i, 0, i.length);\n          var o = pc.minCoordinate(n.getCoordinates());\n          pc.scroll(i, o), Pl.arraycopy(i, 0, n.getCoordinates(), 0, i.length), n.getCoordinates()[i.length] = i[0], Xl.isCCW(n.getCoordinates()) === r && pc.reverse(n.getCoordinates());\n        }\n      }, e.prototype.getCoordinate = function () {\n        return this._shell.getCoordinate();\n      }, e.prototype.getNumInteriorRing = function () {\n        return this._holes.length;\n      }, e.prototype.getBoundaryDimension = function () {\n        return 1;\n      }, e.prototype.getDimension = function () {\n        return 2;\n      }, e.prototype.getLength = function () {\n        var t = 0;\n        t += this._shell.getLength();\n        for (var e = 0; e < this._holes.length; e++) t += this._holes[e].getLength();\n        return t;\n      }, e.prototype.getNumPoints = function () {\n        for (var t = this._shell.getNumPoints(), e = 0; e < this._holes.length; e++) t += this._holes[e].getNumPoints();\n        return t;\n      }, e.prototype.reverse = function () {\n        var t = this.copy();\n        t._shell = this._shell.copy().reverse(), t._holes = new Array(this._holes.length).fill(null);\n        for (var e = 0; e < this._holes.length; e++) t._holes[e] = this._holes[e].copy().reverse();\n        return t;\n      }, e.prototype.convexHull = function () {\n        return this.getExteriorRing().convexHull();\n      }, e.prototype.compareToSameClass = function () {\n        var t = this;\n        if (1 === arguments.length) {\n          var e = arguments[0],\n            n = this._shell,\n            r = e._shell;\n          return n.compareToSameClass(r);\n        }\n        if (2 === arguments.length) {\n          var i = arguments[0],\n            o = arguments[1],\n            s = i,\n            a = this._shell,\n            u = s._shell,\n            l = a.compareToSameClass(u, o);\n          if (0 !== l) return l;\n          for (var c = this.getNumInteriorRing(), h = s.getNumInteriorRing(), p = 0; p < c && p < h;) {\n            var f = t.getInteriorRingN(p),\n              g = s.getInteriorRingN(p),\n              d = f.compareToSameClass(g, o);\n            if (0 !== d) return d;\n            p++;\n          }\n          return p < c ? 1 : p < h ? -1 : 0;\n        }\n      }, e.prototype.apply = function (t) {\n        var e = this;\n        if (gl(t, Kl)) {\n          this._shell.apply(t);\n          for (var n = 0; n < this._holes.length; n++) e._holes[n].apply(t);\n        } else if (gl(t, Fc)) {\n          if (this._shell.apply(t), !t.isDone()) for (var r = 0; r < this._holes.length && (e._holes[r].apply(t), !t.isDone()); r++);\n          t.isGeometryChanged() && this.geometryChanged();\n        } else if (gl(t, Dc)) t.filter(this);else if (gl(t, Hl)) {\n          t.filter(this), this._shell.apply(t);\n          for (var i = 0; i < this._holes.length; i++) e._holes[i].apply(t);\n        }\n      }, e.prototype.getBoundary = function () {\n        if (this.isEmpty()) return this.getFactory().createMultiLineString();\n        var t = new Array(this._holes.length + 1).fill(null);\n        t[0] = this._shell;\n        for (var e = 0; e < this._holes.length; e++) t[e + 1] = this._holes[e];\n        return t.length <= 1 ? this.getFactory().createLinearRing(t[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(t);\n      }, e.prototype.clone = function () {\n        var e = t.prototype.clone.call(this);\n        e._shell = this._shell.clone(), e._holes = new Array(this._holes.length).fill(null);\n        for (var n = 0; n < this._holes.length; n++) e._holes[n] = this._holes[n].clone();\n        return e;\n      }, e.prototype.getGeometryType = function () {\n        return \"Polygon\";\n      }, e.prototype.copy = function () {\n        for (var t = this._shell.copy(), n = new Array(this._holes.length).fill(null), r = 0; r < n.length; r++) n[r] = this._holes[r].copy();\n        return new e(t, n, this._factory);\n      }, e.prototype.getExteriorRing = function () {\n        return this._shell;\n      }, e.prototype.isEmpty = function () {\n        return this._shell.isEmpty();\n      }, e.prototype.getInteriorRingN = function (t) {\n        return this._holes[t];\n      }, e.prototype.interfaces_ = function () {\n        return [$c];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, n.serialVersionUID.get = function () {\n        return -0x307ffefd8dc97200;\n      }, Object.defineProperties(e, n), e;\n    }(Wl),\n    eh = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;\n      var n = {\n        serialVersionUID: {\n          configurable: !0\n        }\n      };\n      return e.prototype.getSortIndex = function () {\n        return Wl.SORTINDEX_MULTIPOINT;\n      }, e.prototype.isValid = function () {\n        return !0;\n      }, e.prototype.equalsExact = function () {\n        if (2 === arguments.length) {\n          var e = arguments[0],\n            n = arguments[1];\n          return !!this.isEquivalentClass(e) && t.prototype.equalsExact.call(this, e, n);\n        }\n        return t.prototype.equalsExact.apply(this, arguments);\n      }, e.prototype.getCoordinate = function () {\n        if (1 === arguments.length) {\n          var e = arguments[0];\n          return this._geometries[e].getCoordinate();\n        }\n        return t.prototype.getCoordinate.apply(this, arguments);\n      }, e.prototype.getBoundaryDimension = function () {\n        return Tc.FALSE;\n      }, e.prototype.getDimension = function () {\n        return 0;\n      }, e.prototype.getBoundary = function () {\n        return this.getFactory().createGeometryCollection(null);\n      }, e.prototype.getGeometryType = function () {\n        return \"MultiPoint\";\n      }, e.prototype.copy = function () {\n        for (var t = new Array(this._geometries.length).fill(null), n = 0; n < t.length; n++) t[n] = this._geometries[n].copy();\n        return new e(t, this._factory);\n      }, e.prototype.interfaces_ = function () {\n        return [Kc];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, n.serialVersionUID.get = function () {\n        return -0x6fb1ed4162e0fc00;\n      }, Object.defineProperties(e, n), e;\n    }(kc),\n    nh = function (t) {\n      function e(e, n) {\n        e instanceof ul && n instanceof _h && (e = n.getCoordinateSequenceFactory().create(e)), t.call(this, e, n), this.validateConstruction();\n      }\n      t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;\n      var n = {\n        MINIMUM_VALID_SIZE: {\n          configurable: !0\n        },\n        serialVersionUID: {\n          configurable: !0\n        }\n      };\n      return e.prototype.getSortIndex = function () {\n        return Wl.SORTINDEX_LINEARRING;\n      }, e.prototype.getBoundaryDimension = function () {\n        return Tc.FALSE;\n      }, e.prototype.isClosed = function () {\n        return !!this.isEmpty() || t.prototype.isClosed.call(this);\n      }, e.prototype.reverse = function () {\n        var t = this._points.copy();\n        return Jc.reverse(t), this.getFactory().createLinearRing(t);\n      }, e.prototype.validateConstruction = function () {\n        if (!this.isEmpty() && !t.prototype.isClosed.call(this)) throw new el(\"Points of LinearRing do not form a closed linestring\");\n        if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < e.MINIMUM_VALID_SIZE) throw new el(\"Invalid number of points in LinearRing (found \" + this.getCoordinateSequence().size() + \" - must be 0 or >= 4)\");\n      }, e.prototype.getGeometryType = function () {\n        return \"LinearRing\";\n      }, e.prototype.copy = function () {\n        return new e(this._points.copy(), this._factory);\n      }, e.prototype.interfaces_ = function () {\n        return [];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, n.MINIMUM_VALID_SIZE.get = function () {\n        return 4;\n      }, n.serialVersionUID.get = function () {\n        return -0x3b229e262367a600;\n      }, Object.defineProperties(e, n), e;\n    }(Zc),\n    rh = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;\n      var n = {\n        serialVersionUID: {\n          configurable: !0\n        }\n      };\n      return e.prototype.getSortIndex = function () {\n        return Wl.SORTINDEX_MULTIPOLYGON;\n      }, e.prototype.equalsExact = function () {\n        if (2 === arguments.length) {\n          var e = arguments[0],\n            n = arguments[1];\n          return !!this.isEquivalentClass(e) && t.prototype.equalsExact.call(this, e, n);\n        }\n        return t.prototype.equalsExact.apply(this, arguments);\n      }, e.prototype.getBoundaryDimension = function () {\n        return 1;\n      }, e.prototype.getDimension = function () {\n        return 2;\n      }, e.prototype.reverse = function () {\n        for (var t = this._geometries.length, e = new Array(t).fill(null), n = 0; n < this._geometries.length; n++) e[n] = this._geometries[n].reverse();\n        return this.getFactory().createMultiPolygon(e);\n      }, e.prototype.getBoundary = function () {\n        if (this.isEmpty()) return this.getFactory().createMultiLineString();\n        for (var t = new lc(), e = 0; e < this._geometries.length; e++) for (var n = this._geometries[e].getBoundary(), r = 0; r < n.getNumGeometries(); r++) t.add(n.getGeometryN(r));\n        var i = new Array(t.size()).fill(null);\n        return this.getFactory().createMultiLineString(t.toArray(i));\n      }, e.prototype.getGeometryType = function () {\n        return \"MultiPolygon\";\n      }, e.prototype.copy = function () {\n        for (var t = new Array(this._geometries.length).fill(null), n = 0; n < t.length; n++) t[n] = this._geometries[n].copy();\n        return new e(t, this._factory);\n      }, e.prototype.interfaces_ = function () {\n        return [$c];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, n.serialVersionUID.get = function () {\n        return -0x7a5aa1369171980;\n      }, Object.defineProperties(e, n), e;\n    }(kc),\n    ih = function ih(t) {\n      this._factory = t || null, this._isUserDataCopied = !1;\n    },\n    oh = {\n      NoOpGeometryOperation: {\n        configurable: !0\n      },\n      CoordinateOperation: {\n        configurable: !0\n      },\n      CoordinateSequenceOperation: {\n        configurable: !0\n      }\n    };\n  ih.prototype.setCopyUserData = function (t) {\n    this._isUserDataCopied = t;\n  }, ih.prototype.edit = function (t, e) {\n    if (null === t) return null;\n    var n = this.editInternal(t, e);\n    return this._isUserDataCopied && n.setUserData(t.getUserData()), n;\n  }, ih.prototype.editInternal = function (t, e) {\n    return null === this._factory && (this._factory = t.getFactory()), t instanceof kc ? this.editGeometryCollection(t, e) : t instanceof th ? this.editPolygon(t, e) : t instanceof Qc || t instanceof Zc ? e.edit(t, this._factory) : (ql.shouldNeverReachHere(\"Unsupported Geometry class: \" + t.getClass().getName()), null);\n  }, ih.prototype.editGeometryCollection = function (t, e) {\n    for (var n = e.edit(t, this._factory), r = new lc(), i = 0; i < n.getNumGeometries(); i++) {\n      var o = this.edit(n.getGeometryN(i), e);\n      null === o || o.isEmpty() || r.add(o);\n    }\n    return n.getClass() === eh ? this._factory.createMultiPoint(r.toArray([])) : n.getClass() === Gc ? this._factory.createMultiLineString(r.toArray([])) : n.getClass() === rh ? this._factory.createMultiPolygon(r.toArray([])) : this._factory.createGeometryCollection(r.toArray([]));\n  }, ih.prototype.editPolygon = function (t, e) {\n    var n = e.edit(t, this._factory);\n    if (null === n && (n = this._factory.createPolygon(null)), n.isEmpty()) return n;\n    var r = this.edit(n.getExteriorRing(), e);\n    if (null === r || r.isEmpty()) return this._factory.createPolygon();\n    for (var i = new lc(), o = 0; o < n.getNumInteriorRing(); o++) {\n      var s = this.edit(n.getInteriorRingN(o), e);\n      null === s || s.isEmpty() || i.add(s);\n    }\n    return this._factory.createPolygon(r, i.toArray([]));\n  }, ih.prototype.interfaces_ = function () {\n    return [];\n  }, ih.prototype.getClass = function () {\n    return ih;\n  }, ih.GeometryEditorOperation = function () {}, oh.NoOpGeometryOperation.get = function () {\n    return sh;\n  }, oh.CoordinateOperation.get = function () {\n    return ah;\n  }, oh.CoordinateSequenceOperation.get = function () {\n    return uh;\n  }, Object.defineProperties(ih, oh);\n  var sh = function sh() {};\n  sh.prototype.edit = function (t, e) {\n    return t;\n  }, sh.prototype.interfaces_ = function () {\n    return [ih.GeometryEditorOperation];\n  }, sh.prototype.getClass = function () {\n    return sh;\n  };\n  var ah = function ah() {};\n  ah.prototype.edit = function (t, e) {\n    var n = this.editCoordinates(t.getCoordinates(), t);\n    return null === n ? t : t instanceof nh ? e.createLinearRing(n) : t instanceof Zc ? e.createLineString(n) : t instanceof Qc ? n.length > 0 ? e.createPoint(n[0]) : e.createPoint() : t;\n  }, ah.prototype.interfaces_ = function () {\n    return [ih.GeometryEditorOperation];\n  }, ah.prototype.getClass = function () {\n    return ah;\n  };\n  var uh = function uh() {};\n  uh.prototype.edit = function (t, e) {\n    return t instanceof nh ? e.createLinearRing(this.edit(t.getCoordinateSequence(), t)) : t instanceof Zc ? e.createLineString(this.edit(t.getCoordinateSequence(), t)) : t instanceof Qc ? e.createPoint(this.edit(t.getCoordinateSequence(), t)) : t;\n  }, uh.prototype.interfaces_ = function () {\n    return [ih.GeometryEditorOperation];\n  }, uh.prototype.getClass = function () {\n    return uh;\n  };\n  var lh = function lh() {\n      var t = this;\n      if (this._dimension = 3, this._coordinates = null, 1 === arguments.length) {\n        if (arguments[0] instanceof Array) this._coordinates = arguments[0], this._dimension = 3;else if (Number.isInteger(arguments[0])) {\n          var e = arguments[0];\n          this._coordinates = new Array(e).fill(null);\n          for (var n = 0; n < e; n++) t._coordinates[n] = new ul();\n        } else if (gl(arguments[0], Il)) {\n          var r = arguments[0];\n          if (null === r) return this._coordinates = new Array(0).fill(null), null;\n          this._dimension = r.getDimension(), this._coordinates = new Array(r.size()).fill(null);\n          for (var i = 0; i < this._coordinates.length; i++) t._coordinates[i] = r.getCoordinateCopy(i);\n        }\n      } else if (2 === arguments.length) if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {\n        var o = arguments[0],\n          s = arguments[1];\n        this._coordinates = o, this._dimension = s, null === o && (this._coordinates = new Array(0).fill(null));\n      } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n        var a = arguments[0],\n          u = arguments[1];\n        this._coordinates = new Array(a).fill(null), this._dimension = u;\n        for (var l = 0; l < a; l++) t._coordinates[l] = new ul();\n      }\n    },\n    ch = {\n      serialVersionUID: {\n        configurable: !0\n      }\n    };\n  lh.prototype.setOrdinate = function (t, e, n) {\n    switch (e) {\n      case Il.X:\n        this._coordinates[t].x = n;\n        break;\n      case Il.Y:\n        this._coordinates[t].y = n;\n        break;\n      case Il.Z:\n        this._coordinates[t].z = n;\n        break;\n      default:\n        throw new el(\"invalid ordinateIndex\");\n    }\n  }, lh.prototype.size = function () {\n    return this._coordinates.length;\n  }, lh.prototype.getOrdinate = function (t, e) {\n    switch (e) {\n      case Il.X:\n        return this._coordinates[t].x;\n      case Il.Y:\n        return this._coordinates[t].y;\n      case Il.Z:\n        return this._coordinates[t].z;\n    }\n    return nl.NaN;\n  }, lh.prototype.getCoordinate = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return this._coordinates[t];\n    }\n    if (2 === arguments.length) {\n      var e = arguments[0],\n        n = arguments[1];\n      n.x = this._coordinates[e].x, n.y = this._coordinates[e].y, n.z = this._coordinates[e].z;\n    }\n  }, lh.prototype.getCoordinateCopy = function (t) {\n    return new ul(this._coordinates[t]);\n  }, lh.prototype.getDimension = function () {\n    return this._dimension;\n  }, lh.prototype.getX = function (t) {\n    return this._coordinates[t].x;\n  }, lh.prototype.clone = function () {\n    for (var t = new Array(this.size()).fill(null), e = 0; e < this._coordinates.length; e++) t[e] = this._coordinates[e].clone();\n    return new lh(t, this._dimension);\n  }, lh.prototype.expandEnvelope = function (t) {\n    for (var e = 0; e < this._coordinates.length; e++) t.expandToInclude(this._coordinates[e]);\n    return t;\n  }, lh.prototype.copy = function () {\n    for (var t = new Array(this.size()).fill(null), e = 0; e < this._coordinates.length; e++) t[e] = this._coordinates[e].copy();\n    return new lh(t, this._dimension);\n  }, lh.prototype.toString = function () {\n    if (this._coordinates.length > 0) {\n      var t = new vl(17 * this._coordinates.length);\n      t.append(\"(\"), t.append(this._coordinates[0]);\n      for (var e = 1; e < this._coordinates.length; e++) t.append(\", \"), t.append(this._coordinates[e]);\n      return t.append(\")\"), t.toString();\n    }\n    return \"()\";\n  }, lh.prototype.getY = function (t) {\n    return this._coordinates[t].y;\n  }, lh.prototype.toCoordinateArray = function () {\n    return this._coordinates;\n  }, lh.prototype.interfaces_ = function () {\n    return [Il, al];\n  }, lh.prototype.getClass = function () {\n    return lh;\n  }, ch.serialVersionUID.get = function () {\n    return -0xcb44a778db18e00;\n  }, Object.defineProperties(lh, ch);\n  var hh = function hh() {},\n    ph = {\n      serialVersionUID: {\n        configurable: !0\n      },\n      instanceObject: {\n        configurable: !0\n      }\n    };\n  hh.prototype.readResolve = function () {\n    return hh.instance();\n  }, hh.prototype.create = function () {\n    if (1 === arguments.length) {\n      if (arguments[0] instanceof Array) {\n        var t = arguments[0];\n        return new lh(t);\n      }\n      if (gl(arguments[0], Il)) {\n        var e = arguments[0];\n        return new lh(e);\n      }\n    } else if (2 === arguments.length) {\n      var n = arguments[0],\n        r = arguments[1];\n      return r > 3 && (r = 3), r < 2 ? new lh(n) : new lh(n, r);\n    }\n  }, hh.prototype.interfaces_ = function () {\n    return [hl, al];\n  }, hh.prototype.getClass = function () {\n    return hh;\n  }, hh.instance = function () {\n    return hh.instanceObject;\n  }, ph.serialVersionUID.get = function () {\n    return -0x38e49fa6cf6f2e00;\n  }, ph.instanceObject.get = function () {\n    return new hh();\n  }, Object.defineProperties(hh, ph);\n  var fh = function (t) {\n      function e() {\n        t.call(this), this.map_ = new Map();\n      }\n      return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.get = function (t) {\n        return this.map_.get(t) || null;\n      }, e.prototype.put = function (t, e) {\n        return this.map_.set(t, e), e;\n      }, e.prototype.values = function () {\n        for (var t = new lc(), e = this.map_.values(), n = e.next(); !n.done;) t.add(n.value), n = e.next();\n        return t;\n      }, e.prototype.entrySet = function () {\n        var t = new xc();\n        return this.map_.entries().forEach(function (e) {\n          return t.add(e);\n        }), t;\n      }, e.prototype.size = function () {\n        return this.map_.size();\n      }, e;\n    }(yc),\n    gh = function t() {\n      if (this._modelType = null, this._scale = null, 0 === arguments.length) this._modelType = t.FLOATING;else if (1 === arguments.length) if (arguments[0] instanceof yh) {\n        var e = arguments[0];\n        this._modelType = e, e === t.FIXED && this.setScale(1);\n      } else if (\"number\" == typeof arguments[0]) {\n        var n = arguments[0];\n        this._modelType = t.FIXED, this.setScale(n);\n      } else if (arguments[0] instanceof t) {\n        var r = arguments[0];\n        this._modelType = r._modelType, this._scale = r._scale;\n      }\n    },\n    dh = {\n      serialVersionUID: {\n        configurable: !0\n      },\n      maximumPreciseValue: {\n        configurable: !0\n      }\n    };\n  gh.prototype.equals = function (t) {\n    if (!(t instanceof gh)) return !1;\n    var e = t;\n    return this._modelType === e._modelType && this._scale === e._scale;\n  }, gh.prototype.compareTo = function (t) {\n    var e = t,\n      n = this.getMaximumSignificantDigits(),\n      r = e.getMaximumSignificantDigits();\n    return new _l(n).compareTo(new _l(r));\n  }, gh.prototype.getScale = function () {\n    return this._scale;\n  }, gh.prototype.isFloating = function () {\n    return this._modelType === gh.FLOATING || this._modelType === gh.FLOATING_SINGLE;\n  }, gh.prototype.getType = function () {\n    return this._modelType;\n  }, gh.prototype.toString = function () {\n    var t = \"UNKNOWN\";\n    return this._modelType === gh.FLOATING ? t = \"Floating\" : this._modelType === gh.FLOATING_SINGLE ? t = \"Floating-Single\" : this._modelType === gh.FIXED && (t = \"Fixed (Scale=\" + this.getScale() + \")\"), t;\n  }, gh.prototype.makePrecise = function () {\n    if (\"number\" == typeof arguments[0]) {\n      var t = arguments[0];\n      if (nl.isNaN(t)) return t;\n      if (this._modelType === gh.FLOATING_SINGLE) {\n        return t;\n      }\n      return this._modelType === gh.FIXED ? Math.round(t * this._scale) / this._scale : t;\n    }\n    if (arguments[0] instanceof ul) {\n      var e = arguments[0];\n      if (this._modelType === gh.FLOATING) return null;\n      e.x = this.makePrecise(e.x), e.y = this.makePrecise(e.y);\n    }\n  }, gh.prototype.getMaximumSignificantDigits = function () {\n    var t = 16;\n    return this._modelType === gh.FLOATING ? t = 16 : this._modelType === gh.FLOATING_SINGLE ? t = 6 : this._modelType === gh.FIXED && (t = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), t;\n  }, gh.prototype.setScale = function (t) {\n    this._scale = Math.abs(t);\n  }, gh.prototype.interfaces_ = function () {\n    return [al, il];\n  }, gh.prototype.getClass = function () {\n    return gh;\n  }, gh.mostPrecise = function (t, e) {\n    return t.compareTo(e) >= 0 ? t : e;\n  }, dh.serialVersionUID.get = function () {\n    return 0x6bee6404e9a25c00;\n  }, dh.maximumPreciseValue.get = function () {\n    return 9007199254740992;\n  }, Object.defineProperties(gh, dh);\n  var yh = function t(e) {\n      this._name = e || null, t.nameToTypeMap.put(e, this);\n    },\n    vh = {\n      serialVersionUID: {\n        configurable: !0\n      },\n      nameToTypeMap: {\n        configurable: !0\n      }\n    };\n  yh.prototype.readResolve = function () {\n    return yh.nameToTypeMap.get(this._name);\n  }, yh.prototype.toString = function () {\n    return this._name;\n  }, yh.prototype.interfaces_ = function () {\n    return [al];\n  }, yh.prototype.getClass = function () {\n    return yh;\n  }, vh.serialVersionUID.get = function () {\n    return -552860263173159e4;\n  }, vh.nameToTypeMap.get = function () {\n    return new fh();\n  }, Object.defineProperties(yh, vh), gh.Type = yh, gh.FIXED = new yh(\"FIXED\"), gh.FLOATING = new yh(\"FLOATING\"), gh.FLOATING_SINGLE = new yh(\"FLOATING SINGLE\");\n  var _h = function t() {\n      this._precisionModel = new gh(), this._SRID = 0, this._coordinateSequenceFactory = t.getDefaultCoordinateSequenceFactory(), 0 === arguments.length || (1 === arguments.length ? gl(arguments[0], hl) ? this._coordinateSequenceFactory = arguments[0] : arguments[0] instanceof gh && (this._precisionModel = arguments[0]) : 2 === arguments.length ? (this._precisionModel = arguments[0], this._SRID = arguments[1]) : 3 === arguments.length && (this._precisionModel = arguments[0], this._SRID = arguments[1], this._coordinateSequenceFactory = arguments[2]));\n    },\n    mh = {\n      serialVersionUID: {\n        configurable: !0\n      }\n    };\n  _h.prototype.toGeometry = function (t) {\n    return t.isNull() ? this.createPoint(null) : t.getMinX() === t.getMaxX() && t.getMinY() === t.getMaxY() ? this.createPoint(new ul(t.getMinX(), t.getMinY())) : t.getMinX() === t.getMaxX() || t.getMinY() === t.getMaxY() ? this.createLineString([new ul(t.getMinX(), t.getMinY()), new ul(t.getMaxX(), t.getMaxY())]) : this.createPolygon(this.createLinearRing([new ul(t.getMinX(), t.getMinY()), new ul(t.getMinX(), t.getMaxY()), new ul(t.getMaxX(), t.getMaxY()), new ul(t.getMaxX(), t.getMinY()), new ul(t.getMinX(), t.getMinY())]), null);\n  }, _h.prototype.createLineString = function (t) {\n    return t ? t instanceof Array ? new Zc(this.getCoordinateSequenceFactory().create(t), this) : gl(t, Il) ? new Zc(t, this) : void 0 : new Zc(this.getCoordinateSequenceFactory().create([]), this);\n  }, _h.prototype.createMultiLineString = function () {\n    if (0 === arguments.length) return new Gc(null, this);\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return new Gc(t, this);\n    }\n  }, _h.prototype.buildGeometry = function (t) {\n    for (var e = null, n = !1, r = !1, i = t.iterator(); i.hasNext();) {\n      var o = i.next(),\n        s = o.getClass();\n      null === e && (e = s), s !== e && (n = !0), o.isGeometryCollectionOrDerived() && (r = !0);\n    }\n    if (null === e) return this.createGeometryCollection();\n    if (n || r) return this.createGeometryCollection(_h.toGeometryArray(t));\n    var a = t.iterator().next();\n    if (t.size() > 1) {\n      if (a instanceof th) return this.createMultiPolygon(_h.toPolygonArray(t));\n      if (a instanceof Zc) return this.createMultiLineString(_h.toLineStringArray(t));\n      if (a instanceof Qc) return this.createMultiPoint(_h.toPointArray(t));\n      ql.shouldNeverReachHere(\"Unhandled class: \" + a.getClass().getName());\n    }\n    return a;\n  }, _h.prototype.createMultiPointFromCoords = function (t) {\n    return this.createMultiPoint(null !== t ? this.getCoordinateSequenceFactory().create(t) : null);\n  }, _h.prototype.createPoint = function () {\n    if (0 === arguments.length) return this.createPoint(this.getCoordinateSequenceFactory().create([]));\n    if (1 === arguments.length) {\n      if (arguments[0] instanceof ul) {\n        var t = arguments[0];\n        return this.createPoint(null !== t ? this.getCoordinateSequenceFactory().create([t]) : null);\n      }\n      if (gl(arguments[0], Il)) {\n        var e = arguments[0];\n        return new Qc(e, this);\n      }\n    }\n  }, _h.prototype.getCoordinateSequenceFactory = function () {\n    return this._coordinateSequenceFactory;\n  }, _h.prototype.createPolygon = function () {\n    if (0 === arguments.length) return new th(null, null, this);\n    if (1 === arguments.length) {\n      if (gl(arguments[0], Il)) {\n        var t = arguments[0];\n        return this.createPolygon(this.createLinearRing(t));\n      }\n      if (arguments[0] instanceof Array) {\n        var e = arguments[0];\n        return this.createPolygon(this.createLinearRing(e));\n      }\n      if (arguments[0] instanceof nh) {\n        var n = arguments[0];\n        return this.createPolygon(n, null);\n      }\n    } else if (2 === arguments.length) {\n      var r = arguments[0],\n        i = arguments[1];\n      return new th(r, i, this);\n    }\n  }, _h.prototype.getSRID = function () {\n    return this._SRID;\n  }, _h.prototype.createGeometryCollection = function () {\n    if (0 === arguments.length) return new kc(null, this);\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return new kc(t, this);\n    }\n  }, _h.prototype.createGeometry = function (t) {\n    return new ih(this).edit(t, {\n      edit: function edit() {\n        if (2 === arguments.length) {\n          var t = arguments[0];\n          return this._coordinateSequenceFactory.create(t);\n        }\n      }\n    });\n  }, _h.prototype.getPrecisionModel = function () {\n    return this._precisionModel;\n  }, _h.prototype.createLinearRing = function () {\n    if (0 === arguments.length) return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));\n    if (1 === arguments.length) {\n      if (arguments[0] instanceof Array) {\n        var t = arguments[0];\n        return this.createLinearRing(null !== t ? this.getCoordinateSequenceFactory().create(t) : null);\n      }\n      if (gl(arguments[0], Il)) {\n        var e = arguments[0];\n        return new nh(e, this);\n      }\n    }\n  }, _h.prototype.createMultiPolygon = function () {\n    if (0 === arguments.length) return new rh(null, this);\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return new rh(t, this);\n    }\n  }, _h.prototype.createMultiPoint = function () {\n    var t = this;\n    if (0 === arguments.length) return new eh(null, this);\n    if (1 === arguments.length) {\n      if (arguments[0] instanceof Array) {\n        var e = arguments[0];\n        return new eh(e, this);\n      }\n      if (arguments[0] instanceof Array) {\n        var n = arguments[0];\n        return this.createMultiPoint(null !== n ? this.getCoordinateSequenceFactory().create(n) : null);\n      }\n      if (gl(arguments[0], Il)) {\n        var r = arguments[0];\n        if (null === r) return this.createMultiPoint(new Array(0).fill(null));\n        for (var i = new Array(r.size()).fill(null), o = 0; o < r.size(); o++) {\n          var s = t.getCoordinateSequenceFactory().create(1, r.getDimension());\n          Jc.copy(r, o, s, 0, 1), i[o] = t.createPoint(s);\n        }\n        return this.createMultiPoint(i);\n      }\n    }\n  }, _h.prototype.interfaces_ = function () {\n    return [al];\n  }, _h.prototype.getClass = function () {\n    return _h;\n  }, _h.toMultiPolygonArray = function (t) {\n    var e = new Array(t.size()).fill(null);\n    return t.toArray(e);\n  }, _h.toGeometryArray = function (t) {\n    if (null === t) return null;\n    var e = new Array(t.size()).fill(null);\n    return t.toArray(e);\n  }, _h.getDefaultCoordinateSequenceFactory = function () {\n    return hh.instance();\n  }, _h.toMultiLineStringArray = function (t) {\n    var e = new Array(t.size()).fill(null);\n    return t.toArray(e);\n  }, _h.toLineStringArray = function (t) {\n    var e = new Array(t.size()).fill(null);\n    return t.toArray(e);\n  }, _h.toMultiPointArray = function (t) {\n    var e = new Array(t.size()).fill(null);\n    return t.toArray(e);\n  }, _h.toLinearRingArray = function (t) {\n    var e = new Array(t.size()).fill(null);\n    return t.toArray(e);\n  }, _h.toPointArray = function (t) {\n    var e = new Array(t.size()).fill(null);\n    return t.toArray(e);\n  }, _h.toPolygonArray = function (t) {\n    var e = new Array(t.size()).fill(null);\n    return t.toArray(e);\n  }, _h.createPointFromInternalCoord = function (t, e) {\n    return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t);\n  }, mh.serialVersionUID.get = function () {\n    return -0x5ea75f2051eeb400;\n  }, Object.defineProperties(_h, mh);\n  var xh = [\"Point\", \"MultiPoint\", \"LineString\", \"MultiLineString\", \"Polygon\", \"MultiPolygon\"],\n    Eh = function Eh(t) {\n      this.geometryFactory = t || new _h();\n    };\n  Eh.prototype.read = function (t) {\n    var e,\n      n = (e = \"string\" == typeof t ? JSON.parse(t) : t).type;\n    if (!bh[n]) throw new Error(\"Unknown GeoJSON type: \" + e.type);\n    return -1 !== xh.indexOf(n) ? bh[n].apply(this, [e.coordinates]) : \"GeometryCollection\" === n ? bh[n].apply(this, [e.geometries]) : bh[n].apply(this, [e]);\n  }, Eh.prototype.write = function (t) {\n    var e = t.getGeometryType();\n    if (!wh[e]) throw new Error(\"Geometry is not supported\");\n    return wh[e].apply(this, [t]);\n  };\n  var bh = {\n      Feature: function Feature(t) {\n        var e = {};\n        for (var n in t) e[n] = t[n];\n        if (t.geometry) {\n          var r = t.geometry.type;\n          if (!bh[r]) throw new Error(\"Unknown GeoJSON type: \" + t.type);\n          e.geometry = this.read(t.geometry);\n        }\n        return t.bbox && (e.bbox = bh.bbox.apply(this, [t.bbox])), e;\n      },\n      FeatureCollection: function FeatureCollection(t) {\n        var e = {};\n        if (t.features) {\n          e.features = [];\n          for (var n = 0; n < t.features.length; ++n) e.features.push(this.read(t.features[n]));\n        }\n        return t.bbox && (e.bbox = this.parse.bbox.apply(this, [t.bbox])), e;\n      },\n      coordinates: function coordinates(t) {\n        for (var e = [], n = 0; n < t.length; ++n) {\n          var r = t[n];\n          e.push(new ul(r[0], r[1]));\n        }\n        return e;\n      },\n      bbox: function bbox(t) {\n        return this.geometryFactory.createLinearRing([new ul(t[0], t[1]), new ul(t[2], t[1]), new ul(t[2], t[3]), new ul(t[0], t[3]), new ul(t[0], t[1])]);\n      },\n      Point: function Point(t) {\n        var e = new ul(t[0], t[1]);\n        return this.geometryFactory.createPoint(e);\n      },\n      MultiPoint: function MultiPoint(t) {\n        for (var e = [], n = 0; n < t.length; ++n) e.push(bh.Point.apply(this, [t[n]]));\n        return this.geometryFactory.createMultiPoint(e);\n      },\n      LineString: function LineString(t) {\n        var e = bh.coordinates.apply(this, [t]);\n        return this.geometryFactory.createLineString(e);\n      },\n      MultiLineString: function MultiLineString(t) {\n        for (var e = [], n = 0; n < t.length; ++n) e.push(bh.LineString.apply(this, [t[n]]));\n        return this.geometryFactory.createMultiLineString(e);\n      },\n      Polygon: function Polygon(t) {\n        for (var e = bh.coordinates.apply(this, [t[0]]), n = this.geometryFactory.createLinearRing(e), r = [], i = 1; i < t.length; ++i) {\n          var o = t[i],\n            s = bh.coordinates.apply(this, [o]),\n            a = this.geometryFactory.createLinearRing(s);\n          r.push(a);\n        }\n        return this.geometryFactory.createPolygon(n, r);\n      },\n      MultiPolygon: function MultiPolygon(t) {\n        for (var e = [], n = 0; n < t.length; ++n) {\n          var r = t[n];\n          e.push(bh.Polygon.apply(this, [r]));\n        }\n        return this.geometryFactory.createMultiPolygon(e);\n      },\n      GeometryCollection: function GeometryCollection(t) {\n        for (var e = [], n = 0; n < t.length; ++n) {\n          var r = t[n];\n          e.push(this.read(r));\n        }\n        return this.geometryFactory.createGeometryCollection(e);\n      }\n    },\n    wh = {\n      coordinate: function coordinate(t) {\n        return [t.x, t.y];\n      },\n      Point: function Point(t) {\n        return {\n          type: \"Point\",\n          coordinates: wh.coordinate.apply(this, [t.getCoordinate()])\n        };\n      },\n      MultiPoint: function MultiPoint(t) {\n        for (var e = [], n = 0; n < t._geometries.length; ++n) {\n          var r = t._geometries[n],\n            i = wh.Point.apply(this, [r]);\n          e.push(i.coordinates);\n        }\n        return {\n          type: \"MultiPoint\",\n          coordinates: e\n        };\n      },\n      LineString: function LineString(t) {\n        for (var e = [], n = t.getCoordinates(), r = 0; r < n.length; ++r) {\n          var i = n[r];\n          e.push(wh.coordinate.apply(this, [i]));\n        }\n        return {\n          type: \"LineString\",\n          coordinates: e\n        };\n      },\n      MultiLineString: function MultiLineString(t) {\n        for (var e = [], n = 0; n < t._geometries.length; ++n) {\n          var r = t._geometries[n],\n            i = wh.LineString.apply(this, [r]);\n          e.push(i.coordinates);\n        }\n        return {\n          type: \"MultiLineString\",\n          coordinates: e\n        };\n      },\n      Polygon: function Polygon(t) {\n        var e = [],\n          n = wh.LineString.apply(this, [t._shell]);\n        e.push(n.coordinates);\n        for (var r = 0; r < t._holes.length; ++r) {\n          var i = t._holes[r],\n            o = wh.LineString.apply(this, [i]);\n          e.push(o.coordinates);\n        }\n        return {\n          type: \"Polygon\",\n          coordinates: e\n        };\n      },\n      MultiPolygon: function MultiPolygon(t) {\n        for (var e = [], n = 0; n < t._geometries.length; ++n) {\n          var r = t._geometries[n],\n            i = wh.Polygon.apply(this, [r]);\n          e.push(i.coordinates);\n        }\n        return {\n          type: \"MultiPolygon\",\n          coordinates: e\n        };\n      },\n      GeometryCollection: function GeometryCollection(t) {\n        for (var e = [], n = 0; n < t._geometries.length; ++n) {\n          var r = t._geometries[n],\n            i = r.getGeometryType();\n          e.push(wh[i].apply(this, [r]));\n        }\n        return {\n          type: \"GeometryCollection\",\n          geometries: e\n        };\n      }\n    },\n    Ih = function Ih(t) {\n      this.geometryFactory = t || new _h(), this.precisionModel = this.geometryFactory.getPrecisionModel(), this.parser = new Eh(this.geometryFactory);\n    };\n  Ih.prototype.read = function (t) {\n    var e = this.parser.read(t);\n    return this.precisionModel.getType() === gh.FIXED && this.reducePrecision(e), e;\n  }, Ih.prototype.reducePrecision = function (t) {\n    var e, n;\n    if (t.coordinate) this.precisionModel.makePrecise(t.coordinate);else if (t.points) for (e = 0, n = t.points.length; e < n; e++) this.precisionModel.makePrecise(t.points[e]);else if (t.geometries) for (e = 0, n = t.geometries.length; e < n; e++) this.reducePrecision(t.geometries[e]);\n  };\n  var Nh = function Nh() {\n    this.parser = new Eh(this.geometryFactory);\n  };\n  Nh.prototype.write = function (t) {\n    return this.parser.write(t);\n  };\n  var Sh = function Sh() {},\n    Ch = {\n      ON: {\n        configurable: !0\n      },\n      LEFT: {\n        configurable: !0\n      },\n      RIGHT: {\n        configurable: !0\n      }\n    };\n  function Ph(t) {\n    this.message = t || \"\";\n  }\n  function Mh() {\n    this.array_ = [];\n  }\n  Sh.prototype.interfaces_ = function () {\n    return [];\n  }, Sh.prototype.getClass = function () {\n    return Sh;\n  }, Sh.opposite = function (t) {\n    return t === Sh.LEFT ? Sh.RIGHT : t === Sh.RIGHT ? Sh.LEFT : t;\n  }, Ch.ON.get = function () {\n    return 0;\n  }, Ch.LEFT.get = function () {\n    return 1;\n  }, Ch.RIGHT.get = function () {\n    return 2;\n  }, Object.defineProperties(Sh, Ch), Ph.prototype = new Error(), Ph.prototype.name = \"EmptyStackException\", Mh.prototype = new ac(), Mh.prototype.add = function (t) {\n    return this.array_.push(t), !0;\n  }, Mh.prototype.get = function (t) {\n    if (t < 0 || t >= this.size()) throw new Error();\n    return this.array_[t];\n  }, Mh.prototype.push = function (t) {\n    return this.array_.push(t), t;\n  }, Mh.prototype.pop = function (t) {\n    if (0 === this.array_.length) throw new Ph();\n    return this.array_.pop();\n  }, Mh.prototype.peek = function () {\n    if (0 === this.array_.length) throw new Ph();\n    return this.array_[this.array_.length - 1];\n  }, Mh.prototype.empty = function () {\n    return 0 === this.array_.length;\n  }, Mh.prototype.isEmpty = function () {\n    return this.empty();\n  }, Mh.prototype.search = function (t) {\n    return this.array_.indexOf(t);\n  }, Mh.prototype.size = function () {\n    return this.array_.length;\n  }, Mh.prototype.toArray = function () {\n    for (var t = [], e = 0, n = this.array_.length; e < n; e++) t.push(this.array_[e]);\n    return t;\n  };\n  var Lh = function Lh() {\n    this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null;\n  };\n  Lh.prototype.getCoordinate = function () {\n    return this._minCoord;\n  }, Lh.prototype.getRightmostSide = function (t, e) {\n    var n = this.getRightmostSideOfSegment(t, e);\n    return n < 0 && (n = this.getRightmostSideOfSegment(t, e - 1)), n < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(t)), n;\n  }, Lh.prototype.findRightmostEdgeAtVertex = function () {\n    var t = this._minDe.getEdge().getCoordinates();\n    ql.isTrue(this._minIndex > 0 && this._minIndex < t.length, \"rightmost point expected to be interior vertex of edge\");\n    var e = t[this._minIndex - 1],\n      n = t[this._minIndex + 1],\n      r = Xl.computeOrientation(this._minCoord, n, e),\n      i = !1;\n    (e.y < this._minCoord.y && n.y < this._minCoord.y && r === Xl.COUNTERCLOCKWISE || e.y > this._minCoord.y && n.y > this._minCoord.y && r === Xl.CLOCKWISE) && (i = !0), i && (this._minIndex = this._minIndex - 1);\n  }, Lh.prototype.getRightmostSideOfSegment = function (t, e) {\n    var n = t.getEdge().getCoordinates();\n    if (e < 0 || e + 1 >= n.length) return -1;\n    if (n[e].y === n[e + 1].y) return -1;\n    var r = Sh.LEFT;\n    return n[e].y < n[e + 1].y && (r = Sh.RIGHT), r;\n  }, Lh.prototype.getEdge = function () {\n    return this._orientedDe;\n  }, Lh.prototype.checkForRightmostCoordinate = function (t) {\n    for (var e = this, n = t.getEdge().getCoordinates(), r = 0; r < n.length - 1; r++) (null === e._minCoord || n[r].x > e._minCoord.x) && (e._minDe = t, e._minIndex = r, e._minCoord = n[r]);\n  }, Lh.prototype.findRightmostEdgeAtNode = function () {\n    var t = this._minDe.getNode().getEdges();\n    this._minDe = t.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1);\n  }, Lh.prototype.findEdge = function (t) {\n    for (var e = t.iterator(); e.hasNext();) {\n      var n = e.next();\n      n.isForward() && this.checkForRightmostCoordinate(n);\n    }\n    ql.isTrue(0 !== this._minIndex || this._minCoord.equals(this._minDe.getCoordinate()), \"inconsistency in rightmost processing\"), 0 === this._minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe, this.getRightmostSide(this._minDe, this._minIndex) === Sh.LEFT && (this._orientedDe = this._minDe.getSym());\n  }, Lh.prototype.interfaces_ = function () {\n    return [];\n  }, Lh.prototype.getClass = function () {\n    return Lh;\n  };\n  var Oh = function (t) {\n      function e(n, r) {\n        t.call(this, e.msgWithCoord(n, r)), this.pt = r ? new ul(r) : null, this.name = \"TopologyException\";\n      }\n      return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getCoordinate = function () {\n        return this.pt;\n      }, e.prototype.interfaces_ = function () {\n        return [];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, e.msgWithCoord = function (t, e) {\n        return e ? t : t + \" [ \" + e + \" ]\";\n      }, e;\n    }(kl),\n    Rh = function Rh() {\n      this.array_ = [];\n    };\n  Rh.prototype.addLast = function (t) {\n    this.array_.push(t);\n  }, Rh.prototype.removeFirst = function () {\n    return this.array_.shift();\n  }, Rh.prototype.isEmpty = function () {\n    return 0 === this.array_.length;\n  };\n  var Th = function Th() {\n    this._finder = null, this._dirEdgeList = new lc(), this._nodes = new lc(), this._rightMostCoord = null, this._env = null, this._finder = new Lh();\n  };\n  Th.prototype.clearVisitedEdges = function () {\n    for (var t = this._dirEdgeList.iterator(); t.hasNext();) {\n      t.next().setVisited(!1);\n    }\n  }, Th.prototype.getRightmostCoordinate = function () {\n    return this._rightMostCoord;\n  }, Th.prototype.computeNodeDepth = function (t) {\n    for (var e = null, n = t.getEdges().iterator(); n.hasNext();) {\n      var r = n.next();\n      if (r.isVisited() || r.getSym().isVisited()) {\n        e = r;\n        break;\n      }\n    }\n    if (null === e) throw new Oh(\"unable to find edge to compute depths at \" + t.getCoordinate());\n    t.getEdges().computeDepths(e);\n    for (var i = t.getEdges().iterator(); i.hasNext();) {\n      var o = i.next();\n      o.setVisited(!0), this.copySymDepths(o);\n    }\n  }, Th.prototype.computeDepth = function (t) {\n    this.clearVisitedEdges();\n    var e = this._finder.getEdge();\n    e.setEdgeDepths(Sh.RIGHT, t), this.copySymDepths(e), this.computeDepths(e);\n  }, Th.prototype.create = function (t) {\n    this.addReachable(t), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate();\n  }, Th.prototype.findResultEdges = function () {\n    for (var t = this._dirEdgeList.iterator(); t.hasNext();) {\n      var e = t.next();\n      e.getDepth(Sh.RIGHT) >= 1 && e.getDepth(Sh.LEFT) <= 0 && !e.isInteriorAreaEdge() && e.setInResult(!0);\n    }\n  }, Th.prototype.computeDepths = function (t) {\n    var e = new xc(),\n      n = new Rh(),\n      r = t.getNode();\n    for (n.addLast(r), e.add(r), t.setVisited(!0); !n.isEmpty();) {\n      var i = n.removeFirst();\n      e.add(i), this.computeNodeDepth(i);\n      for (var o = i.getEdges().iterator(); o.hasNext();) {\n        var s = o.next().getSym();\n        if (!s.isVisited()) {\n          var a = s.getNode();\n          e.contains(a) || (n.addLast(a), e.add(a));\n        }\n      }\n    }\n  }, Th.prototype.compareTo = function (t) {\n    var e = t;\n    return this._rightMostCoord.x < e._rightMostCoord.x ? -1 : this._rightMostCoord.x > e._rightMostCoord.x ? 1 : 0;\n  }, Th.prototype.getEnvelope = function () {\n    if (null === this._env) {\n      for (var t = new Ll(), e = this._dirEdgeList.iterator(); e.hasNext();) for (var n = e.next().getEdge().getCoordinates(), r = 0; r < n.length - 1; r++) t.expandToInclude(n[r]);\n      this._env = t;\n    }\n    return this._env;\n  }, Th.prototype.addReachable = function (t) {\n    var e = new Mh();\n    for (e.add(t); !e.empty();) {\n      var n = e.pop();\n      this.add(n, e);\n    }\n  }, Th.prototype.copySymDepths = function (t) {\n    var e = t.getSym();\n    e.setDepth(Sh.LEFT, t.getDepth(Sh.RIGHT)), e.setDepth(Sh.RIGHT, t.getDepth(Sh.LEFT));\n  }, Th.prototype.add = function (t, e) {\n    t.setVisited(!0), this._nodes.add(t);\n    for (var n = t.getEdges().iterator(); n.hasNext();) {\n      var r = n.next();\n      this._dirEdgeList.add(r);\n      var i = r.getSym().getNode();\n      i.isVisited() || e.push(i);\n    }\n  }, Th.prototype.getNodes = function () {\n    return this._nodes;\n  }, Th.prototype.getDirectedEdges = function () {\n    return this._dirEdgeList;\n  }, Th.prototype.interfaces_ = function () {\n    return [il];\n  }, Th.prototype.getClass = function () {\n    return Th;\n  };\n  var Ah = function t() {\n    var e = this;\n    if (this.location = null, 1 === arguments.length) {\n      if (arguments[0] instanceof Array) {\n        var n = arguments[0];\n        this.init(n.length);\n      } else if (Number.isInteger(arguments[0])) {\n        var r = arguments[0];\n        this.init(1), this.location[Sh.ON] = r;\n      } else if (arguments[0] instanceof t) {\n        var i = arguments[0];\n        if (this.init(i.location.length), null !== i) for (var o = 0; o < this.location.length; o++) e.location[o] = i.location[o];\n      }\n    } else if (3 === arguments.length) {\n      var s = arguments[0],\n        a = arguments[1],\n        u = arguments[2];\n      this.init(3), this.location[Sh.ON] = s, this.location[Sh.LEFT] = a, this.location[Sh.RIGHT] = u;\n    }\n  };\n  Ah.prototype.setAllLocations = function (t) {\n    for (var e = 0; e < this.location.length; e++) this.location[e] = t;\n  }, Ah.prototype.isNull = function () {\n    for (var t = 0; t < this.location.length; t++) if (this.location[t] !== pl.NONE) return !1;\n    return !0;\n  }, Ah.prototype.setAllLocationsIfNull = function (t) {\n    for (var e = 0; e < this.location.length; e++) this.location[e] === pl.NONE && (this.location[e] = t);\n  }, Ah.prototype.isLine = function () {\n    return 1 === this.location.length;\n  }, Ah.prototype.merge = function (t) {\n    if (t.location.length > this.location.length) {\n      var e = new Array(3).fill(null);\n      e[Sh.ON] = this.location[Sh.ON], e[Sh.LEFT] = pl.NONE, e[Sh.RIGHT] = pl.NONE, this.location = e;\n    }\n    for (var n = 0; n < this.location.length; n++) this.location[n] === pl.NONE && n < t.location.length && (this.location[n] = t.location[n]);\n  }, Ah.prototype.getLocations = function () {\n    return this.location;\n  }, Ah.prototype.flip = function () {\n    if (this.location.length <= 1) return null;\n    var t = this.location[Sh.LEFT];\n    this.location[Sh.LEFT] = this.location[Sh.RIGHT], this.location[Sh.RIGHT] = t;\n  }, Ah.prototype.toString = function () {\n    var t = new vl();\n    return this.location.length > 1 && t.append(pl.toLocationSymbol(this.location[Sh.LEFT])), t.append(pl.toLocationSymbol(this.location[Sh.ON])), this.location.length > 1 && t.append(pl.toLocationSymbol(this.location[Sh.RIGHT])), t.toString();\n  }, Ah.prototype.setLocations = function (t, e, n) {\n    this.location[Sh.ON] = t, this.location[Sh.LEFT] = e, this.location[Sh.RIGHT] = n;\n  }, Ah.prototype.get = function (t) {\n    return t < this.location.length ? this.location[t] : pl.NONE;\n  }, Ah.prototype.isArea = function () {\n    return this.location.length > 1;\n  }, Ah.prototype.isAnyNull = function () {\n    for (var t = 0; t < this.location.length; t++) if (this.location[t] === pl.NONE) return !0;\n    return !1;\n  }, Ah.prototype.setLocation = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      this.setLocation(Sh.ON, t);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n        n = arguments[1];\n      this.location[e] = n;\n    }\n  }, Ah.prototype.init = function (t) {\n    this.location = new Array(t).fill(null), this.setAllLocations(pl.NONE);\n  }, Ah.prototype.isEqualOnSide = function (t, e) {\n    return this.location[e] === t.location[e];\n  }, Ah.prototype.allPositionsEqual = function (t) {\n    for (var e = 0; e < this.location.length; e++) if (this.location[e] !== t) return !1;\n    return !0;\n  }, Ah.prototype.interfaces_ = function () {\n    return [];\n  }, Ah.prototype.getClass = function () {\n    return Ah;\n  };\n  var Dh = function t() {\n    if (this.elt = new Array(2).fill(null), 1 === arguments.length) {\n      if (Number.isInteger(arguments[0])) {\n        var e = arguments[0];\n        this.elt[0] = new Ah(e), this.elt[1] = new Ah(e);\n      } else if (arguments[0] instanceof t) {\n        var n = arguments[0];\n        this.elt[0] = new Ah(n.elt[0]), this.elt[1] = new Ah(n.elt[1]);\n      }\n    } else if (2 === arguments.length) {\n      var r = arguments[0],\n        i = arguments[1];\n      this.elt[0] = new Ah(pl.NONE), this.elt[1] = new Ah(pl.NONE), this.elt[r].setLocation(i);\n    } else if (3 === arguments.length) {\n      var o = arguments[0],\n        s = arguments[1],\n        a = arguments[2];\n      this.elt[0] = new Ah(o, s, a), this.elt[1] = new Ah(o, s, a);\n    } else if (4 === arguments.length) {\n      var u = arguments[0],\n        l = arguments[1],\n        c = arguments[2],\n        h = arguments[3];\n      this.elt[0] = new Ah(pl.NONE, pl.NONE, pl.NONE), this.elt[1] = new Ah(pl.NONE, pl.NONE, pl.NONE), this.elt[u].setLocations(l, c, h);\n    }\n  };\n  Dh.prototype.getGeometryCount = function () {\n    var t = 0;\n    return this.elt[0].isNull() || t++, this.elt[1].isNull() || t++, t;\n  }, Dh.prototype.setAllLocations = function (t, e) {\n    this.elt[t].setAllLocations(e);\n  }, Dh.prototype.isNull = function (t) {\n    return this.elt[t].isNull();\n  }, Dh.prototype.setAllLocationsIfNull = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      this.setAllLocationsIfNull(0, t), this.setAllLocationsIfNull(1, t);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n        n = arguments[1];\n      this.elt[e].setAllLocationsIfNull(n);\n    }\n  }, Dh.prototype.isLine = function (t) {\n    return this.elt[t].isLine();\n  }, Dh.prototype.merge = function (t) {\n    for (var e = this, n = 0; n < 2; n++) null === e.elt[n] && null !== t.elt[n] ? e.elt[n] = new Ah(t.elt[n]) : e.elt[n].merge(t.elt[n]);\n  }, Dh.prototype.flip = function () {\n    this.elt[0].flip(), this.elt[1].flip();\n  }, Dh.prototype.getLocation = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return this.elt[t].get(Sh.ON);\n    }\n    if (2 === arguments.length) {\n      var e = arguments[0],\n        n = arguments[1];\n      return this.elt[e].get(n);\n    }\n  }, Dh.prototype.toString = function () {\n    var t = new vl();\n    return null !== this.elt[0] && (t.append(\"A:\"), t.append(this.elt[0].toString())), null !== this.elt[1] && (t.append(\" B:\"), t.append(this.elt[1].toString())), t.toString();\n  }, Dh.prototype.isArea = function () {\n    if (0 === arguments.length) return this.elt[0].isArea() || this.elt[1].isArea();\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return this.elt[t].isArea();\n    }\n  }, Dh.prototype.isAnyNull = function (t) {\n    return this.elt[t].isAnyNull();\n  }, Dh.prototype.setLocation = function () {\n    if (2 === arguments.length) {\n      var t = arguments[0],\n        e = arguments[1];\n      this.elt[t].setLocation(Sh.ON, e);\n    } else if (3 === arguments.length) {\n      var n = arguments[0],\n        r = arguments[1],\n        i = arguments[2];\n      this.elt[n].setLocation(r, i);\n    }\n  }, Dh.prototype.isEqualOnSide = function (t, e) {\n    return this.elt[0].isEqualOnSide(t.elt[0], e) && this.elt[1].isEqualOnSide(t.elt[1], e);\n  }, Dh.prototype.allPositionsEqual = function (t, e) {\n    return this.elt[t].allPositionsEqual(e);\n  }, Dh.prototype.toLine = function (t) {\n    this.elt[t].isArea() && (this.elt[t] = new Ah(this.elt[t].location[0]));\n  }, Dh.prototype.interfaces_ = function () {\n    return [];\n  }, Dh.prototype.getClass = function () {\n    return Dh;\n  }, Dh.toLineLabel = function (t) {\n    for (var e = new Dh(pl.NONE), n = 0; n < 2; n++) e.setLocation(n, t.getLocation(n));\n    return e;\n  };\n  var Fh = function Fh() {\n    this._startDe = null, this._maxNodeDegree = -1, this._edges = new lc(), this._pts = new lc(), this._label = new Dh(pl.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new lc(), this._geometryFactory = null;\n    var t = arguments[0],\n      e = arguments[1];\n    this._geometryFactory = e, this.computePoints(t), this.computeRing();\n  };\n  Fh.prototype.computeRing = function () {\n    if (null !== this._ring) return null;\n    for (var t = new Array(this._pts.size()).fill(null), e = 0; e < this._pts.size(); e++) t[e] = this._pts.get(e);\n    this._ring = this._geometryFactory.createLinearRing(t), this._isHole = Xl.isCCW(this._ring.getCoordinates());\n  }, Fh.prototype.isIsolated = function () {\n    return 1 === this._label.getGeometryCount();\n  }, Fh.prototype.computePoints = function (t) {\n    var e = this;\n    this._startDe = t;\n    var n = t,\n      r = !0;\n    do {\n      if (null === n) throw new Oh(\"Found null DirectedEdge\");\n      if (n.getEdgeRing() === e) throw new Oh(\"Directed Edge visited twice during ring-building at \" + n.getCoordinate());\n      e._edges.add(n);\n      var i = n.getLabel();\n      ql.isTrue(i.isArea()), e.mergeLabel(i), e.addPoints(n.getEdge(), n.isForward(), r), r = !1, e.setEdgeRing(n, e), n = e.getNext(n);\n    } while (n !== this._startDe);\n  }, Fh.prototype.getLinearRing = function () {\n    return this._ring;\n  }, Fh.prototype.getCoordinate = function (t) {\n    return this._pts.get(t);\n  }, Fh.prototype.computeMaxNodeDegree = function () {\n    var t = this;\n    this._maxNodeDegree = 0;\n    var e = this._startDe;\n    do {\n      var n = e.getNode().getEdges().getOutgoingDegree(t);\n      n > t._maxNodeDegree && (t._maxNodeDegree = n), e = t.getNext(e);\n    } while (e !== this._startDe);\n    this._maxNodeDegree *= 2;\n  }, Fh.prototype.addPoints = function (t, e, n) {\n    var r = t.getCoordinates();\n    if (e) {\n      var i = 1;\n      n && (i = 0);\n      for (var o = i; o < r.length; o++) this._pts.add(r[o]);\n    } else {\n      var s = r.length - 2;\n      n && (s = r.length - 1);\n      for (var a = s; a >= 0; a--) this._pts.add(r[a]);\n    }\n  }, Fh.prototype.isHole = function () {\n    return this._isHole;\n  }, Fh.prototype.setInResult = function () {\n    var t = this._startDe;\n    do {\n      t.getEdge().setInResult(!0), t = t.getNext();\n    } while (t !== this._startDe);\n  }, Fh.prototype.containsPoint = function (t) {\n    var e = this.getLinearRing();\n    if (!e.getEnvelopeInternal().contains(t)) return !1;\n    if (!Xl.isPointInRing(t, e.getCoordinates())) return !1;\n    for (var n = this._holes.iterator(); n.hasNext();) {\n      if (n.next().containsPoint(t)) return !1;\n    }\n    return !0;\n  }, Fh.prototype.addHole = function (t) {\n    this._holes.add(t);\n  }, Fh.prototype.isShell = function () {\n    return null === this._shell;\n  }, Fh.prototype.getLabel = function () {\n    return this._label;\n  }, Fh.prototype.getEdges = function () {\n    return this._edges;\n  }, Fh.prototype.getMaxNodeDegree = function () {\n    return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree;\n  }, Fh.prototype.getShell = function () {\n    return this._shell;\n  }, Fh.prototype.mergeLabel = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      this.mergeLabel(t, 0), this.mergeLabel(t, 1);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n        n = arguments[1],\n        r = e.getLocation(n, Sh.RIGHT);\n      if (r === pl.NONE) return null;\n      if (this._label.getLocation(n) === pl.NONE) return this._label.setLocation(n, r), null;\n    }\n  }, Fh.prototype.setShell = function (t) {\n    this._shell = t, null !== t && t.addHole(this);\n  }, Fh.prototype.toPolygon = function (t) {\n    for (var e = new Array(this._holes.size()).fill(null), n = 0; n < this._holes.size(); n++) e[n] = this._holes.get(n).getLinearRing();\n    return t.createPolygon(this.getLinearRing(), e);\n  }, Fh.prototype.interfaces_ = function () {\n    return [];\n  }, Fh.prototype.getClass = function () {\n    return Fh;\n  };\n  var kh = function (t) {\n      function e() {\n        var e = arguments[0],\n          n = arguments[1];\n        t.call(this, e, n);\n      }\n      return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.setEdgeRing = function (t, e) {\n        t.setMinEdgeRing(e);\n      }, e.prototype.getNext = function (t) {\n        return t.getNextMin();\n      }, e.prototype.interfaces_ = function () {\n        return [];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, e;\n    }(Fh),\n    Gh = function (t) {\n      function e() {\n        var e = arguments[0],\n          n = arguments[1];\n        t.call(this, e, n);\n      }\n      return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.buildMinimalRings = function () {\n        var t = new lc(),\n          e = this._startDe;\n        do {\n          if (null === e.getMinEdgeRing()) {\n            var n = new kh(e, this._geometryFactory);\n            t.add(n);\n          }\n          e = e.getNext();\n        } while (e !== this._startDe);\n        return t;\n      }, e.prototype.setEdgeRing = function (t, e) {\n        t.setEdgeRing(e);\n      }, e.prototype.linkDirectedEdgesForMinimalEdgeRings = function () {\n        var t = this._startDe;\n        do {\n          t.getNode().getEdges().linkMinimalDirectedEdges(this), t = t.getNext();\n        } while (t !== this._startDe);\n      }, e.prototype.getNext = function (t) {\n        return t.getNext();\n      }, e.prototype.interfaces_ = function () {\n        return [];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, e;\n    }(Fh),\n    qh = function qh() {\n      if (this._label = null, this._isInResult = !1, this._isCovered = !1, this._isCoveredSet = !1, this._isVisited = !1, 0 === arguments.length) ;else if (1 === arguments.length) {\n        var t = arguments[0];\n        this._label = t;\n      }\n    };\n  qh.prototype.setVisited = function (t) {\n    this._isVisited = t;\n  }, qh.prototype.setInResult = function (t) {\n    this._isInResult = t;\n  }, qh.prototype.isCovered = function () {\n    return this._isCovered;\n  }, qh.prototype.isCoveredSet = function () {\n    return this._isCoveredSet;\n  }, qh.prototype.setLabel = function (t) {\n    this._label = t;\n  }, qh.prototype.getLabel = function () {\n    return this._label;\n  }, qh.prototype.setCovered = function (t) {\n    this._isCovered = t, this._isCoveredSet = !0;\n  }, qh.prototype.updateIM = function (t) {\n    ql.isTrue(this._label.getGeometryCount() >= 2, \"found partial label\"), this.computeIM(t);\n  }, qh.prototype.isInResult = function () {\n    return this._isInResult;\n  }, qh.prototype.isVisited = function () {\n    return this._isVisited;\n  }, qh.prototype.interfaces_ = function () {\n    return [];\n  }, qh.prototype.getClass = function () {\n    return qh;\n  };\n  var Bh = function (t) {\n      function e() {\n        t.call(this), this._coord = null, this._edges = null;\n        var e = arguments[0],\n          n = arguments[1];\n        this._coord = e, this._edges = n, this._label = new Dh(0, pl.NONE);\n      }\n      return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.isIncidentEdgeInResult = function () {\n        for (var t = this.getEdges().getEdges().iterator(); t.hasNext();) {\n          if (t.next().getEdge().isInResult()) return !0;\n        }\n        return !1;\n      }, e.prototype.isIsolated = function () {\n        return 1 === this._label.getGeometryCount();\n      }, e.prototype.getCoordinate = function () {\n        return this._coord;\n      }, e.prototype.print = function (t) {\n        t.println(\"node \" + this._coord + \" lbl: \" + this._label);\n      }, e.prototype.computeIM = function (t) {}, e.prototype.computeMergedLocation = function (t, e) {\n        var n = pl.NONE;\n        if (n = this._label.getLocation(e), !t.isNull(e)) {\n          var r = t.getLocation(e);\n          n !== pl.BOUNDARY && (n = r);\n        }\n        return n;\n      }, e.prototype.setLabel = function () {\n        if (2 !== arguments.length) return t.prototype.setLabel.apply(this, arguments);\n        var e = arguments[0],\n          n = arguments[1];\n        null === this._label ? this._label = new Dh(e, n) : this._label.setLocation(e, n);\n      }, e.prototype.getEdges = function () {\n        return this._edges;\n      }, e.prototype.mergeLabel = function () {\n        var t = this;\n        if (arguments[0] instanceof e) {\n          var n = arguments[0];\n          this.mergeLabel(n._label);\n        } else if (arguments[0] instanceof Dh) for (var r = arguments[0], i = 0; i < 2; i++) {\n          var o = t.computeMergedLocation(r, i),\n            s = t._label.getLocation(i);\n          s === pl.NONE && t._label.setLocation(i, o);\n        }\n      }, e.prototype.add = function (t) {\n        this._edges.insert(t), t.setNode(this);\n      }, e.prototype.setLabelBoundary = function (t) {\n        if (null === this._label) return null;\n        var e = pl.NONE;\n        null !== this._label && (e = this._label.getLocation(t));\n        var n = null;\n        switch (e) {\n          case pl.BOUNDARY:\n            n = pl.INTERIOR;\n            break;\n          case pl.INTERIOR:\n          default:\n            n = pl.BOUNDARY;\n        }\n        this._label.setLocation(t, n);\n      }, e.prototype.interfaces_ = function () {\n        return [];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, e;\n    }(qh),\n    zh = function zh() {\n      this.nodeMap = new Cc(), this.nodeFact = null;\n      var t = arguments[0];\n      this.nodeFact = t;\n    };\n  zh.prototype.find = function (t) {\n    return this.nodeMap.get(t);\n  }, zh.prototype.addNode = function () {\n    if (arguments[0] instanceof ul) {\n      var t = arguments[0],\n        e = this.nodeMap.get(t);\n      return null === e && (e = this.nodeFact.createNode(t), this.nodeMap.put(t, e)), e;\n    }\n    if (arguments[0] instanceof Bh) {\n      var n = arguments[0],\n        r = this.nodeMap.get(n.getCoordinate());\n      return null === r ? (this.nodeMap.put(n.getCoordinate(), n), n) : (r.mergeLabel(n), r);\n    }\n  }, zh.prototype.print = function (t) {\n    for (var e = this.iterator(); e.hasNext();) {\n      e.next().print(t);\n    }\n  }, zh.prototype.iterator = function () {\n    return this.nodeMap.values().iterator();\n  }, zh.prototype.values = function () {\n    return this.nodeMap.values();\n  }, zh.prototype.getBoundaryNodes = function (t) {\n    for (var e = new lc(), n = this.iterator(); n.hasNext();) {\n      var r = n.next();\n      r.getLabel().getLocation(t) === pl.BOUNDARY && e.add(r);\n    }\n    return e;\n  }, zh.prototype.add = function (t) {\n    var e = t.getCoordinate();\n    this.addNode(e).add(t);\n  }, zh.prototype.interfaces_ = function () {\n    return [];\n  }, zh.prototype.getClass = function () {\n    return zh;\n  };\n  var jh = function jh() {},\n    Uh = {\n      NE: {\n        configurable: !0\n      },\n      NW: {\n        configurable: !0\n      },\n      SW: {\n        configurable: !0\n      },\n      SE: {\n        configurable: !0\n      }\n    };\n  jh.prototype.interfaces_ = function () {\n    return [];\n  }, jh.prototype.getClass = function () {\n    return jh;\n  }, jh.isNorthern = function (t) {\n    return t === jh.NE || t === jh.NW;\n  }, jh.isOpposite = function (t, e) {\n    return t !== e && 2 === (t - e + 4) % 4;\n  }, jh.commonHalfPlane = function (t, e) {\n    if (t === e) return t;\n    if (2 === (t - e + 4) % 4) return -1;\n    var n = t < e ? t : e;\n    return 0 === n && 3 === (t > e ? t : e) ? 3 : n;\n  }, jh.isInHalfPlane = function (t, e) {\n    return e === jh.SE ? t === jh.SE || t === jh.SW : t === e || t === e + 1;\n  }, jh.quadrant = function () {\n    if (\"number\" == typeof arguments[0] && \"number\" == typeof arguments[1]) {\n      var t = arguments[0],\n        e = arguments[1];\n      if (0 === t && 0 === e) throw new el(\"Cannot compute the quadrant for point ( \" + t + \", \" + e + \" )\");\n      return t >= 0 ? e >= 0 ? jh.NE : jh.SE : e >= 0 ? jh.NW : jh.SW;\n    }\n    if (arguments[0] instanceof ul && arguments[1] instanceof ul) {\n      var n = arguments[0],\n        r = arguments[1];\n      if (r.x === n.x && r.y === n.y) throw new el(\"Cannot compute the quadrant for two identical points \" + n);\n      return r.x >= n.x ? r.y >= n.y ? jh.NE : jh.SE : r.y >= n.y ? jh.NW : jh.SW;\n    }\n  }, Uh.NE.get = function () {\n    return 0;\n  }, Uh.NW.get = function () {\n    return 1;\n  }, Uh.SW.get = function () {\n    return 2;\n  }, Uh.SE.get = function () {\n    return 3;\n  }, Object.defineProperties(jh, Uh);\n  var Vh = function Vh() {\n    if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, 1 === arguments.length) {\n      var t = arguments[0];\n      this._edge = t;\n    } else if (3 === arguments.length) {\n      var e = arguments[0],\n        n = arguments[1],\n        r = arguments[2],\n        i = null;\n      this._edge = e, this.init(n, r), this._label = i;\n    } else if (4 === arguments.length) {\n      var o = arguments[0],\n        s = arguments[1],\n        a = arguments[2],\n        u = arguments[3];\n      this._edge = o, this.init(s, a), this._label = u;\n    }\n  };\n  Vh.prototype.compareDirection = function (t) {\n    return this._dx === t._dx && this._dy === t._dy ? 0 : this._quadrant > t._quadrant ? 1 : this._quadrant < t._quadrant ? -1 : Xl.computeOrientation(t._p0, t._p1, this._p1);\n  }, Vh.prototype.getDy = function () {\n    return this._dy;\n  }, Vh.prototype.getCoordinate = function () {\n    return this._p0;\n  }, Vh.prototype.setNode = function (t) {\n    this._node = t;\n  }, Vh.prototype.print = function (t) {\n    var e = Math.atan2(this._dy, this._dx),\n      n = this.getClass().getName(),\n      r = n.lastIndexOf(\".\"),\n      i = n.substring(r + 1);\n    t.print(\"  \" + i + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + e + \"   \" + this._label);\n  }, Vh.prototype.compareTo = function (t) {\n    var e = t;\n    return this.compareDirection(e);\n  }, Vh.prototype.getDirectedCoordinate = function () {\n    return this._p1;\n  }, Vh.prototype.getDx = function () {\n    return this._dx;\n  }, Vh.prototype.getLabel = function () {\n    return this._label;\n  }, Vh.prototype.getEdge = function () {\n    return this._edge;\n  }, Vh.prototype.getQuadrant = function () {\n    return this._quadrant;\n  }, Vh.prototype.getNode = function () {\n    return this._node;\n  }, Vh.prototype.toString = function () {\n    var t = Math.atan2(this._dy, this._dx),\n      e = this.getClass().getName(),\n      n = e.lastIndexOf(\".\");\n    return \"  \" + e.substring(n + 1) + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + t + \"   \" + this._label;\n  }, Vh.prototype.computeLabel = function (t) {}, Vh.prototype.init = function (t, e) {\n    this._p0 = t, this._p1 = e, this._dx = e.x - t.x, this._dy = e.y - t.y, this._quadrant = jh.quadrant(this._dx, this._dy), ql.isTrue(!(0 === this._dx && 0 === this._dy), \"EdgeEnd with identical endpoints found\");\n  }, Vh.prototype.interfaces_ = function () {\n    return [il];\n  }, Vh.prototype.getClass = function () {\n    return Vh;\n  };\n  var Xh = function (t) {\n      function e() {\n        var e = arguments[0],\n          n = arguments[1];\n        if (t.call(this, e), this._isForward = null, this._isInResult = !1, this._isVisited = !1, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999], this._isForward = n, n) this.init(e.getCoordinate(0), e.getCoordinate(1));else {\n          var r = e.getNumPoints() - 1;\n          this.init(e.getCoordinate(r), e.getCoordinate(r - 1));\n        }\n        this.computeDirectedLabel();\n      }\n      return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getNextMin = function () {\n        return this._nextMin;\n      }, e.prototype.getDepth = function (t) {\n        return this._depth[t];\n      }, e.prototype.setVisited = function (t) {\n        this._isVisited = t;\n      }, e.prototype.computeDirectedLabel = function () {\n        this._label = new Dh(this._edge.getLabel()), this._isForward || this._label.flip();\n      }, e.prototype.getNext = function () {\n        return this._next;\n      }, e.prototype.setDepth = function (t, e) {\n        if (-999 !== this._depth[t] && this._depth[t] !== e) throw new Oh(\"assigned depths do not match\", this.getCoordinate());\n        this._depth[t] = e;\n      }, e.prototype.isInteriorAreaEdge = function () {\n        for (var t = this, e = !0, n = 0; n < 2; n++) t._label.isArea(n) && t._label.getLocation(n, Sh.LEFT) === pl.INTERIOR && t._label.getLocation(n, Sh.RIGHT) === pl.INTERIOR || (e = !1);\n        return e;\n      }, e.prototype.setNextMin = function (t) {\n        this._nextMin = t;\n      }, e.prototype.print = function (e) {\n        t.prototype.print.call(this, e), e.print(\" \" + this._depth[Sh.LEFT] + \"/\" + this._depth[Sh.RIGHT]), e.print(\" (\" + this.getDepthDelta() + \")\"), this._isInResult && e.print(\" inResult\");\n      }, e.prototype.setMinEdgeRing = function (t) {\n        this._minEdgeRing = t;\n      }, e.prototype.isLineEdge = function () {\n        var t = this._label.isLine(0) || this._label.isLine(1),\n          e = !this._label.isArea(0) || this._label.allPositionsEqual(0, pl.EXTERIOR),\n          n = !this._label.isArea(1) || this._label.allPositionsEqual(1, pl.EXTERIOR);\n        return t && e && n;\n      }, e.prototype.setEdgeRing = function (t) {\n        this._edgeRing = t;\n      }, e.prototype.getMinEdgeRing = function () {\n        return this._minEdgeRing;\n      }, e.prototype.getDepthDelta = function () {\n        var t = this._edge.getDepthDelta();\n        return this._isForward || (t = -t), t;\n      }, e.prototype.setInResult = function (t) {\n        this._isInResult = t;\n      }, e.prototype.getSym = function () {\n        return this._sym;\n      }, e.prototype.isForward = function () {\n        return this._isForward;\n      }, e.prototype.getEdge = function () {\n        return this._edge;\n      }, e.prototype.printEdge = function (t) {\n        this.print(t), t.print(\" \"), this._isForward ? this._edge.print(t) : this._edge.printReverse(t);\n      }, e.prototype.setSym = function (t) {\n        this._sym = t;\n      }, e.prototype.setVisitedEdge = function (t) {\n        this.setVisited(t), this._sym.setVisited(t);\n      }, e.prototype.setEdgeDepths = function (t, e) {\n        var n = this.getEdge().getDepthDelta();\n        this._isForward || (n = -n);\n        var r = 1;\n        t === Sh.LEFT && (r = -1);\n        var i = Sh.opposite(t),\n          o = e + n * r;\n        this.setDepth(t, e), this.setDepth(i, o);\n      }, e.prototype.getEdgeRing = function () {\n        return this._edgeRing;\n      }, e.prototype.isInResult = function () {\n        return this._isInResult;\n      }, e.prototype.setNext = function (t) {\n        this._next = t;\n      }, e.prototype.isVisited = function () {\n        return this._isVisited;\n      }, e.prototype.interfaces_ = function () {\n        return [];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, e.depthFactor = function (t, e) {\n        return t === pl.EXTERIOR && e === pl.INTERIOR ? 1 : t === pl.INTERIOR && e === pl.EXTERIOR ? -1 : 0;\n      }, e;\n    }(Vh),\n    Yh = function Yh() {};\n  Yh.prototype.createNode = function (t) {\n    return new Bh(t, null);\n  }, Yh.prototype.interfaces_ = function () {\n    return [];\n  }, Yh.prototype.getClass = function () {\n    return Yh;\n  };\n  var Hh = function Hh() {\n    if (this._edges = new lc(), this._nodes = null, this._edgeEndList = new lc(), 0 === arguments.length) this._nodes = new zh(new Yh());else if (1 === arguments.length) {\n      var t = arguments[0];\n      this._nodes = new zh(t);\n    }\n  };\n  Hh.prototype.printEdges = function (t) {\n    t.println(\"Edges:\");\n    for (var e = 0; e < this._edges.size(); e++) {\n      t.println(\"edge \" + e + \":\");\n      var n = this._edges.get(e);\n      n.print(t), n.eiList.print(t);\n    }\n  }, Hh.prototype.find = function (t) {\n    return this._nodes.find(t);\n  }, Hh.prototype.addNode = function () {\n    if (arguments[0] instanceof Bh) {\n      var t = arguments[0];\n      return this._nodes.addNode(t);\n    }\n    if (arguments[0] instanceof ul) {\n      var e = arguments[0];\n      return this._nodes.addNode(e);\n    }\n  }, Hh.prototype.getNodeIterator = function () {\n    return this._nodes.iterator();\n  }, Hh.prototype.linkResultDirectedEdges = function () {\n    for (var t = this._nodes.iterator(); t.hasNext();) {\n      t.next().getEdges().linkResultDirectedEdges();\n    }\n  }, Hh.prototype.debugPrintln = function (t) {\n    Pl.out.println(t);\n  }, Hh.prototype.isBoundaryNode = function (t, e) {\n    var n = this._nodes.find(e);\n    if (null === n) return !1;\n    var r = n.getLabel();\n    return null !== r && r.getLocation(t) === pl.BOUNDARY;\n  }, Hh.prototype.linkAllDirectedEdges = function () {\n    for (var t = this._nodes.iterator(); t.hasNext();) {\n      t.next().getEdges().linkAllDirectedEdges();\n    }\n  }, Hh.prototype.matchInSameDirection = function (t, e, n, r) {\n    return !!t.equals(n) && Xl.computeOrientation(t, e, r) === Xl.COLLINEAR && jh.quadrant(t, e) === jh.quadrant(n, r);\n  }, Hh.prototype.getEdgeEnds = function () {\n    return this._edgeEndList;\n  }, Hh.prototype.debugPrint = function (t) {\n    Pl.out.print(t);\n  }, Hh.prototype.getEdgeIterator = function () {\n    return this._edges.iterator();\n  }, Hh.prototype.findEdgeInSameDirection = function (t, e) {\n    for (var n = this, r = 0; r < this._edges.size(); r++) {\n      var i = n._edges.get(r),\n        o = i.getCoordinates();\n      if (n.matchInSameDirection(t, e, o[0], o[1])) return i;\n      if (n.matchInSameDirection(t, e, o[o.length - 1], o[o.length - 2])) return i;\n    }\n    return null;\n  }, Hh.prototype.insertEdge = function (t) {\n    this._edges.add(t);\n  }, Hh.prototype.findEdgeEnd = function (t) {\n    for (var e = this.getEdgeEnds().iterator(); e.hasNext();) {\n      var n = e.next();\n      if (n.getEdge() === t) return n;\n    }\n    return null;\n  }, Hh.prototype.addEdges = function (t) {\n    for (var e = this, n = t.iterator(); n.hasNext();) {\n      var r = n.next();\n      e._edges.add(r);\n      var i = new Xh(r, !0),\n        o = new Xh(r, !1);\n      i.setSym(o), o.setSym(i), e.add(i), e.add(o);\n    }\n  }, Hh.prototype.add = function (t) {\n    this._nodes.add(t), this._edgeEndList.add(t);\n  }, Hh.prototype.getNodes = function () {\n    return this._nodes.values();\n  }, Hh.prototype.findEdge = function (t, e) {\n    for (var n = 0; n < this._edges.size(); n++) {\n      var r = this._edges.get(n),\n        i = r.getCoordinates();\n      if (t.equals(i[0]) && e.equals(i[1])) return r;\n    }\n    return null;\n  }, Hh.prototype.interfaces_ = function () {\n    return [];\n  }, Hh.prototype.getClass = function () {\n    return Hh;\n  }, Hh.linkResultDirectedEdges = function (t) {\n    for (var e = t.iterator(); e.hasNext();) {\n      e.next().getEdges().linkResultDirectedEdges();\n    }\n  };\n  var Wh = function Wh() {\n    this._geometryFactory = null, this._shellList = new lc();\n    var t = arguments[0];\n    this._geometryFactory = t;\n  };\n  Wh.prototype.sortShellsAndHoles = function (t, e, n) {\n    for (var r = t.iterator(); r.hasNext();) {\n      var i = r.next();\n      i.isHole() ? n.add(i) : e.add(i);\n    }\n  }, Wh.prototype.computePolygons = function (t) {\n    for (var e = new lc(), n = t.iterator(); n.hasNext();) {\n      var r = n.next().toPolygon(this._geometryFactory);\n      e.add(r);\n    }\n    return e;\n  }, Wh.prototype.placeFreeHoles = function (t, e) {\n    for (var n = e.iterator(); n.hasNext();) {\n      var r = n.next();\n      if (null === r.getShell()) {\n        var i = this.findEdgeRingContaining(r, t);\n        if (null === i) throw new Oh(\"unable to assign hole to a shell\", r.getCoordinate(0));\n        r.setShell(i);\n      }\n    }\n  }, Wh.prototype.buildMinimalEdgeRings = function (t, e, n) {\n    for (var r = new lc(), i = t.iterator(); i.hasNext();) {\n      var o = i.next();\n      if (o.getMaxNodeDegree() > 2) {\n        o.linkDirectedEdgesForMinimalEdgeRings();\n        var s = o.buildMinimalRings(),\n          a = this.findShell(s);\n        null !== a ? (this.placePolygonHoles(a, s), e.add(a)) : n.addAll(s);\n      } else r.add(o);\n    }\n    return r;\n  }, Wh.prototype.containsPoint = function (t) {\n    for (var e = this._shellList.iterator(); e.hasNext();) {\n      if (e.next().containsPoint(t)) return !0;\n    }\n    return !1;\n  }, Wh.prototype.buildMaximalEdgeRings = function (t) {\n    for (var e = new lc(), n = t.iterator(); n.hasNext();) {\n      var r = n.next();\n      if (r.isInResult() && r.getLabel().isArea() && null === r.getEdgeRing()) {\n        var i = new Gh(r, this._geometryFactory);\n        e.add(i), i.setInResult();\n      }\n    }\n    return e;\n  }, Wh.prototype.placePolygonHoles = function (t, e) {\n    for (var n = e.iterator(); n.hasNext();) {\n      var r = n.next();\n      r.isHole() && r.setShell(t);\n    }\n  }, Wh.prototype.getPolygons = function () {\n    return this.computePolygons(this._shellList);\n  }, Wh.prototype.findEdgeRingContaining = function (t, e) {\n    for (var n = t.getLinearRing(), r = n.getEnvelopeInternal(), i = n.getCoordinateN(0), o = null, s = null, a = e.iterator(); a.hasNext();) {\n      var u = a.next(),\n        l = u.getLinearRing(),\n        c = l.getEnvelopeInternal();\n      null !== o && (s = o.getLinearRing().getEnvelopeInternal());\n      var h = !1;\n      c.contains(r) && Xl.isPointInRing(i, l.getCoordinates()) && (h = !0), h && (null === o || s.contains(c)) && (o = u);\n    }\n    return o;\n  }, Wh.prototype.findShell = function (t) {\n    for (var e = 0, n = null, r = t.iterator(); r.hasNext();) {\n      var i = r.next();\n      i.isHole() || (n = i, e++);\n    }\n    return ql.isTrue(e <= 1, \"found two shells in MinimalEdgeRing list\"), n;\n  }, Wh.prototype.add = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      this.add(t.getEdgeEnds(), t.getNodes());\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n        n = arguments[1];\n      Hh.linkResultDirectedEdges(n);\n      var r = this.buildMaximalEdgeRings(e),\n        i = new lc(),\n        o = this.buildMinimalEdgeRings(r, this._shellList, i);\n      this.sortShellsAndHoles(o, this._shellList, i), this.placeFreeHoles(this._shellList, i);\n    }\n  }, Wh.prototype.interfaces_ = function () {\n    return [];\n  }, Wh.prototype.getClass = function () {\n    return Wh;\n  };\n  var Jh = function Jh() {};\n  Jh.prototype.getBounds = function () {}, Jh.prototype.interfaces_ = function () {\n    return [];\n  }, Jh.prototype.getClass = function () {\n    return Jh;\n  };\n  var Zh = function Zh() {\n    this._bounds = null, this._item = null;\n    var t = arguments[0],\n      e = arguments[1];\n    this._bounds = t, this._item = e;\n  };\n  Zh.prototype.getItem = function () {\n    return this._item;\n  }, Zh.prototype.getBounds = function () {\n    return this._bounds;\n  }, Zh.prototype.interfaces_ = function () {\n    return [Jh, al];\n  }, Zh.prototype.getClass = function () {\n    return Zh;\n  };\n  var Kh = function Kh() {\n    this._size = null, this._items = null, this._size = 0, this._items = new lc(), this._items.add(null);\n  };\n  Kh.prototype.poll = function () {\n    if (this.isEmpty()) return null;\n    var t = this._items.get(1);\n    return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), t;\n  }, Kh.prototype.size = function () {\n    return this._size;\n  }, Kh.prototype.reorder = function (t) {\n    for (var e = this, n = null, r = this._items.get(t); 2 * t <= this._size && ((n = 2 * t) !== e._size && e._items.get(n + 1).compareTo(e._items.get(n)) < 0 && n++, e._items.get(n).compareTo(r) < 0); t = n) e._items.set(t, e._items.get(n));\n    this._items.set(t, r);\n  }, Kh.prototype.clear = function () {\n    this._size = 0, this._items.clear();\n  }, Kh.prototype.isEmpty = function () {\n    return 0 === this._size;\n  }, Kh.prototype.add = function (t) {\n    this._items.add(null), this._size += 1;\n    var e = this._size;\n    for (this._items.set(0, t); t.compareTo(this._items.get(Math.trunc(e / 2))) < 0; e /= 2) this._items.set(e, this._items.get(Math.trunc(e / 2)));\n    this._items.set(e, t);\n  }, Kh.prototype.interfaces_ = function () {\n    return [];\n  }, Kh.prototype.getClass = function () {\n    return Kh;\n  };\n  var Qh = function Qh() {};\n  Qh.prototype.visitItem = function (t) {}, Qh.prototype.interfaces_ = function () {\n    return [];\n  }, Qh.prototype.getClass = function () {\n    return Qh;\n  };\n  var $h = function $h() {};\n  $h.prototype.insert = function (t, e) {}, $h.prototype.remove = function (t, e) {}, $h.prototype.query = function () {}, $h.prototype.interfaces_ = function () {\n    return [];\n  }, $h.prototype.getClass = function () {\n    return $h;\n  };\n  var tp = function tp() {\n      if (this._childBoundables = new lc(), this._bounds = null, this._level = null, 0 === arguments.length) ;else if (1 === arguments.length) {\n        var t = arguments[0];\n        this._level = t;\n      }\n    },\n    ep = {\n      serialVersionUID: {\n        configurable: !0\n      }\n    };\n  tp.prototype.getLevel = function () {\n    return this._level;\n  }, tp.prototype.size = function () {\n    return this._childBoundables.size();\n  }, tp.prototype.getChildBoundables = function () {\n    return this._childBoundables;\n  }, tp.prototype.addChildBoundable = function (t) {\n    ql.isTrue(null === this._bounds), this._childBoundables.add(t);\n  }, tp.prototype.isEmpty = function () {\n    return this._childBoundables.isEmpty();\n  }, tp.prototype.getBounds = function () {\n    return null === this._bounds && (this._bounds = this.computeBounds()), this._bounds;\n  }, tp.prototype.interfaces_ = function () {\n    return [Jh, al];\n  }, tp.prototype.getClass = function () {\n    return tp;\n  }, ep.serialVersionUID.get = function () {\n    return 0x5a1e55ec41369800;\n  }, Object.defineProperties(tp, ep);\n  var np = function np() {};\n  np.reverseOrder = function () {\n    return {\n      compare: function compare(t, e) {\n        return e.compareTo(t);\n      }\n    };\n  }, np.min = function (t) {\n    return np.sort(t), t.get(0);\n  }, np.sort = function (t, e) {\n    var n = t.toArray();\n    e ? Rc.sort(n, e) : Rc.sort(n);\n    for (var r = t.iterator(), i = 0, o = n.length; i < o; i++) r.next(), r.set(n[i]);\n  }, np.singletonList = function (t) {\n    var e = new lc();\n    return e.add(t), e;\n  };\n  var rp = function rp() {\n    this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null;\n    var t = arguments[0],\n      e = arguments[1],\n      n = arguments[2];\n    this._boundable1 = t, this._boundable2 = e, this._itemDistance = n, this._distance = this.distance();\n  };\n  rp.prototype.expandToQueue = function (t, e) {\n    var n = rp.isComposite(this._boundable1),\n      r = rp.isComposite(this._boundable2);\n    if (n && r) return rp.area(this._boundable1) > rp.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, t, e), null) : (this.expand(this._boundable2, this._boundable1, t, e), null);\n    if (n) return this.expand(this._boundable1, this._boundable2, t, e), null;\n    if (r) return this.expand(this._boundable2, this._boundable1, t, e), null;\n    throw new el(\"neither boundable is composite\");\n  }, rp.prototype.isLeaves = function () {\n    return !(rp.isComposite(this._boundable1) || rp.isComposite(this._boundable2));\n  }, rp.prototype.compareTo = function (t) {\n    var e = t;\n    return this._distance < e._distance ? -1 : this._distance > e._distance ? 1 : 0;\n  }, rp.prototype.expand = function (t, e, n, r) {\n    for (var i = t.getChildBoundables().iterator(); i.hasNext();) {\n      var o = i.next(),\n        s = new rp(o, e, this._itemDistance);\n      s.getDistance() < r && n.add(s);\n    }\n  }, rp.prototype.getBoundable = function (t) {\n    return 0 === t ? this._boundable1 : this._boundable2;\n  }, rp.prototype.getDistance = function () {\n    return this._distance;\n  }, rp.prototype.distance = function () {\n    return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds());\n  }, rp.prototype.interfaces_ = function () {\n    return [il];\n  }, rp.prototype.getClass = function () {\n    return rp;\n  }, rp.area = function (t) {\n    return t.getBounds().getArea();\n  }, rp.isComposite = function (t) {\n    return t instanceof tp;\n  };\n  var ip = function t() {\n      if (this._root = null, this._built = !1, this._itemBoundables = new lc(), this._nodeCapacity = null, 0 === arguments.length) {\n        var e = t.DEFAULT_NODE_CAPACITY;\n        this._nodeCapacity = e;\n      } else if (1 === arguments.length) {\n        var n = arguments[0];\n        ql.isTrue(n > 1, \"Node capacity must be greater than 1\"), this._nodeCapacity = n;\n      }\n    },\n    op = {\n      IntersectsOp: {\n        configurable: !0\n      },\n      serialVersionUID: {\n        configurable: !0\n      },\n      DEFAULT_NODE_CAPACITY: {\n        configurable: !0\n      }\n    };\n  ip.prototype.getNodeCapacity = function () {\n    return this._nodeCapacity;\n  }, ip.prototype.lastNode = function (t) {\n    return t.get(t.size() - 1);\n  }, ip.prototype.size = function () {\n    var t = this;\n    if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.size(this._root));\n    if (1 === arguments.length) {\n      for (var e = arguments[0], n = 0, r = e.getChildBoundables().iterator(); r.hasNext();) {\n        var i = r.next();\n        i instanceof tp ? n += t.size(i) : i instanceof Zh && (n += 1);\n      }\n      return n;\n    }\n  }, ip.prototype.removeItem = function (t, e) {\n    for (var n = null, r = t.getChildBoundables().iterator(); r.hasNext();) {\n      var i = r.next();\n      i instanceof Zh && i.getItem() === e && (n = i);\n    }\n    return null !== n && (t.getChildBoundables().remove(n), !0);\n  }, ip.prototype.itemsTree = function () {\n    var t = this;\n    if (0 === arguments.length) {\n      this.build();\n      var e = this.itemsTree(this._root);\n      return null === e ? new lc() : e;\n    }\n    if (1 === arguments.length) {\n      for (var n = arguments[0], r = new lc(), i = n.getChildBoundables().iterator(); i.hasNext();) {\n        var o = i.next();\n        if (o instanceof tp) {\n          var s = t.itemsTree(o);\n          null !== s && r.add(s);\n        } else o instanceof Zh ? r.add(o.getItem()) : ql.shouldNeverReachHere();\n      }\n      return r.size() <= 0 ? null : r;\n    }\n  }, ip.prototype.insert = function (t, e) {\n    ql.isTrue(!this._built, \"Cannot insert items into an STR packed R-tree after it has been built.\"), this._itemBoundables.add(new Zh(t, e));\n  }, ip.prototype.boundablesAtLevel = function () {\n    var t = this;\n    if (1 === arguments.length) {\n      var e = arguments[0],\n        n = new lc();\n      return this.boundablesAtLevel(e, this._root, n), n;\n    }\n    if (3 === arguments.length) {\n      var r = arguments[0],\n        i = arguments[1],\n        o = arguments[2];\n      if (ql.isTrue(r > -2), i.getLevel() === r) return o.add(i), null;\n      for (var s = i.getChildBoundables().iterator(); s.hasNext();) {\n        var a = s.next();\n        a instanceof tp ? t.boundablesAtLevel(r, a, o) : (ql.isTrue(a instanceof Zh), -1 === r && o.add(a));\n      }\n      return null;\n    }\n  }, ip.prototype.query = function () {\n    var t = this;\n    if (1 === arguments.length) {\n      var e = arguments[0];\n      this.build();\n      var n = new lc();\n      return this.isEmpty() || this.getIntersectsOp().intersects(this._root.getBounds(), e) && this.query(e, this._root, n), n;\n    }\n    if (2 === arguments.length) {\n      var r = arguments[0],\n        i = arguments[1];\n      if (this.build(), this.isEmpty()) return null;\n      this.getIntersectsOp().intersects(this._root.getBounds(), r) && this.query(r, this._root, i);\n    } else if (3 === arguments.length) if (gl(arguments[2], Qh) && arguments[0] instanceof Object && arguments[1] instanceof tp) for (var o = arguments[0], s = arguments[1], a = arguments[2], u = s.getChildBoundables(), l = 0; l < u.size(); l++) {\n      var c = u.get(l);\n      t.getIntersectsOp().intersects(c.getBounds(), o) && (c instanceof tp ? t.query(o, c, a) : c instanceof Zh ? a.visitItem(c.getItem()) : ql.shouldNeverReachHere());\n    } else if (gl(arguments[2], ac) && arguments[0] instanceof Object && arguments[1] instanceof tp) for (var h = arguments[0], p = arguments[1], f = arguments[2], g = p.getChildBoundables(), d = 0; d < g.size(); d++) {\n      var y = g.get(d);\n      t.getIntersectsOp().intersects(y.getBounds(), h) && (y instanceof tp ? t.query(h, y, f) : y instanceof Zh ? f.add(y.getItem()) : ql.shouldNeverReachHere());\n    }\n  }, ip.prototype.build = function () {\n    if (this._built) return null;\n    this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = !0;\n  }, ip.prototype.getRoot = function () {\n    return this.build(), this._root;\n  }, ip.prototype.remove = function () {\n    var t = this;\n    if (2 === arguments.length) {\n      var e = arguments[0],\n        n = arguments[1];\n      return this.build(), !!this.getIntersectsOp().intersects(this._root.getBounds(), e) && this.remove(e, this._root, n);\n    }\n    if (3 === arguments.length) {\n      var r = arguments[0],\n        i = arguments[1],\n        o = arguments[2],\n        s = this.removeItem(i, o);\n      if (s) return !0;\n      for (var a = null, u = i.getChildBoundables().iterator(); u.hasNext();) {\n        var l = u.next();\n        if (t.getIntersectsOp().intersects(l.getBounds(), r) && l instanceof tp && (s = t.remove(r, l, o))) {\n          a = l;\n          break;\n        }\n      }\n      return null !== a && a.getChildBoundables().isEmpty() && i.getChildBoundables().remove(a), s;\n    }\n  }, ip.prototype.createHigherLevels = function (t, e) {\n    ql.isTrue(!t.isEmpty());\n    var n = this.createParentBoundables(t, e + 1);\n    return 1 === n.size() ? n.get(0) : this.createHigherLevels(n, e + 1);\n  }, ip.prototype.depth = function () {\n    var t = this;\n    if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));\n    if (1 === arguments.length) {\n      for (var e = arguments[0], n = 0, r = e.getChildBoundables().iterator(); r.hasNext();) {\n        var i = r.next();\n        if (i instanceof tp) {\n          var o = t.depth(i);\n          o > n && (n = o);\n        }\n      }\n      return n + 1;\n    }\n  }, ip.prototype.createParentBoundables = function (t, e) {\n    var n = this;\n    ql.isTrue(!t.isEmpty());\n    var r = new lc();\n    r.add(this.createNode(e));\n    var i = new lc(t);\n    np.sort(i, this.getComparator());\n    for (var o = i.iterator(); o.hasNext();) {\n      var s = o.next();\n      n.lastNode(r).getChildBoundables().size() === n.getNodeCapacity() && r.add(n.createNode(e)), n.lastNode(r).addChildBoundable(s);\n    }\n    return r;\n  }, ip.prototype.isEmpty = function () {\n    return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty();\n  }, ip.prototype.interfaces_ = function () {\n    return [al];\n  }, ip.prototype.getClass = function () {\n    return ip;\n  }, ip.compareDoubles = function (t, e) {\n    return t > e ? 1 : t < e ? -1 : 0;\n  }, op.IntersectsOp.get = function () {\n    return sp;\n  }, op.serialVersionUID.get = function () {\n    return -0x35ef64c82d4c5400;\n  }, op.DEFAULT_NODE_CAPACITY.get = function () {\n    return 10;\n  }, Object.defineProperties(ip, op);\n  var sp = function sp() {},\n    ap = function ap() {};\n  ap.prototype.distance = function (t, e) {}, ap.prototype.interfaces_ = function () {\n    return [];\n  }, ap.prototype.getClass = function () {\n    return ap;\n  };\n  var up = function (t) {\n      function e(n) {\n        n = n || e.DEFAULT_NODE_CAPACITY, t.call(this, n);\n      }\n      t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;\n      var n = {\n        STRtreeNode: {\n          configurable: !0\n        },\n        serialVersionUID: {\n          configurable: !0\n        },\n        xComparator: {\n          configurable: !0\n        },\n        yComparator: {\n          configurable: !0\n        },\n        intersectsOp: {\n          configurable: !0\n        },\n        DEFAULT_NODE_CAPACITY: {\n          configurable: !0\n        }\n      };\n      return e.prototype.createParentBoundablesFromVerticalSlices = function (t, e) {\n        ql.isTrue(t.length > 0);\n        for (var n = new lc(), r = 0; r < t.length; r++) n.addAll(this.createParentBoundablesFromVerticalSlice(t[r], e));\n        return n;\n      }, e.prototype.createNode = function (t) {\n        return new lp(t);\n      }, e.prototype.size = function () {\n        return 0 === arguments.length ? t.prototype.size.call(this) : t.prototype.size.apply(this, arguments);\n      }, e.prototype.insert = function () {\n        if (2 !== arguments.length) return t.prototype.insert.apply(this, arguments);\n        var e = arguments[0],\n          n = arguments[1];\n        if (e.isNull()) return null;\n        t.prototype.insert.call(this, e, n);\n      }, e.prototype.getIntersectsOp = function () {\n        return e.intersectsOp;\n      }, e.prototype.verticalSlices = function (t, e) {\n        for (var n = Math.trunc(Math.ceil(t.size() / e)), r = new Array(e).fill(null), i = t.iterator(), o = 0; o < e; o++) {\n          r[o] = new lc();\n          for (var s = 0; i.hasNext() && s < n;) {\n            var a = i.next();\n            r[o].add(a), s++;\n          }\n        }\n        return r;\n      }, e.prototype.query = function () {\n        if (1 === arguments.length) {\n          var e = arguments[0];\n          return t.prototype.query.call(this, e);\n        }\n        if (2 === arguments.length) {\n          var n = arguments[0],\n            r = arguments[1];\n          t.prototype.query.call(this, n, r);\n        } else if (3 === arguments.length) if (gl(arguments[2], Qh) && arguments[0] instanceof Object && arguments[1] instanceof tp) {\n          var i = arguments[0],\n            o = arguments[1],\n            s = arguments[2];\n          t.prototype.query.call(this, i, o, s);\n        } else if (gl(arguments[2], ac) && arguments[0] instanceof Object && arguments[1] instanceof tp) {\n          var a = arguments[0],\n            u = arguments[1],\n            l = arguments[2];\n          t.prototype.query.call(this, a, u, l);\n        }\n      }, e.prototype.getComparator = function () {\n        return e.yComparator;\n      }, e.prototype.createParentBoundablesFromVerticalSlice = function (e, n) {\n        return t.prototype.createParentBoundables.call(this, e, n);\n      }, e.prototype.remove = function () {\n        if (2 === arguments.length) {\n          var e = arguments[0],\n            n = arguments[1];\n          return t.prototype.remove.call(this, e, n);\n        }\n        return t.prototype.remove.apply(this, arguments);\n      }, e.prototype.depth = function () {\n        return 0 === arguments.length ? t.prototype.depth.call(this) : t.prototype.depth.apply(this, arguments);\n      }, e.prototype.createParentBoundables = function (t, n) {\n        ql.isTrue(!t.isEmpty());\n        var r = Math.trunc(Math.ceil(t.size() / this.getNodeCapacity())),\n          i = new lc(t);\n        np.sort(i, e.xComparator);\n        var o = this.verticalSlices(i, Math.trunc(Math.ceil(Math.sqrt(r))));\n        return this.createParentBoundablesFromVerticalSlices(o, n);\n      }, e.prototype.nearestNeighbour = function () {\n        if (1 === arguments.length) {\n          if (gl(arguments[0], ap)) {\n            var t = arguments[0],\n              n = new rp(this.getRoot(), this.getRoot(), t);\n            return this.nearestNeighbour(n);\n          }\n          if (arguments[0] instanceof rp) {\n            var r = arguments[0];\n            return this.nearestNeighbour(r, nl.POSITIVE_INFINITY);\n          }\n        } else if (2 === arguments.length) {\n          if (arguments[0] instanceof e && gl(arguments[1], ap)) {\n            var i = arguments[0],\n              o = arguments[1],\n              s = new rp(this.getRoot(), i.getRoot(), o);\n            return this.nearestNeighbour(s);\n          }\n          if (arguments[0] instanceof rp && \"number\" == typeof arguments[1]) {\n            var a = arguments[0],\n              u = arguments[1],\n              l = u,\n              c = null,\n              h = new Kh();\n            for (h.add(a); !h.isEmpty() && l > 0;) {\n              var p = h.poll(),\n                f = p.getDistance();\n              if (f >= l) break;\n              p.isLeaves() ? (l = f, c = p) : p.expandToQueue(h, l);\n            }\n            return [c.getBoundable(0).getItem(), c.getBoundable(1).getItem()];\n          }\n        } else if (3 === arguments.length) {\n          var g = arguments[0],\n            d = arguments[1],\n            y = arguments[2],\n            v = new Zh(g, d),\n            _ = new rp(this.getRoot(), v, y);\n          return this.nearestNeighbour(_)[0];\n        }\n      }, e.prototype.interfaces_ = function () {\n        return [$h, al];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, e.centreX = function (t) {\n        return e.avg(t.getMinX(), t.getMaxX());\n      }, e.avg = function (t, e) {\n        return (t + e) / 2;\n      }, e.centreY = function (t) {\n        return e.avg(t.getMinY(), t.getMaxY());\n      }, n.STRtreeNode.get = function () {\n        return lp;\n      }, n.serialVersionUID.get = function () {\n        return 0x39920f7d5f261e0;\n      }, n.xComparator.get = function () {\n        return {\n          interfaces_: function interfaces_() {\n            return [sl];\n          },\n          compare: function compare(n, r) {\n            return t.compareDoubles(e.centreX(n.getBounds()), e.centreX(r.getBounds()));\n          }\n        };\n      }, n.yComparator.get = function () {\n        return {\n          interfaces_: function interfaces_() {\n            return [sl];\n          },\n          compare: function compare(n, r) {\n            return t.compareDoubles(e.centreY(n.getBounds()), e.centreY(r.getBounds()));\n          }\n        };\n      }, n.intersectsOp.get = function () {\n        return {\n          interfaces_: function interfaces_() {\n            return [t.IntersectsOp];\n          },\n          intersects: function intersects(t, e) {\n            return t.intersects(e);\n          }\n        };\n      }, n.DEFAULT_NODE_CAPACITY.get = function () {\n        return 10;\n      }, Object.defineProperties(e, n), e;\n    }(ip),\n    lp = function (t) {\n      function e() {\n        var e = arguments[0];\n        t.call(this, e);\n      }\n      return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.computeBounds = function () {\n        for (var t = null, e = this.getChildBoundables().iterator(); e.hasNext();) {\n          var n = e.next();\n          null === t ? t = new Ll(n.getBounds()) : t.expandToInclude(n.getBounds());\n        }\n        return t;\n      }, e.prototype.interfaces_ = function () {\n        return [];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, e;\n    }(tp),\n    cp = function cp() {};\n  cp.prototype.interfaces_ = function () {\n    return [];\n  }, cp.prototype.getClass = function () {\n    return cp;\n  }, cp.relativeSign = function (t, e) {\n    return t < e ? -1 : t > e ? 1 : 0;\n  }, cp.compare = function (t, e, n) {\n    if (e.equals2D(n)) return 0;\n    var r = cp.relativeSign(e.x, n.x),\n      i = cp.relativeSign(e.y, n.y);\n    switch (t) {\n      case 0:\n        return cp.compareValue(r, i);\n      case 1:\n        return cp.compareValue(i, r);\n      case 2:\n        return cp.compareValue(i, -r);\n      case 3:\n        return cp.compareValue(-r, i);\n      case 4:\n        return cp.compareValue(-r, -i);\n      case 5:\n        return cp.compareValue(-i, -r);\n      case 6:\n        return cp.compareValue(-i, r);\n      case 7:\n        return cp.compareValue(r, -i);\n    }\n    return ql.shouldNeverReachHere(\"invalid octant value\"), 0;\n  }, cp.compareValue = function (t, e) {\n    return t < 0 ? -1 : t > 0 ? 1 : e < 0 ? -1 : e > 0 ? 1 : 0;\n  };\n  var hp = function hp() {\n    this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null;\n    var t = arguments[0],\n      e = arguments[1],\n      n = arguments[2],\n      r = arguments[3];\n    this._segString = t, this.coord = new ul(e), this.segmentIndex = n, this._segmentOctant = r, this._isInterior = !e.equals2D(t.getCoordinate(n));\n  };\n  hp.prototype.getCoordinate = function () {\n    return this.coord;\n  }, hp.prototype.print = function (t) {\n    t.print(this.coord), t.print(\" seg # = \" + this.segmentIndex);\n  }, hp.prototype.compareTo = function (t) {\n    var e = t;\n    return this.segmentIndex < e.segmentIndex ? -1 : this.segmentIndex > e.segmentIndex ? 1 : this.coord.equals2D(e.coord) ? 0 : cp.compare(this._segmentOctant, this.coord, e.coord);\n  }, hp.prototype.isEndPoint = function (t) {\n    return 0 === this.segmentIndex && !this._isInterior || this.segmentIndex === t;\n  }, hp.prototype.isInterior = function () {\n    return this._isInterior;\n  }, hp.prototype.interfaces_ = function () {\n    return [il];\n  }, hp.prototype.getClass = function () {\n    return hp;\n  };\n  var pp = function pp() {\n    this._nodeMap = new Cc(), this._edge = null;\n    var t = arguments[0];\n    this._edge = t;\n  };\n  pp.prototype.getSplitCoordinates = function () {\n    var t = new hc();\n    this.addEndpoints();\n    for (var e = this.iterator(), n = e.next(); e.hasNext();) {\n      var r = e.next();\n      this.addEdgeCoordinates(n, r, t), n = r;\n    }\n    return t.toCoordinateArray();\n  }, pp.prototype.addCollapsedNodes = function () {\n    var t = new lc();\n    this.findCollapsesFromInsertedNodes(t), this.findCollapsesFromExistingVertices(t);\n    for (var e = t.iterator(); e.hasNext();) {\n      var n = e.next().intValue();\n      this.add(this._edge.getCoordinate(n), n);\n    }\n  }, pp.prototype.print = function (t) {\n    t.println(\"Intersections:\");\n    for (var e = this.iterator(); e.hasNext();) {\n      e.next().print(t);\n    }\n  }, pp.prototype.findCollapsesFromExistingVertices = function (t) {\n    for (var e = 0; e < this._edge.size() - 2; e++) {\n      var n = this._edge.getCoordinate(e),\n        r = this._edge.getCoordinate(e + 2);\n      n.equals2D(r) && t.add(new _l(e + 1));\n    }\n  }, pp.prototype.addEdgeCoordinates = function (t, e, n) {\n    var r = this._edge.getCoordinate(e.segmentIndex),\n      i = e.isInterior() || !e.coord.equals2D(r);\n    n.add(new ul(t.coord), !1);\n    for (var o = t.segmentIndex + 1; o <= e.segmentIndex; o++) n.add(this._edge.getCoordinate(o));\n    i && n.add(new ul(e.coord));\n  }, pp.prototype.iterator = function () {\n    return this._nodeMap.values().iterator();\n  }, pp.prototype.addSplitEdges = function (t) {\n    this.addEndpoints(), this.addCollapsedNodes();\n    for (var e = this.iterator(), n = e.next(); e.hasNext();) {\n      var r = e.next(),\n        i = this.createSplitEdge(n, r);\n      t.add(i), n = r;\n    }\n  }, pp.prototype.findCollapseIndex = function (t, e, n) {\n    if (!t.coord.equals2D(e.coord)) return !1;\n    var r = e.segmentIndex - t.segmentIndex;\n    return e.isInterior() || r--, 1 === r && (n[0] = t.segmentIndex + 1, !0);\n  }, pp.prototype.findCollapsesFromInsertedNodes = function (t) {\n    for (var e = new Array(1).fill(null), n = this.iterator(), r = n.next(); n.hasNext();) {\n      var i = n.next();\n      this.findCollapseIndex(r, i, e) && t.add(new _l(e[0])), r = i;\n    }\n  }, pp.prototype.getEdge = function () {\n    return this._edge;\n  }, pp.prototype.addEndpoints = function () {\n    var t = this._edge.size() - 1;\n    this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(t), t);\n  }, pp.prototype.createSplitEdge = function (t, e) {\n    var n = e.segmentIndex - t.segmentIndex + 2,\n      r = this._edge.getCoordinate(e.segmentIndex),\n      i = e.isInterior() || !e.coord.equals2D(r);\n    i || n--;\n    var o = new Array(n).fill(null),\n      s = 0;\n    o[s++] = new ul(t.coord);\n    for (var a = t.segmentIndex + 1; a <= e.segmentIndex; a++) o[s++] = this._edge.getCoordinate(a);\n    return i && (o[s] = new ul(e.coord)), new yp(o, this._edge.getData());\n  }, pp.prototype.add = function (t, e) {\n    var n = new hp(this._edge, t, e, this._edge.getSegmentOctant(e)),\n      r = this._nodeMap.get(n);\n    return null !== r ? (ql.isTrue(r.coord.equals2D(t), \"Found equal nodes with different coordinates\"), r) : (this._nodeMap.put(n, n), n);\n  }, pp.prototype.checkSplitEdgesCorrectness = function (t) {\n    var e = this._edge.getCoordinates(),\n      n = t.get(0).getCoordinate(0);\n    if (!n.equals2D(e[0])) throw new kl(\"bad split edge start point at \" + n);\n    var r = t.get(t.size() - 1).getCoordinates(),\n      i = r[r.length - 1];\n    if (!i.equals2D(e[e.length - 1])) throw new kl(\"bad split edge end point at \" + i);\n  }, pp.prototype.interfaces_ = function () {\n    return [];\n  }, pp.prototype.getClass = function () {\n    return pp;\n  };\n  var fp = function fp() {};\n  fp.prototype.interfaces_ = function () {\n    return [];\n  }, fp.prototype.getClass = function () {\n    return fp;\n  }, fp.octant = function () {\n    if (\"number\" == typeof arguments[0] && \"number\" == typeof arguments[1]) {\n      var t = arguments[0],\n        e = arguments[1];\n      if (0 === t && 0 === e) throw new el(\"Cannot compute the octant for point ( \" + t + \", \" + e + \" )\");\n      var n = Math.abs(t),\n        r = Math.abs(e);\n      return t >= 0 ? e >= 0 ? n >= r ? 0 : 1 : n >= r ? 7 : 6 : e >= 0 ? n >= r ? 3 : 2 : n >= r ? 4 : 5;\n    }\n    if (arguments[0] instanceof ul && arguments[1] instanceof ul) {\n      var i = arguments[0],\n        o = arguments[1],\n        s = o.x - i.x,\n        a = o.y - i.y;\n      if (0 === s && 0 === a) throw new el(\"Cannot compute the octant for two identical points \" + i);\n      return fp.octant(s, a);\n    }\n  };\n  var gp = function gp() {};\n  gp.prototype.getCoordinates = function () {}, gp.prototype.size = function () {}, gp.prototype.getCoordinate = function (t) {}, gp.prototype.isClosed = function () {}, gp.prototype.setData = function (t) {}, gp.prototype.getData = function () {}, gp.prototype.interfaces_ = function () {\n    return [];\n  }, gp.prototype.getClass = function () {\n    return gp;\n  };\n  var dp = function dp() {};\n  dp.prototype.addIntersection = function (t, e) {}, dp.prototype.interfaces_ = function () {\n    return [gp];\n  }, dp.prototype.getClass = function () {\n    return dp;\n  };\n  var yp = function yp() {\n    this._nodeList = new pp(this), this._pts = null, this._data = null;\n    var t = arguments[0],\n      e = arguments[1];\n    this._pts = t, this._data = e;\n  };\n  yp.prototype.getCoordinates = function () {\n    return this._pts;\n  }, yp.prototype.size = function () {\n    return this._pts.length;\n  }, yp.prototype.getCoordinate = function (t) {\n    return this._pts[t];\n  }, yp.prototype.isClosed = function () {\n    return this._pts[0].equals(this._pts[this._pts.length - 1]);\n  }, yp.prototype.getSegmentOctant = function (t) {\n    return t === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t), this.getCoordinate(t + 1));\n  }, yp.prototype.setData = function (t) {\n    this._data = t;\n  }, yp.prototype.safeOctant = function (t, e) {\n    return t.equals2D(e) ? 0 : fp.octant(t, e);\n  }, yp.prototype.getData = function () {\n    return this._data;\n  }, yp.prototype.addIntersection = function () {\n    if (2 === arguments.length) {\n      var t = arguments[0],\n        e = arguments[1];\n      this.addIntersectionNode(t, e);\n    } else if (4 === arguments.length) {\n      var n = arguments[0],\n        r = arguments[1],\n        i = arguments[3],\n        o = new ul(n.getIntersection(i));\n      this.addIntersection(o, r);\n    }\n  }, yp.prototype.toString = function () {\n    return Fl.toLineString(new lh(this._pts));\n  }, yp.prototype.getNodeList = function () {\n    return this._nodeList;\n  }, yp.prototype.addIntersectionNode = function (t, e) {\n    var n = e,\n      r = n + 1;\n    if (r < this._pts.length) {\n      var i = this._pts[r];\n      t.equals2D(i) && (n = r);\n    }\n    return this._nodeList.add(t, n);\n  }, yp.prototype.addIntersections = function (t, e, n) {\n    for (var r = 0; r < t.getIntersectionNum(); r++) this.addIntersection(t, e, n, r);\n  }, yp.prototype.interfaces_ = function () {\n    return [dp];\n  }, yp.prototype.getClass = function () {\n    return yp;\n  }, yp.getNodedSubstrings = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0],\n        e = new lc();\n      return yp.getNodedSubstrings(t, e), e;\n    }\n    if (2 === arguments.length) for (var n = arguments[0], r = arguments[1], i = n.iterator(); i.hasNext();) {\n      var o = i.next();\n      o.getNodeList().addSplitEdges(r);\n    }\n  };\n  var vp = function vp() {\n      if (this.p0 = null, this.p1 = null, 0 === arguments.length) this.p0 = new ul(), this.p1 = new ul();else if (1 === arguments.length) {\n        var t = arguments[0];\n        this.p0 = new ul(t.p0), this.p1 = new ul(t.p1);\n      } else if (2 === arguments.length) this.p0 = arguments[0], this.p1 = arguments[1];else if (4 === arguments.length) {\n        var e = arguments[0],\n          n = arguments[1],\n          r = arguments[2],\n          i = arguments[3];\n        this.p0 = new ul(e, n), this.p1 = new ul(r, i);\n      }\n    },\n    _p = {\n      serialVersionUID: {\n        configurable: !0\n      }\n    };\n  vp.prototype.minX = function () {\n    return Math.min(this.p0.x, this.p1.x);\n  }, vp.prototype.orientationIndex = function () {\n    if (arguments[0] instanceof vp) {\n      var t = arguments[0],\n        e = Xl.orientationIndex(this.p0, this.p1, t.p0),\n        n = Xl.orientationIndex(this.p0, this.p1, t.p1);\n      return e >= 0 && n >= 0 || e <= 0 && n <= 0 ? Math.max(e, n) : 0;\n    }\n    if (arguments[0] instanceof ul) {\n      var r = arguments[0];\n      return Xl.orientationIndex(this.p0, this.p1, r);\n    }\n  }, vp.prototype.toGeometry = function (t) {\n    return t.createLineString([this.p0, this.p1]);\n  }, vp.prototype.isVertical = function () {\n    return this.p0.x === this.p1.x;\n  }, vp.prototype.equals = function (t) {\n    if (!(t instanceof vp)) return !1;\n    var e = t;\n    return this.p0.equals(e.p0) && this.p1.equals(e.p1);\n  }, vp.prototype.intersection = function (t) {\n    var e = new jl();\n    return e.computeIntersection(this.p0, this.p1, t.p0, t.p1), e.hasIntersection() ? e.getIntersection(0) : null;\n  }, vp.prototype.project = function () {\n    if (arguments[0] instanceof ul) {\n      var t = arguments[0];\n      if (t.equals(this.p0) || t.equals(this.p1)) return new ul(t);\n      var e = this.projectionFactor(t),\n        n = new ul();\n      return n.x = this.p0.x + e * (this.p1.x - this.p0.x), n.y = this.p0.y + e * (this.p1.y - this.p0.y), n;\n    }\n    if (arguments[0] instanceof vp) {\n      var r = arguments[0],\n        i = this.projectionFactor(r.p0),\n        o = this.projectionFactor(r.p1);\n      if (i >= 1 && o >= 1) return null;\n      if (i <= 0 && o <= 0) return null;\n      var s = this.project(r.p0);\n      i < 0 && (s = this.p0), i > 1 && (s = this.p1);\n      var a = this.project(r.p1);\n      return o < 0 && (a = this.p0), o > 1 && (a = this.p1), new vp(s, a);\n    }\n  }, vp.prototype.normalize = function () {\n    this.p1.compareTo(this.p0) < 0 && this.reverse();\n  }, vp.prototype.angle = function () {\n    return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);\n  }, vp.prototype.getCoordinate = function (t) {\n    return 0 === t ? this.p0 : this.p1;\n  }, vp.prototype.distancePerpendicular = function (t) {\n    return Xl.distancePointLinePerpendicular(t, this.p0, this.p1);\n  }, vp.prototype.minY = function () {\n    return Math.min(this.p0.y, this.p1.y);\n  }, vp.prototype.midPoint = function () {\n    return vp.midPoint(this.p0, this.p1);\n  }, vp.prototype.projectionFactor = function (t) {\n    if (t.equals(this.p0)) return 0;\n    if (t.equals(this.p1)) return 1;\n    var e = this.p1.x - this.p0.x,\n      n = this.p1.y - this.p0.y,\n      r = e * e + n * n;\n    return r <= 0 ? nl.NaN : ((t.x - this.p0.x) * e + (t.y - this.p0.y) * n) / r;\n  }, vp.prototype.closestPoints = function (t) {\n    var e = this.intersection(t);\n    if (null !== e) return [e, e];\n    var n = new Array(2).fill(null),\n      r = nl.MAX_VALUE,\n      i = null,\n      o = this.closestPoint(t.p0);\n    r = o.distance(t.p0), n[0] = o, n[1] = t.p0;\n    var s = this.closestPoint(t.p1);\n    (i = s.distance(t.p1)) < r && (r = i, n[0] = s, n[1] = t.p1);\n    var a = t.closestPoint(this.p0);\n    (i = a.distance(this.p0)) < r && (r = i, n[0] = this.p0, n[1] = a);\n    var u = t.closestPoint(this.p1);\n    return (i = u.distance(this.p1)) < r && (r = i, n[0] = this.p1, n[1] = u), n;\n  }, vp.prototype.closestPoint = function (t) {\n    var e = this.projectionFactor(t);\n    return e > 0 && e < 1 ? this.project(t) : this.p0.distance(t) < this.p1.distance(t) ? this.p0 : this.p1;\n  }, vp.prototype.maxX = function () {\n    return Math.max(this.p0.x, this.p1.x);\n  }, vp.prototype.getLength = function () {\n    return this.p0.distance(this.p1);\n  }, vp.prototype.compareTo = function (t) {\n    var e = t,\n      n = this.p0.compareTo(e.p0);\n    return 0 !== n ? n : this.p1.compareTo(e.p1);\n  }, vp.prototype.reverse = function () {\n    var t = this.p0;\n    this.p0 = this.p1, this.p1 = t;\n  }, vp.prototype.equalsTopo = function (t) {\n    return this.p0.equals(t.p0) && (this.p1.equals(t.p1) || this.p0.equals(t.p1)) && this.p1.equals(t.p0);\n  }, vp.prototype.lineIntersection = function (t) {\n    try {\n      return Ml.intersection(this.p0, this.p1, t.p0, t.p1);\n    } catch (t) {\n      if (!(t instanceof Cl)) throw t;\n    }\n    return null;\n  }, vp.prototype.maxY = function () {\n    return Math.max(this.p0.y, this.p1.y);\n  }, vp.prototype.pointAlongOffset = function (t, e) {\n    var n = this.p0.x + t * (this.p1.x - this.p0.x),\n      r = this.p0.y + t * (this.p1.y - this.p0.y),\n      i = this.p1.x - this.p0.x,\n      o = this.p1.y - this.p0.y,\n      s = Math.sqrt(i * i + o * o),\n      a = 0,\n      u = 0;\n    if (0 !== e) {\n      if (s <= 0) throw new Error(\"Cannot compute offset from zero-length line segment\");\n      a = e * i / s, u = e * o / s;\n    }\n    return new ul(n - u, r + a);\n  }, vp.prototype.setCoordinates = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      this.setCoordinates(t.p0, t.p1);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n        n = arguments[1];\n      this.p0.x = e.x, this.p0.y = e.y, this.p1.x = n.x, this.p1.y = n.y;\n    }\n  }, vp.prototype.segmentFraction = function (t) {\n    var e = this.projectionFactor(t);\n    return e < 0 ? e = 0 : (e > 1 || nl.isNaN(e)) && (e = 1), e;\n  }, vp.prototype.toString = function () {\n    return \"LINESTRING( \" + this.p0.x + \" \" + this.p0.y + \", \" + this.p1.x + \" \" + this.p1.y + \")\";\n  }, vp.prototype.isHorizontal = function () {\n    return this.p0.y === this.p1.y;\n  }, vp.prototype.distance = function () {\n    if (arguments[0] instanceof vp) {\n      var t = arguments[0];\n      return Xl.distanceLineLine(this.p0, this.p1, t.p0, t.p1);\n    }\n    if (arguments[0] instanceof ul) {\n      var e = arguments[0];\n      return Xl.distancePointLine(e, this.p0, this.p1);\n    }\n  }, vp.prototype.pointAlong = function (t) {\n    var e = new ul();\n    return e.x = this.p0.x + t * (this.p1.x - this.p0.x), e.y = this.p0.y + t * (this.p1.y - this.p0.y), e;\n  }, vp.prototype.hashCode = function () {\n    var t = nl.doubleToLongBits(this.p0.x);\n    t ^= 31 * nl.doubleToLongBits(this.p0.y);\n    var e = Math.trunc(t) ^ Math.trunc(t >> 32),\n      n = nl.doubleToLongBits(this.p1.x);\n    return n ^= 31 * nl.doubleToLongBits(this.p1.y), e ^ (Math.trunc(n) ^ Math.trunc(n >> 32));\n  }, vp.prototype.interfaces_ = function () {\n    return [il, al];\n  }, vp.prototype.getClass = function () {\n    return vp;\n  }, vp.midPoint = function (t, e) {\n    return new ul((t.x + e.x) / 2, (t.y + e.y) / 2);\n  }, _p.serialVersionUID.get = function () {\n    return 0x2d2172135f411c00;\n  }, Object.defineProperties(vp, _p);\n  var mp = function mp() {\n    this.tempEnv1 = new Ll(), this.tempEnv2 = new Ll(), this._overlapSeg1 = new vp(), this._overlapSeg2 = new vp();\n  };\n  mp.prototype.overlap = function () {\n    if (2 === arguments.length) ;else if (4 === arguments.length) {\n      var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2],\n        r = arguments[3];\n      t.getLineSegment(e, this._overlapSeg1), n.getLineSegment(r, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2);\n    }\n  }, mp.prototype.interfaces_ = function () {\n    return [];\n  }, mp.prototype.getClass = function () {\n    return mp;\n  };\n  var xp = function xp() {\n    this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null;\n    var t = arguments[0],\n      e = arguments[1],\n      n = arguments[2],\n      r = arguments[3];\n    this._pts = t, this._start = e, this._end = n, this._context = r;\n  };\n  xp.prototype.getLineSegment = function (t, e) {\n    e.p0 = this._pts[t], e.p1 = this._pts[t + 1];\n  }, xp.prototype.computeSelect = function (t, e, n, r) {\n    var i = this._pts[e],\n      o = this._pts[n];\n    if (r.tempEnv1.init(i, o), n - e == 1) return r.select(this, e), null;\n    if (!t.intersects(r.tempEnv1)) return null;\n    var s = Math.trunc((e + n) / 2);\n    e < s && this.computeSelect(t, e, s, r), s < n && this.computeSelect(t, s, n, r);\n  }, xp.prototype.getCoordinates = function () {\n    for (var t = new Array(this._end - this._start + 1).fill(null), e = 0, n = this._start; n <= this._end; n++) t[e++] = this._pts[n];\n    return t;\n  }, xp.prototype.computeOverlaps = function (t, e) {\n    this.computeOverlapsInternal(this._start, this._end, t, t._start, t._end, e);\n  }, xp.prototype.setId = function (t) {\n    this._id = t;\n  }, xp.prototype.select = function (t, e) {\n    this.computeSelect(t, this._start, this._end, e);\n  }, xp.prototype.getEnvelope = function () {\n    if (null === this._env) {\n      var t = this._pts[this._start],\n        e = this._pts[this._end];\n      this._env = new Ll(t, e);\n    }\n    return this._env;\n  }, xp.prototype.getEndIndex = function () {\n    return this._end;\n  }, xp.prototype.getStartIndex = function () {\n    return this._start;\n  }, xp.prototype.getContext = function () {\n    return this._context;\n  }, xp.prototype.getId = function () {\n    return this._id;\n  }, xp.prototype.computeOverlapsInternal = function (t, e, n, r, i, o) {\n    var s = this._pts[t],\n      a = this._pts[e],\n      u = n._pts[r],\n      l = n._pts[i];\n    if (e - t == 1 && i - r == 1) return o.overlap(this, t, n, r), null;\n    if (o.tempEnv1.init(s, a), o.tempEnv2.init(u, l), !o.tempEnv1.intersects(o.tempEnv2)) return null;\n    var c = Math.trunc((t + e) / 2),\n      h = Math.trunc((r + i) / 2);\n    t < c && (r < h && this.computeOverlapsInternal(t, c, n, r, h, o), h < i && this.computeOverlapsInternal(t, c, n, h, i, o)), c < e && (r < h && this.computeOverlapsInternal(c, e, n, r, h, o), h < i && this.computeOverlapsInternal(c, e, n, h, i, o));\n  }, xp.prototype.interfaces_ = function () {\n    return [];\n  }, xp.prototype.getClass = function () {\n    return xp;\n  };\n  var Ep = function Ep() {};\n  Ep.prototype.interfaces_ = function () {\n    return [];\n  }, Ep.prototype.getClass = function () {\n    return Ep;\n  }, Ep.getChainStartIndices = function (t) {\n    var e = 0,\n      n = new lc();\n    n.add(new _l(e));\n    do {\n      var r = Ep.findChainEnd(t, e);\n      n.add(new _l(r)), e = r;\n    } while (e < t.length - 1);\n    return Ep.toIntArray(n);\n  }, Ep.findChainEnd = function (t, e) {\n    for (var n = e; n < t.length - 1 && t[n].equals2D(t[n + 1]);) n++;\n    if (n >= t.length - 1) return t.length - 1;\n    for (var r = jh.quadrant(t[n], t[n + 1]), i = e + 1; i < t.length;) {\n      if (!t[i - 1].equals2D(t[i])) if (jh.quadrant(t[i - 1], t[i]) !== r) break;\n      i++;\n    }\n    return i - 1;\n  }, Ep.getChains = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return Ep.getChains(t, null);\n    }\n    if (2 === arguments.length) {\n      for (var e = arguments[0], n = arguments[1], r = new lc(), i = Ep.getChainStartIndices(e), o = 0; o < i.length - 1; o++) {\n        var s = new xp(e, i[o], i[o + 1], n);\n        r.add(s);\n      }\n      return r;\n    }\n  }, Ep.toIntArray = function (t) {\n    for (var e = new Array(t.size()).fill(null), n = 0; n < e.length; n++) e[n] = t.get(n).intValue();\n    return e;\n  };\n  var bp = function bp() {};\n  bp.prototype.computeNodes = function (t) {}, bp.prototype.getNodedSubstrings = function () {}, bp.prototype.interfaces_ = function () {\n    return [];\n  }, bp.prototype.getClass = function () {\n    return bp;\n  };\n  var wp = function wp() {\n    if (this._segInt = null, 0 === arguments.length) ;else if (1 === arguments.length) {\n      var t = arguments[0];\n      this.setSegmentIntersector(t);\n    }\n  };\n  wp.prototype.setSegmentIntersector = function (t) {\n    this._segInt = t;\n  }, wp.prototype.interfaces_ = function () {\n    return [bp];\n  }, wp.prototype.getClass = function () {\n    return wp;\n  };\n  var Ip = function (t) {\n      function e(e) {\n        e ? t.call(this, e) : t.call(this), this._monoChains = new lc(), this._index = new up(), this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0;\n      }\n      t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;\n      var n = {\n        SegmentOverlapAction: {\n          configurable: !0\n        }\n      };\n      return e.prototype.getMonotoneChains = function () {\n        return this._monoChains;\n      }, e.prototype.getNodedSubstrings = function () {\n        return yp.getNodedSubstrings(this._nodedSegStrings);\n      }, e.prototype.getIndex = function () {\n        return this._index;\n      }, e.prototype.add = function (t) {\n        for (var e = this, n = Ep.getChains(t.getCoordinates(), t).iterator(); n.hasNext();) {\n          var r = n.next();\n          r.setId(e._idCounter++), e._index.insert(r.getEnvelope(), r), e._monoChains.add(r);\n        }\n      }, e.prototype.computeNodes = function (t) {\n        this._nodedSegStrings = t;\n        for (var e = t.iterator(); e.hasNext();) this.add(e.next());\n        this.intersectChains();\n      }, e.prototype.intersectChains = function () {\n        for (var t = this, e = new Np(this._segInt), n = this._monoChains.iterator(); n.hasNext();) for (var r = n.next(), i = t._index.query(r.getEnvelope()).iterator(); i.hasNext();) {\n          var o = i.next();\n          if (o.getId() > r.getId() && (r.computeOverlaps(o, e), t._nOverlaps++), t._segInt.isDone()) return null;\n        }\n      }, e.prototype.interfaces_ = function () {\n        return [];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, n.SegmentOverlapAction.get = function () {\n        return Np;\n      }, Object.defineProperties(e, n), e;\n    }(wp),\n    Np = function (t) {\n      function e() {\n        t.call(this), this._si = null;\n        var e = arguments[0];\n        this._si = e;\n      }\n      return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.overlap = function () {\n        if (4 !== arguments.length) return t.prototype.overlap.apply(this, arguments);\n        var e = arguments[0],\n          n = arguments[1],\n          r = arguments[2],\n          i = arguments[3],\n          o = e.getContext(),\n          s = r.getContext();\n        this._si.processIntersections(o, n, s, i);\n      }, e.prototype.interfaces_ = function () {\n        return [];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, e;\n    }(mp),\n    Sp = function t() {\n      if (this._quadrantSegments = t.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = t.CAP_ROUND, this._joinStyle = t.JOIN_ROUND, this._mitreLimit = t.DEFAULT_MITRE_LIMIT, this._isSingleSided = !1, this._simplifyFactor = t.DEFAULT_SIMPLIFY_FACTOR, 0 === arguments.length) ;else if (1 === arguments.length) {\n        var e = arguments[0];\n        this.setQuadrantSegments(e);\n      } else if (2 === arguments.length) {\n        var n = arguments[0],\n          r = arguments[1];\n        this.setQuadrantSegments(n), this.setEndCapStyle(r);\n      } else if (4 === arguments.length) {\n        var i = arguments[0],\n          o = arguments[1],\n          s = arguments[2],\n          a = arguments[3];\n        this.setQuadrantSegments(i), this.setEndCapStyle(o), this.setJoinStyle(s), this.setMitreLimit(a);\n      }\n    },\n    Cp = {\n      CAP_ROUND: {\n        configurable: !0\n      },\n      CAP_FLAT: {\n        configurable: !0\n      },\n      CAP_SQUARE: {\n        configurable: !0\n      },\n      JOIN_ROUND: {\n        configurable: !0\n      },\n      JOIN_MITRE: {\n        configurable: !0\n      },\n      JOIN_BEVEL: {\n        configurable: !0\n      },\n      DEFAULT_QUADRANT_SEGMENTS: {\n        configurable: !0\n      },\n      DEFAULT_MITRE_LIMIT: {\n        configurable: !0\n      },\n      DEFAULT_SIMPLIFY_FACTOR: {\n        configurable: !0\n      }\n    };\n  Sp.prototype.getEndCapStyle = function () {\n    return this._endCapStyle;\n  }, Sp.prototype.isSingleSided = function () {\n    return this._isSingleSided;\n  }, Sp.prototype.setQuadrantSegments = function (t) {\n    this._quadrantSegments = t, 0 === this._quadrantSegments && (this._joinStyle = Sp.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = Sp.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), t <= 0 && (this._quadrantSegments = 1), this._joinStyle !== Sp.JOIN_ROUND && (this._quadrantSegments = Sp.DEFAULT_QUADRANT_SEGMENTS);\n  }, Sp.prototype.getJoinStyle = function () {\n    return this._joinStyle;\n  }, Sp.prototype.setJoinStyle = function (t) {\n    this._joinStyle = t;\n  }, Sp.prototype.setSimplifyFactor = function (t) {\n    this._simplifyFactor = t < 0 ? 0 : t;\n  }, Sp.prototype.getSimplifyFactor = function () {\n    return this._simplifyFactor;\n  }, Sp.prototype.getQuadrantSegments = function () {\n    return this._quadrantSegments;\n  }, Sp.prototype.setEndCapStyle = function (t) {\n    this._endCapStyle = t;\n  }, Sp.prototype.getMitreLimit = function () {\n    return this._mitreLimit;\n  }, Sp.prototype.setMitreLimit = function (t) {\n    this._mitreLimit = t;\n  }, Sp.prototype.setSingleSided = function (t) {\n    this._isSingleSided = t;\n  }, Sp.prototype.interfaces_ = function () {\n    return [];\n  }, Sp.prototype.getClass = function () {\n    return Sp;\n  }, Sp.bufferDistanceError = function (t) {\n    var e = Math.PI / 2 / t;\n    return 1 - Math.cos(e / 2);\n  }, Cp.CAP_ROUND.get = function () {\n    return 1;\n  }, Cp.CAP_FLAT.get = function () {\n    return 2;\n  }, Cp.CAP_SQUARE.get = function () {\n    return 3;\n  }, Cp.JOIN_ROUND.get = function () {\n    return 1;\n  }, Cp.JOIN_MITRE.get = function () {\n    return 2;\n  }, Cp.JOIN_BEVEL.get = function () {\n    return 3;\n  }, Cp.DEFAULT_QUADRANT_SEGMENTS.get = function () {\n    return 8;\n  }, Cp.DEFAULT_MITRE_LIMIT.get = function () {\n    return 5;\n  }, Cp.DEFAULT_SIMPLIFY_FACTOR.get = function () {\n    return .01;\n  }, Object.defineProperties(Sp, Cp);\n  var Pp = function Pp(t) {\n      this._distanceTol = null, this._isDeleted = null, this._angleOrientation = Xl.COUNTERCLOCKWISE, this._inputLine = t || null;\n    },\n    Mp = {\n      INIT: {\n        configurable: !0\n      },\n      DELETE: {\n        configurable: !0\n      },\n      KEEP: {\n        configurable: !0\n      },\n      NUM_PTS_TO_CHECK: {\n        configurable: !0\n      }\n    };\n  Pp.prototype.isDeletable = function (t, e, n, r) {\n    var i = this._inputLine[t],\n      o = this._inputLine[e],\n      s = this._inputLine[n];\n    return !!this.isConcave(i, o, s) && !!this.isShallow(i, o, s, r) && this.isShallowSampled(i, o, t, n, r);\n  }, Pp.prototype.deleteShallowConcavities = function () {\n    for (var t = this, e = 1, n = this.findNextNonDeletedIndex(e), r = this.findNextNonDeletedIndex(n), i = !1; r < this._inputLine.length;) {\n      var o = !1;\n      t.isDeletable(e, n, r, t._distanceTol) && (t._isDeleted[n] = Pp.DELETE, o = !0, i = !0), e = o ? r : n, n = t.findNextNonDeletedIndex(e), r = t.findNextNonDeletedIndex(n);\n    }\n    return i;\n  }, Pp.prototype.isShallowConcavity = function (t, e, n, r) {\n    return Xl.computeOrientation(t, e, n) === this._angleOrientation && Xl.distancePointLine(e, t, n) < r;\n  }, Pp.prototype.isShallowSampled = function (t, e, n, r, i) {\n    var o = Math.trunc((r - n) / Pp.NUM_PTS_TO_CHECK);\n    o <= 0 && (o = 1);\n    for (var s = n; s < r; s += o) if (!this.isShallow(t, e, this._inputLine[s], i)) return !1;\n    return !0;\n  }, Pp.prototype.isConcave = function (t, e, n) {\n    var r = Xl.computeOrientation(t, e, n) === this._angleOrientation;\n    return r;\n  }, Pp.prototype.simplify = function (t) {\n    this._distanceTol = Math.abs(t), t < 0 && (this._angleOrientation = Xl.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null);\n    var e = !1;\n    do {\n      e = this.deleteShallowConcavities();\n    } while (e);\n    return this.collapseLine();\n  }, Pp.prototype.findNextNonDeletedIndex = function (t) {\n    for (var e = t + 1; e < this._inputLine.length && this._isDeleted[e] === Pp.DELETE;) e++;\n    return e;\n  }, Pp.prototype.isShallow = function (t, e, n, r) {\n    return Xl.distancePointLine(e, t, n) < r;\n  }, Pp.prototype.collapseLine = function () {\n    for (var t = new hc(), e = 0; e < this._inputLine.length; e++) this._isDeleted[e] !== Pp.DELETE && t.add(this._inputLine[e]);\n    return t.toCoordinateArray();\n  }, Pp.prototype.interfaces_ = function () {\n    return [];\n  }, Pp.prototype.getClass = function () {\n    return Pp;\n  }, Pp.simplify = function (t, e) {\n    return new Pp(t).simplify(e);\n  }, Mp.INIT.get = function () {\n    return 0;\n  }, Mp.DELETE.get = function () {\n    return 1;\n  }, Mp.KEEP.get = function () {\n    return 1;\n  }, Mp.NUM_PTS_TO_CHECK.get = function () {\n    return 10;\n  }, Object.defineProperties(Pp, Mp);\n  var Lp = function Lp() {\n      this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new lc();\n    },\n    Op = {\n      COORDINATE_ARRAY_TYPE: {\n        configurable: !0\n      }\n    };\n  Lp.prototype.getCoordinates = function () {\n    return this._ptList.toArray(Lp.COORDINATE_ARRAY_TYPE);\n  }, Lp.prototype.setPrecisionModel = function (t) {\n    this._precisionModel = t;\n  }, Lp.prototype.addPt = function (t) {\n    var e = new ul(t);\n    if (this._precisionModel.makePrecise(e), this.isRedundant(e)) return null;\n    this._ptList.add(e);\n  }, Lp.prototype.revere = function () {}, Lp.prototype.addPts = function (t, e) {\n    if (e) for (var n = 0; n < t.length; n++) this.addPt(t[n]);else for (var r = t.length - 1; r >= 0; r--) this.addPt(t[r]);\n  }, Lp.prototype.isRedundant = function (t) {\n    if (this._ptList.size() < 1) return !1;\n    var e = this._ptList.get(this._ptList.size() - 1);\n    return t.distance(e) < this._minimimVertexDistance;\n  }, Lp.prototype.toString = function () {\n    return new _h().createLineString(this.getCoordinates()).toString();\n  }, Lp.prototype.closeRing = function () {\n    if (this._ptList.size() < 1) return null;\n    var t = new ul(this._ptList.get(0)),\n      e = this._ptList.get(this._ptList.size() - 1);\n    if (t.equals(e)) return null;\n    this._ptList.add(t);\n  }, Lp.prototype.setMinimumVertexDistance = function (t) {\n    this._minimimVertexDistance = t;\n  }, Lp.prototype.interfaces_ = function () {\n    return [];\n  }, Lp.prototype.getClass = function () {\n    return Lp;\n  }, Op.COORDINATE_ARRAY_TYPE.get = function () {\n    return new Array(0).fill(null);\n  }, Object.defineProperties(Lp, Op);\n  var Rp = function Rp() {},\n    Tp = {\n      PI_TIMES_2: {\n        configurable: !0\n      },\n      PI_OVER_2: {\n        configurable: !0\n      },\n      PI_OVER_4: {\n        configurable: !0\n      },\n      COUNTERCLOCKWISE: {\n        configurable: !0\n      },\n      CLOCKWISE: {\n        configurable: !0\n      },\n      NONE: {\n        configurable: !0\n      }\n    };\n  Rp.prototype.interfaces_ = function () {\n    return [];\n  }, Rp.prototype.getClass = function () {\n    return Rp;\n  }, Rp.toDegrees = function (t) {\n    return 180 * t / Math.PI;\n  }, Rp.normalize = function (t) {\n    for (; t > Math.PI;) t -= Rp.PI_TIMES_2;\n    for (; t <= -Math.PI;) t += Rp.PI_TIMES_2;\n    return t;\n  }, Rp.angle = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return Math.atan2(t.y, t.x);\n    }\n    if (2 === arguments.length) {\n      var e = arguments[0],\n        n = arguments[1],\n        r = n.x - e.x,\n        i = n.y - e.y;\n      return Math.atan2(i, r);\n    }\n  }, Rp.isAcute = function (t, e, n) {\n    var r = t.x - e.x,\n      i = t.y - e.y;\n    return r * (n.x - e.x) + i * (n.y - e.y) > 0;\n  }, Rp.isObtuse = function (t, e, n) {\n    var r = t.x - e.x,\n      i = t.y - e.y;\n    return r * (n.x - e.x) + i * (n.y - e.y) < 0;\n  }, Rp.interiorAngle = function (t, e, n) {\n    var r = Rp.angle(e, t),\n      i = Rp.angle(e, n);\n    return Math.abs(i - r);\n  }, Rp.normalizePositive = function (t) {\n    if (t < 0) {\n      for (; t < 0;) t += Rp.PI_TIMES_2;\n      t >= Rp.PI_TIMES_2 && (t = 0);\n    } else {\n      for (; t >= Rp.PI_TIMES_2;) t -= Rp.PI_TIMES_2;\n      t < 0 && (t = 0);\n    }\n    return t;\n  }, Rp.angleBetween = function (t, e, n) {\n    var r = Rp.angle(e, t),\n      i = Rp.angle(e, n);\n    return Rp.diff(r, i);\n  }, Rp.diff = function (t, e) {\n    var n = null;\n    return (n = t < e ? e - t : t - e) > Math.PI && (n = 2 * Math.PI - n), n;\n  }, Rp.toRadians = function (t) {\n    return t * Math.PI / 180;\n  }, Rp.getTurn = function (t, e) {\n    var n = Math.sin(e - t);\n    return n > 0 ? Rp.COUNTERCLOCKWISE : n < 0 ? Rp.CLOCKWISE : Rp.NONE;\n  }, Rp.angleBetweenOriented = function (t, e, n) {\n    var r = Rp.angle(e, t),\n      i = Rp.angle(e, n) - r;\n    return i <= -Math.PI ? i + Rp.PI_TIMES_2 : i > Math.PI ? i - Rp.PI_TIMES_2 : i;\n  }, Tp.PI_TIMES_2.get = function () {\n    return 2 * Math.PI;\n  }, Tp.PI_OVER_2.get = function () {\n    return Math.PI / 2;\n  }, Tp.PI_OVER_4.get = function () {\n    return Math.PI / 4;\n  }, Tp.COUNTERCLOCKWISE.get = function () {\n    return Xl.COUNTERCLOCKWISE;\n  }, Tp.CLOCKWISE.get = function () {\n    return Xl.CLOCKWISE;\n  }, Tp.NONE.get = function () {\n    return Xl.COLLINEAR;\n  }, Object.defineProperties(Rp, Tp);\n  var Ap = function t() {\n      this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new vp(), this._seg1 = new vp(), this._offset0 = new vp(), this._offset1 = new vp(), this._side = 0, this._hasNarrowConcaveAngle = !1;\n      var e = arguments[0],\n        n = arguments[1],\n        r = arguments[2];\n      this._precisionModel = e, this._bufParams = n, this._li = new jl(), this._filletAngleQuantum = Math.PI / 2 / n.getQuadrantSegments(), n.getQuadrantSegments() >= 8 && n.getJoinStyle() === Sp.JOIN_ROUND && (this._closingSegLengthFactor = t.MAX_CLOSING_SEG_LEN_FACTOR), this.init(r);\n    },\n    Dp = {\n      OFFSET_SEGMENT_SEPARATION_FACTOR: {\n        configurable: !0\n      },\n      INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR: {\n        configurable: !0\n      },\n      CURVE_VERTEX_SNAP_DISTANCE_FACTOR: {\n        configurable: !0\n      },\n      MAX_CLOSING_SEG_LEN_FACTOR: {\n        configurable: !0\n      }\n    };\n  Ap.prototype.addNextSegment = function (t, e) {\n    if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = t, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2)) return null;\n    var n = Xl.computeOrientation(this._s0, this._s1, this._s2),\n      r = n === Xl.CLOCKWISE && this._side === Sh.LEFT || n === Xl.COUNTERCLOCKWISE && this._side === Sh.RIGHT;\n    0 === n ? this.addCollinear(e) : r ? this.addOutsideTurn(n, e) : this.addInsideTurn(n, e);\n  }, Ap.prototype.addLineEndCap = function (t, e) {\n    var n = new vp(t, e),\n      r = new vp();\n    this.computeOffsetSegment(n, Sh.LEFT, this._distance, r);\n    var i = new vp();\n    this.computeOffsetSegment(n, Sh.RIGHT, this._distance, i);\n    var o = e.x - t.x,\n      s = e.y - t.y,\n      a = Math.atan2(s, o);\n    switch (this._bufParams.getEndCapStyle()) {\n      case Sp.CAP_ROUND:\n        this._segList.addPt(r.p1), this.addFilletArc(e, a + Math.PI / 2, a - Math.PI / 2, Xl.CLOCKWISE, this._distance), this._segList.addPt(i.p1);\n        break;\n      case Sp.CAP_FLAT:\n        this._segList.addPt(r.p1), this._segList.addPt(i.p1);\n        break;\n      case Sp.CAP_SQUARE:\n        var u = new ul();\n        u.x = Math.abs(this._distance) * Math.cos(a), u.y = Math.abs(this._distance) * Math.sin(a);\n        var l = new ul(r.p1.x + u.x, r.p1.y + u.y),\n          c = new ul(i.p1.x + u.x, i.p1.y + u.y);\n        this._segList.addPt(l), this._segList.addPt(c);\n    }\n  }, Ap.prototype.getCoordinates = function () {\n    return this._segList.getCoordinates();\n  }, Ap.prototype.addMitreJoin = function (t, e, n, r) {\n    var i = !0,\n      o = null;\n    try {\n      o = Ml.intersection(e.p0, e.p1, n.p0, n.p1), (r <= 0 ? 1 : o.distance(t) / Math.abs(r)) > this._bufParams.getMitreLimit() && (i = !1);\n    } catch (t) {\n      if (!(t instanceof Cl)) throw t;\n      o = new ul(0, 0), i = !1;\n    }\n    i ? this._segList.addPt(o) : this.addLimitedMitreJoin(e, n, r, this._bufParams.getMitreLimit());\n  }, Ap.prototype.addFilletCorner = function (t, e, n, r, i) {\n    var o = e.x - t.x,\n      s = e.y - t.y,\n      a = Math.atan2(s, o),\n      u = n.x - t.x,\n      l = n.y - t.y,\n      c = Math.atan2(l, u);\n    r === Xl.CLOCKWISE ? a <= c && (a += 2 * Math.PI) : a >= c && (a -= 2 * Math.PI), this._segList.addPt(e), this.addFilletArc(t, a, c, r, i), this._segList.addPt(n);\n  }, Ap.prototype.addOutsideTurn = function (t, e) {\n    if (this._offset0.p1.distance(this._offset1.p0) < this._distance * Ap.OFFSET_SEGMENT_SEPARATION_FACTOR) return this._segList.addPt(this._offset0.p1), null;\n    this._bufParams.getJoinStyle() === Sp.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === Sp.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (e && this._segList.addPt(this._offset0.p1), this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, t, this._distance), this._segList.addPt(this._offset1.p0));\n  }, Ap.prototype.createSquare = function (t) {\n    this._segList.addPt(new ul(t.x + this._distance, t.y + this._distance)), this._segList.addPt(new ul(t.x + this._distance, t.y - this._distance)), this._segList.addPt(new ul(t.x - this._distance, t.y - this._distance)), this._segList.addPt(new ul(t.x - this._distance, t.y + this._distance)), this._segList.closeRing();\n  }, Ap.prototype.addSegments = function (t, e) {\n    this._segList.addPts(t, e);\n  }, Ap.prototype.addFirstSegment = function () {\n    this._segList.addPt(this._offset1.p0);\n  }, Ap.prototype.addLastSegment = function () {\n    this._segList.addPt(this._offset1.p1);\n  }, Ap.prototype.initSideSegments = function (t, e, n) {\n    this._s1 = t, this._s2 = e, this._side = n, this._seg1.setCoordinates(t, e), this.computeOffsetSegment(this._seg1, n, this._distance, this._offset1);\n  }, Ap.prototype.addLimitedMitreJoin = function (t, e, n, r) {\n    var i = this._seg0.p1,\n      o = Rp.angle(i, this._seg0.p0),\n      s = Rp.angleBetweenOriented(this._seg0.p0, i, this._seg1.p1) / 2,\n      a = Rp.normalize(o + s),\n      u = Rp.normalize(a + Math.PI),\n      l = r * n,\n      c = n - l * Math.abs(Math.sin(s)),\n      h = i.x + l * Math.cos(u),\n      p = i.y + l * Math.sin(u),\n      f = new ul(h, p),\n      g = new vp(i, f),\n      d = g.pointAlongOffset(1, c),\n      y = g.pointAlongOffset(1, -c);\n    this._side === Sh.LEFT ? (this._segList.addPt(d), this._segList.addPt(y)) : (this._segList.addPt(y), this._segList.addPt(d));\n  }, Ap.prototype.computeOffsetSegment = function (t, e, n, r) {\n    var i = e === Sh.LEFT ? 1 : -1,\n      o = t.p1.x - t.p0.x,\n      s = t.p1.y - t.p0.y,\n      a = Math.sqrt(o * o + s * s),\n      u = i * n * o / a,\n      l = i * n * s / a;\n    r.p0.x = t.p0.x - l, r.p0.y = t.p0.y + u, r.p1.x = t.p1.x - l, r.p1.y = t.p1.y + u;\n  }, Ap.prototype.addFilletArc = function (t, e, n, r, i) {\n    var o = r === Xl.CLOCKWISE ? -1 : 1,\n      s = Math.abs(e - n),\n      a = Math.trunc(s / this._filletAngleQuantum + .5);\n    if (a < 1) return null;\n    for (var u = s / a, l = 0, c = new ul(); l < s;) {\n      var h = e + o * l;\n      c.x = t.x + i * Math.cos(h), c.y = t.y + i * Math.sin(h), this._segList.addPt(c), l += u;\n    }\n  }, Ap.prototype.addInsideTurn = function (t, e) {\n    if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection()) this._segList.addPt(this._li.getIntersection(0));else if (this._hasNarrowConcaveAngle = !0, this._offset0.p1.distance(this._offset1.p0) < this._distance * Ap.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this._segList.addPt(this._offset0.p1);else {\n      if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) {\n        var n = new ul((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));\n        this._segList.addPt(n);\n        var r = new ul((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));\n        this._segList.addPt(r);\n      } else this._segList.addPt(this._s1);\n      this._segList.addPt(this._offset1.p0);\n    }\n  }, Ap.prototype.createCircle = function (t) {\n    var e = new ul(t.x + this._distance, t.y);\n    this._segList.addPt(e), this.addFilletArc(t, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing();\n  }, Ap.prototype.addBevelJoin = function (t, e) {\n    this._segList.addPt(t.p1), this._segList.addPt(e.p0);\n  }, Ap.prototype.init = function (t) {\n    this._distance = t, this._maxCurveSegmentError = t * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new Lp(), this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(t * Ap.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);\n  }, Ap.prototype.addCollinear = function (t) {\n    this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2), this._li.getIntersectionNum() >= 2 && (this._bufParams.getJoinStyle() === Sp.JOIN_BEVEL || this._bufParams.getJoinStyle() === Sp.JOIN_MITRE ? (t && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, Xl.CLOCKWISE, this._distance));\n  }, Ap.prototype.closeRing = function () {\n    this._segList.closeRing();\n  }, Ap.prototype.hasNarrowConcaveAngle = function () {\n    return this._hasNarrowConcaveAngle;\n  }, Ap.prototype.interfaces_ = function () {\n    return [];\n  }, Ap.prototype.getClass = function () {\n    return Ap;\n  }, Dp.OFFSET_SEGMENT_SEPARATION_FACTOR.get = function () {\n    return .001;\n  }, Dp.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get = function () {\n    return .001;\n  }, Dp.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get = function () {\n    return 1e-6;\n  }, Dp.MAX_CLOSING_SEG_LEN_FACTOR.get = function () {\n    return 80;\n  }, Object.defineProperties(Ap, Dp);\n  var Fp = function Fp() {\n    this._distance = 0, this._precisionModel = null, this._bufParams = null;\n    var t = arguments[0],\n      e = arguments[1];\n    this._precisionModel = t, this._bufParams = e;\n  };\n  Fp.prototype.getOffsetCurve = function (t, e) {\n    if (this._distance = e, 0 === e) return null;\n    var n = e < 0,\n      r = Math.abs(e),\n      i = this.getSegGen(r);\n    t.length <= 1 ? this.computePointCurve(t[0], i) : this.computeOffsetCurve(t, n, i);\n    var o = i.getCoordinates();\n    return n && pc.reverse(o), o;\n  }, Fp.prototype.computeSingleSidedBufferCurve = function (t, e, n) {\n    var r = this.simplifyTolerance(this._distance);\n    if (e) {\n      n.addSegments(t, !0);\n      var i = Pp.simplify(t, -r),\n        o = i.length - 1;\n      n.initSideSegments(i[o], i[o - 1], Sh.LEFT), n.addFirstSegment();\n      for (var s = o - 2; s >= 0; s--) n.addNextSegment(i[s], !0);\n    } else {\n      n.addSegments(t, !1);\n      var a = Pp.simplify(t, r),\n        u = a.length - 1;\n      n.initSideSegments(a[0], a[1], Sh.LEFT), n.addFirstSegment();\n      for (var l = 2; l <= u; l++) n.addNextSegment(a[l], !0);\n    }\n    n.addLastSegment(), n.closeRing();\n  }, Fp.prototype.computeRingBufferCurve = function (t, e, n) {\n    var r = this.simplifyTolerance(this._distance);\n    e === Sh.RIGHT && (r = -r);\n    var i = Pp.simplify(t, r),\n      o = i.length - 1;\n    n.initSideSegments(i[o - 1], i[0], e);\n    for (var s = 1; s <= o; s++) {\n      var a = 1 !== s;\n      n.addNextSegment(i[s], a);\n    }\n    n.closeRing();\n  }, Fp.prototype.computeLineBufferCurve = function (t, e) {\n    var n = this.simplifyTolerance(this._distance),\n      r = Pp.simplify(t, n),\n      i = r.length - 1;\n    e.initSideSegments(r[0], r[1], Sh.LEFT);\n    for (var o = 2; o <= i; o++) e.addNextSegment(r[o], !0);\n    e.addLastSegment(), e.addLineEndCap(r[i - 1], r[i]);\n    var s = Pp.simplify(t, -n),\n      a = s.length - 1;\n    e.initSideSegments(s[a], s[a - 1], Sh.LEFT);\n    for (var u = a - 2; u >= 0; u--) e.addNextSegment(s[u], !0);\n    e.addLastSegment(), e.addLineEndCap(s[1], s[0]), e.closeRing();\n  }, Fp.prototype.computePointCurve = function (t, e) {\n    switch (this._bufParams.getEndCapStyle()) {\n      case Sp.CAP_ROUND:\n        e.createCircle(t);\n        break;\n      case Sp.CAP_SQUARE:\n        e.createSquare(t);\n    }\n  }, Fp.prototype.getLineCurve = function (t, e) {\n    if (this._distance = e, e < 0 && !this._bufParams.isSingleSided()) return null;\n    if (0 === e) return null;\n    var n = Math.abs(e),\n      r = this.getSegGen(n);\n    if (t.length <= 1) this.computePointCurve(t[0], r);else if (this._bufParams.isSingleSided()) {\n      var i = e < 0;\n      this.computeSingleSidedBufferCurve(t, i, r);\n    } else this.computeLineBufferCurve(t, r);\n    return r.getCoordinates();\n  }, Fp.prototype.getBufferParameters = function () {\n    return this._bufParams;\n  }, Fp.prototype.simplifyTolerance = function (t) {\n    return t * this._bufParams.getSimplifyFactor();\n  }, Fp.prototype.getRingCurve = function (t, e, n) {\n    if (this._distance = n, t.length <= 2) return this.getLineCurve(t, n);\n    if (0 === n) return Fp.copyCoordinates(t);\n    var r = this.getSegGen(n);\n    return this.computeRingBufferCurve(t, e, r), r.getCoordinates();\n  }, Fp.prototype.computeOffsetCurve = function (t, e, n) {\n    var r = this.simplifyTolerance(this._distance);\n    if (e) {\n      var i = Pp.simplify(t, -r),\n        o = i.length - 1;\n      n.initSideSegments(i[o], i[o - 1], Sh.LEFT), n.addFirstSegment();\n      for (var s = o - 2; s >= 0; s--) n.addNextSegment(i[s], !0);\n    } else {\n      var a = Pp.simplify(t, r),\n        u = a.length - 1;\n      n.initSideSegments(a[0], a[1], Sh.LEFT), n.addFirstSegment();\n      for (var l = 2; l <= u; l++) n.addNextSegment(a[l], !0);\n    }\n    n.addLastSegment();\n  }, Fp.prototype.getSegGen = function (t) {\n    return new Ap(this._precisionModel, this._bufParams, t);\n  }, Fp.prototype.interfaces_ = function () {\n    return [];\n  }, Fp.prototype.getClass = function () {\n    return Fp;\n  }, Fp.copyCoordinates = function (t) {\n    for (var e = new Array(t.length).fill(null), n = 0; n < e.length; n++) e[n] = new ul(t[n]);\n    return e;\n  };\n  var kp = function kp() {\n      this._subgraphs = null, this._seg = new vp(), this._cga = new Xl();\n      var t = arguments[0];\n      this._subgraphs = t;\n    },\n    Gp = {\n      DepthSegment: {\n        configurable: !0\n      }\n    };\n  kp.prototype.findStabbedSegments = function () {\n    var t = this;\n    if (1 === arguments.length) {\n      for (var e = arguments[0], n = new lc(), r = this._subgraphs.iterator(); r.hasNext();) {\n        var i = r.next(),\n          o = i.getEnvelope();\n        e.y < o.getMinY() || e.y > o.getMaxY() || t.findStabbedSegments(e, i.getDirectedEdges(), n);\n      }\n      return n;\n    }\n    if (3 === arguments.length) if (gl(arguments[2], ac) && arguments[0] instanceof ul && arguments[1] instanceof Xh) for (var s = arguments[0], a = arguments[1], u = arguments[2], l = a.getEdge().getCoordinates(), c = 0; c < l.length - 1; c++) {\n      t._seg.p0 = l[c], t._seg.p1 = l[c + 1], t._seg.p0.y > t._seg.p1.y && t._seg.reverse();\n      var h = Math.max(t._seg.p0.x, t._seg.p1.x);\n      if (!(h < s.x) && !(t._seg.isHorizontal() || s.y < t._seg.p0.y || s.y > t._seg.p1.y || Xl.computeOrientation(t._seg.p0, t._seg.p1, s) === Xl.RIGHT)) {\n        var p = a.getDepth(Sh.LEFT);\n        t._seg.p0.equals(l[c]) || (p = a.getDepth(Sh.RIGHT));\n        var f = new qp(t._seg, p);\n        u.add(f);\n      }\n    } else if (gl(arguments[2], ac) && arguments[0] instanceof ul && gl(arguments[1], ac)) for (var g = arguments[0], d = arguments[1], y = arguments[2], v = d.iterator(); v.hasNext();) {\n      var _ = v.next();\n      _.isForward() && t.findStabbedSegments(g, _, y);\n    }\n  }, kp.prototype.getDepth = function (t) {\n    var e = this.findStabbedSegments(t);\n    return 0 === e.size() ? 0 : np.min(e)._leftDepth;\n  }, kp.prototype.interfaces_ = function () {\n    return [];\n  }, kp.prototype.getClass = function () {\n    return kp;\n  }, Gp.DepthSegment.get = function () {\n    return qp;\n  }, Object.defineProperties(kp, Gp);\n  var qp = function qp() {\n    this._upwardSeg = null, this._leftDepth = null;\n    var t = arguments[0],\n      e = arguments[1];\n    this._upwardSeg = new vp(t), this._leftDepth = e;\n  };\n  qp.prototype.compareTo = function (t) {\n    var e = t;\n    if (this._upwardSeg.minX() >= e._upwardSeg.maxX()) return 1;\n    if (this._upwardSeg.maxX() <= e._upwardSeg.minX()) return -1;\n    var n = this._upwardSeg.orientationIndex(e._upwardSeg);\n    return 0 !== n || 0 !== (n = -1 * e._upwardSeg.orientationIndex(this._upwardSeg)) ? n : this._upwardSeg.compareTo(e._upwardSeg);\n  }, qp.prototype.compareX = function (t, e) {\n    var n = t.p0.compareTo(e.p0);\n    return 0 !== n ? n : t.p1.compareTo(e.p1);\n  }, qp.prototype.toString = function () {\n    return this._upwardSeg.toString();\n  }, qp.prototype.interfaces_ = function () {\n    return [il];\n  }, qp.prototype.getClass = function () {\n    return qp;\n  };\n  var Bp = function Bp(t, e, n) {\n    this.p0 = t || null, this.p1 = e || null, this.p2 = n || null;\n  };\n  Bp.prototype.area = function () {\n    return Bp.area(this.p0, this.p1, this.p2);\n  }, Bp.prototype.signedArea = function () {\n    return Bp.signedArea(this.p0, this.p1, this.p2);\n  }, Bp.prototype.interpolateZ = function (t) {\n    if (null === t) throw new el(\"Supplied point is null.\");\n    return Bp.interpolateZ(t, this.p0, this.p1, this.p2);\n  }, Bp.prototype.longestSideLength = function () {\n    return Bp.longestSideLength(this.p0, this.p1, this.p2);\n  }, Bp.prototype.isAcute = function () {\n    return Bp.isAcute(this.p0, this.p1, this.p2);\n  }, Bp.prototype.circumcentre = function () {\n    return Bp.circumcentre(this.p0, this.p1, this.p2);\n  }, Bp.prototype.area3D = function () {\n    return Bp.area3D(this.p0, this.p1, this.p2);\n  }, Bp.prototype.centroid = function () {\n    return Bp.centroid(this.p0, this.p1, this.p2);\n  }, Bp.prototype.inCentre = function () {\n    return Bp.inCentre(this.p0, this.p1, this.p2);\n  }, Bp.prototype.interfaces_ = function () {\n    return [];\n  }, Bp.prototype.getClass = function () {\n    return Bp;\n  }, Bp.area = function (t, e, n) {\n    return Math.abs(((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2);\n  }, Bp.signedArea = function (t, e, n) {\n    return ((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2;\n  }, Bp.det = function (t, e, n, r) {\n    return t * r - e * n;\n  }, Bp.interpolateZ = function (t, e, n, r) {\n    var i = e.x,\n      o = e.y,\n      s = n.x - i,\n      a = r.x - i,\n      u = n.y - o,\n      l = r.y - o,\n      c = s * l - a * u,\n      h = t.x - i,\n      p = t.y - o,\n      f = (l * h - a * p) / c,\n      g = (-u * h + s * p) / c;\n    return e.z + f * (n.z - e.z) + g * (r.z - e.z);\n  }, Bp.longestSideLength = function (t, e, n) {\n    var r = t.distance(e),\n      i = e.distance(n),\n      o = n.distance(t),\n      s = r;\n    return i > s && (s = i), o > s && (s = o), s;\n  }, Bp.isAcute = function (t, e, n) {\n    return !!Rp.isAcute(t, e, n) && !!Rp.isAcute(e, n, t) && !!Rp.isAcute(n, t, e);\n  }, Bp.circumcentre = function (t, e, n) {\n    var r = n.x,\n      i = n.y,\n      o = t.x - r,\n      s = t.y - i,\n      a = e.x - r,\n      u = e.y - i,\n      l = 2 * Bp.det(o, s, a, u),\n      c = Bp.det(s, o * o + s * s, u, a * a + u * u),\n      h = Bp.det(o, o * o + s * s, a, a * a + u * u);\n    return new ul(r - c / l, i + h / l);\n  }, Bp.perpendicularBisector = function (t, e) {\n    var n = e.x - t.x,\n      r = e.y - t.y,\n      i = new Ml(t.x + n / 2, t.y + r / 2, 1),\n      o = new Ml(t.x - r + n / 2, t.y + n + r / 2, 1);\n    return new Ml(i, o);\n  }, Bp.angleBisector = function (t, e, n) {\n    var r = e.distance(t),\n      i = r / (r + e.distance(n)),\n      o = n.x - t.x,\n      s = n.y - t.y;\n    return new ul(t.x + i * o, t.y + i * s);\n  }, Bp.area3D = function (t, e, n) {\n    var r = e.x - t.x,\n      i = e.y - t.y,\n      o = e.z - t.z,\n      s = n.x - t.x,\n      a = n.y - t.y,\n      u = n.z - t.z,\n      l = i * u - o * a,\n      c = o * s - r * u,\n      h = r * a - i * s,\n      p = l * l + c * c + h * h,\n      f = Math.sqrt(p) / 2;\n    return f;\n  }, Bp.centroid = function (t, e, n) {\n    var r = (t.x + e.x + n.x) / 3,\n      i = (t.y + e.y + n.y) / 3;\n    return new ul(r, i);\n  }, Bp.inCentre = function (t, e, n) {\n    var r = e.distance(n),\n      i = t.distance(n),\n      o = t.distance(e),\n      s = r + i + o,\n      a = (r * t.x + i * e.x + o * n.x) / s,\n      u = (r * t.y + i * e.y + o * n.y) / s;\n    return new ul(a, u);\n  };\n  var zp = function zp() {\n    this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new lc();\n    var t = arguments[0],\n      e = arguments[1],\n      n = arguments[2];\n    this._inputGeom = t, this._distance = e, this._curveBuilder = n;\n  };\n  zp.prototype.addPoint = function (t) {\n    if (this._distance <= 0) return null;\n    var e = t.getCoordinates(),\n      n = this._curveBuilder.getLineCurve(e, this._distance);\n    this.addCurve(n, pl.EXTERIOR, pl.INTERIOR);\n  }, zp.prototype.addPolygon = function (t) {\n    var e = this,\n      n = this._distance,\n      r = Sh.LEFT;\n    this._distance < 0 && (n = -this._distance, r = Sh.RIGHT);\n    var i = t.getExteriorRing(),\n      o = pc.removeRepeatedPoints(i.getCoordinates());\n    if (this._distance < 0 && this.isErodedCompletely(i, this._distance)) return null;\n    if (this._distance <= 0 && o.length < 3) return null;\n    this.addPolygonRing(o, n, r, pl.EXTERIOR, pl.INTERIOR);\n    for (var s = 0; s < t.getNumInteriorRing(); s++) {\n      var a = t.getInteriorRingN(s),\n        u = pc.removeRepeatedPoints(a.getCoordinates());\n      e._distance > 0 && e.isErodedCompletely(a, -e._distance) || e.addPolygonRing(u, n, Sh.opposite(r), pl.INTERIOR, pl.EXTERIOR);\n    }\n  }, zp.prototype.isTriangleErodedCompletely = function (t, e) {\n    var n = new Bp(t[0], t[1], t[2]),\n      r = n.inCentre();\n    return Xl.distancePointLine(r, n.p0, n.p1) < Math.abs(e);\n  }, zp.prototype.addLineString = function (t) {\n    if (this._distance <= 0 && !this._curveBuilder.getBufferParameters().isSingleSided()) return null;\n    var e = pc.removeRepeatedPoints(t.getCoordinates()),\n      n = this._curveBuilder.getLineCurve(e, this._distance);\n    this.addCurve(n, pl.EXTERIOR, pl.INTERIOR);\n  }, zp.prototype.addCurve = function (t, e, n) {\n    if (null === t || t.length < 2) return null;\n    var r = new yp(t, new Dh(0, pl.BOUNDARY, e, n));\n    this._curveList.add(r);\n  }, zp.prototype.getCurves = function () {\n    return this.add(this._inputGeom), this._curveList;\n  }, zp.prototype.addPolygonRing = function (t, e, n, r, i) {\n    if (0 === e && t.length < nh.MINIMUM_VALID_SIZE) return null;\n    var o = r,\n      s = i;\n    t.length >= nh.MINIMUM_VALID_SIZE && Xl.isCCW(t) && (o = i, s = r, n = Sh.opposite(n));\n    var a = this._curveBuilder.getRingCurve(t, n, e);\n    this.addCurve(a, o, s);\n  }, zp.prototype.add = function (t) {\n    if (t.isEmpty()) return null;\n    t instanceof th ? this.addPolygon(t) : t instanceof Zc ? this.addLineString(t) : t instanceof Qc ? this.addPoint(t) : (t instanceof eh || t instanceof Gc || t instanceof rh || t instanceof kc) && this.addCollection(t);\n  }, zp.prototype.isErodedCompletely = function (t, e) {\n    var n = t.getCoordinates();\n    if (n.length < 4) return e < 0;\n    if (4 === n.length) return this.isTriangleErodedCompletely(n, e);\n    var r = t.getEnvelopeInternal(),\n      i = Math.min(r.getHeight(), r.getWidth());\n    return e < 0 && 2 * Math.abs(e) > i;\n  }, zp.prototype.addCollection = function (t) {\n    for (var e = 0; e < t.getNumGeometries(); e++) {\n      var n = t.getGeometryN(e);\n      this.add(n);\n    }\n  }, zp.prototype.interfaces_ = function () {\n    return [];\n  }, zp.prototype.getClass = function () {\n    return zp;\n  };\n  var jp = function jp() {};\n  jp.prototype.locate = function (t) {}, jp.prototype.interfaces_ = function () {\n    return [];\n  }, jp.prototype.getClass = function () {\n    return jp;\n  };\n  var Up = function Up() {\n    this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null;\n    var t = arguments[0];\n    this._parent = t, this._atStart = !0, this._index = 0, this._max = t.getNumGeometries();\n  };\n  Up.prototype.next = function () {\n    if (this._atStart) return this._atStart = !1, Up.isAtomic(this._parent) && this._index++, this._parent;\n    if (null !== this._subcollectionIterator) {\n      if (this._subcollectionIterator.hasNext()) return this._subcollectionIterator.next();\n      this._subcollectionIterator = null;\n    }\n    if (this._index >= this._max) throw new uc();\n    var t = this._parent.getGeometryN(this._index++);\n    return t instanceof kc ? (this._subcollectionIterator = new Up(t), this._subcollectionIterator.next()) : t;\n  }, Up.prototype.remove = function () {\n    throw new Error(this.getClass().getName());\n  }, Up.prototype.hasNext = function () {\n    if (this._atStart) return !0;\n    if (null !== this._subcollectionIterator) {\n      if (this._subcollectionIterator.hasNext()) return !0;\n      this._subcollectionIterator = null;\n    }\n    return !(this._index >= this._max);\n  }, Up.prototype.interfaces_ = function () {\n    return [sc];\n  }, Up.prototype.getClass = function () {\n    return Up;\n  }, Up.isAtomic = function (t) {\n    return !(t instanceof kc);\n  };\n  var Vp = function Vp() {\n    this._geom = null;\n    var t = arguments[0];\n    this._geom = t;\n  };\n  Vp.prototype.locate = function (t) {\n    return Vp.locate(t, this._geom);\n  }, Vp.prototype.interfaces_ = function () {\n    return [jp];\n  }, Vp.prototype.getClass = function () {\n    return Vp;\n  }, Vp.isPointInRing = function (t, e) {\n    return !!e.getEnvelopeInternal().intersects(t) && Xl.isPointInRing(t, e.getCoordinates());\n  }, Vp.containsPointInPolygon = function (t, e) {\n    if (e.isEmpty()) return !1;\n    var n = e.getExteriorRing();\n    if (!Vp.isPointInRing(t, n)) return !1;\n    for (var r = 0; r < e.getNumInteriorRing(); r++) {\n      var i = e.getInteriorRingN(r);\n      if (Vp.isPointInRing(t, i)) return !1;\n    }\n    return !0;\n  }, Vp.containsPoint = function (t, e) {\n    if (e instanceof th) return Vp.containsPointInPolygon(t, e);\n    if (e instanceof kc) for (var n = new Up(e); n.hasNext();) {\n      var r = n.next();\n      if (r !== e && Vp.containsPoint(t, r)) return !0;\n    }\n    return !1;\n  }, Vp.locate = function (t, e) {\n    return e.isEmpty() ? pl.EXTERIOR : Vp.containsPoint(t, e) ? pl.INTERIOR : pl.EXTERIOR;\n  };\n  var Xp = function Xp() {\n    this._edgeMap = new Cc(), this._edgeList = null, this._ptInAreaLocation = [pl.NONE, pl.NONE];\n  };\n  Xp.prototype.getNextCW = function (t) {\n    this.getEdges();\n    var e = this._edgeList.indexOf(t),\n      n = e - 1;\n    return 0 === e && (n = this._edgeList.size() - 1), this._edgeList.get(n);\n  }, Xp.prototype.propagateSideLabels = function (t) {\n    for (var e = pl.NONE, n = this.iterator(); n.hasNext();) {\n      var r = n.next().getLabel();\n      r.isArea(t) && r.getLocation(t, Sh.LEFT) !== pl.NONE && (e = r.getLocation(t, Sh.LEFT));\n    }\n    if (e === pl.NONE) return null;\n    for (var i = e, o = this.iterator(); o.hasNext();) {\n      var s = o.next(),\n        a = s.getLabel();\n      if (a.getLocation(t, Sh.ON) === pl.NONE && a.setLocation(t, Sh.ON, i), a.isArea(t)) {\n        var u = a.getLocation(t, Sh.LEFT),\n          l = a.getLocation(t, Sh.RIGHT);\n        if (l !== pl.NONE) {\n          if (l !== i) throw new Oh(\"side location conflict\", s.getCoordinate());\n          u === pl.NONE && ql.shouldNeverReachHere(\"found single null side (at \" + s.getCoordinate() + \")\"), i = u;\n        } else ql.isTrue(a.getLocation(t, Sh.LEFT) === pl.NONE, \"found single null side\"), a.setLocation(t, Sh.RIGHT, i), a.setLocation(t, Sh.LEFT, i);\n      }\n    }\n  }, Xp.prototype.getCoordinate = function () {\n    var t = this.iterator();\n    return t.hasNext() ? t.next().getCoordinate() : null;\n  }, Xp.prototype.print = function (t) {\n    Pl.out.println(\"EdgeEndStar:   \" + this.getCoordinate());\n    for (var e = this.iterator(); e.hasNext();) {\n      e.next().print(t);\n    }\n  }, Xp.prototype.isAreaLabelsConsistent = function (t) {\n    return this.computeEdgeEndLabels(t.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0);\n  }, Xp.prototype.checkAreaLabelsConsistent = function (t) {\n    var e = this.getEdges();\n    if (e.size() <= 0) return !0;\n    var n = e.size() - 1,\n      r = e.get(n).getLabel().getLocation(t, Sh.LEFT);\n    ql.isTrue(r !== pl.NONE, \"Found unlabelled area edge\");\n    for (var i = r, o = this.iterator(); o.hasNext();) {\n      var s = o.next().getLabel();\n      ql.isTrue(s.isArea(t), \"Found non-area edge\");\n      var a = s.getLocation(t, Sh.LEFT),\n        u = s.getLocation(t, Sh.RIGHT);\n      if (a === u) return !1;\n      if (u !== i) return !1;\n      i = a;\n    }\n    return !0;\n  }, Xp.prototype.findIndex = function (t) {\n    this.iterator();\n    for (var e = 0; e < this._edgeList.size(); e++) {\n      if (this._edgeList.get(e) === t) return e;\n    }\n    return -1;\n  }, Xp.prototype.iterator = function () {\n    return this.getEdges().iterator();\n  }, Xp.prototype.getEdges = function () {\n    return null === this._edgeList && (this._edgeList = new lc(this._edgeMap.values())), this._edgeList;\n  }, Xp.prototype.getLocation = function (t, e, n) {\n    return this._ptInAreaLocation[t] === pl.NONE && (this._ptInAreaLocation[t] = Vp.locate(e, n[t].getGeometry())), this._ptInAreaLocation[t];\n  }, Xp.prototype.toString = function () {\n    var t = new vl();\n    t.append(\"EdgeEndStar:   \" + this.getCoordinate()), t.append(\"\\n\");\n    for (var e = this.iterator(); e.hasNext();) {\n      var n = e.next();\n      t.append(n), t.append(\"\\n\");\n    }\n    return t.toString();\n  }, Xp.prototype.computeEdgeEndLabels = function (t) {\n    for (var e = this.iterator(); e.hasNext();) {\n      e.next().computeLabel(t);\n    }\n  }, Xp.prototype.computeLabelling = function (t) {\n    this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);\n    for (var e = [!1, !1], n = this.iterator(); n.hasNext();) for (var r = n.next().getLabel(), i = 0; i < 2; i++) r.isLine(i) && r.getLocation(i) === pl.BOUNDARY && (e[i] = !0);\n    for (var o = this.iterator(); o.hasNext();) for (var s = o.next(), a = s.getLabel(), u = 0; u < 2; u++) if (a.isAnyNull(u)) {\n      var l = pl.NONE;\n      if (e[u]) l = pl.EXTERIOR;else {\n        var c = s.getCoordinate();\n        l = this.getLocation(u, c, t);\n      }\n      a.setAllLocationsIfNull(u, l);\n    }\n  }, Xp.prototype.getDegree = function () {\n    return this._edgeMap.size();\n  }, Xp.prototype.insertEdgeEnd = function (t, e) {\n    this._edgeMap.put(t, e), this._edgeList = null;\n  }, Xp.prototype.interfaces_ = function () {\n    return [];\n  }, Xp.prototype.getClass = function () {\n    return Xp;\n  };\n  var Yp = function (t) {\n      function e() {\n        t.call(this), this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2;\n      }\n      return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.linkResultDirectedEdges = function () {\n        var t = this;\n        this.getResultAreaEdges();\n        for (var e = null, n = null, r = this._SCANNING_FOR_INCOMING, i = 0; i < this._resultAreaEdgeList.size(); i++) {\n          var o = t._resultAreaEdgeList.get(i),\n            s = o.getSym();\n          if (o.getLabel().isArea()) switch (null === e && o.isInResult() && (e = o), r) {\n            case t._SCANNING_FOR_INCOMING:\n              if (!s.isInResult()) continue;\n              n = s, r = t._LINKING_TO_OUTGOING;\n              break;\n            case t._LINKING_TO_OUTGOING:\n              if (!o.isInResult()) continue;\n              n.setNext(o), r = t._SCANNING_FOR_INCOMING;\n          }\n        }\n        if (r === this._LINKING_TO_OUTGOING) {\n          if (null === e) throw new Oh(\"no outgoing dirEdge found\", this.getCoordinate());\n          ql.isTrue(e.isInResult(), \"unable to link last incoming dirEdge\"), n.setNext(e);\n        }\n      }, e.prototype.insert = function (t) {\n        var e = t;\n        this.insertEdgeEnd(e, e);\n      }, e.prototype.getRightmostEdge = function () {\n        var t = this.getEdges(),\n          e = t.size();\n        if (e < 1) return null;\n        var n = t.get(0);\n        if (1 === e) return n;\n        var r = t.get(e - 1),\n          i = n.getQuadrant(),\n          o = r.getQuadrant();\n        return jh.isNorthern(i) && jh.isNorthern(o) ? n : jh.isNorthern(i) || jh.isNorthern(o) ? 0 !== n.getDy() ? n : 0 !== r.getDy() ? r : (ql.shouldNeverReachHere(\"found two horizontal edges incident on node\"), null) : r;\n      }, e.prototype.print = function (t) {\n        Pl.out.println(\"DirectedEdgeStar: \" + this.getCoordinate());\n        for (var e = this.iterator(); e.hasNext();) {\n          var n = e.next();\n          t.print(\"out \"), n.print(t), t.println(), t.print(\"in \"), n.getSym().print(t), t.println();\n        }\n      }, e.prototype.getResultAreaEdges = function () {\n        if (null !== this._resultAreaEdgeList) return this._resultAreaEdgeList;\n        this._resultAreaEdgeList = new lc();\n        for (var t = this.iterator(); t.hasNext();) {\n          var e = t.next();\n          (e.isInResult() || e.getSym().isInResult()) && this._resultAreaEdgeList.add(e);\n        }\n        return this._resultAreaEdgeList;\n      }, e.prototype.updateLabelling = function (t) {\n        for (var e = this.iterator(); e.hasNext();) {\n          var n = e.next().getLabel();\n          n.setAllLocationsIfNull(0, t.getLocation(0)), n.setAllLocationsIfNull(1, t.getLocation(1));\n        }\n      }, e.prototype.linkAllDirectedEdges = function () {\n        this.getEdges();\n        for (var t = null, e = null, n = this._edgeList.size() - 1; n >= 0; n--) {\n          var r = this._edgeList.get(n),\n            i = r.getSym();\n          null === e && (e = i), null !== t && i.setNext(t), t = r;\n        }\n        e.setNext(t);\n      }, e.prototype.computeDepths = function () {\n        var t = this;\n        if (1 === arguments.length) {\n          var e = arguments[0],\n            n = this.findIndex(e),\n            r = e.getDepth(Sh.LEFT),\n            i = e.getDepth(Sh.RIGHT),\n            o = this.computeDepths(n + 1, this._edgeList.size(), r),\n            s = this.computeDepths(0, n, o);\n          if (s !== i) throw new Oh(\"depth mismatch at \" + e.getCoordinate());\n        } else if (3 === arguments.length) {\n          for (var a = arguments[0], u = arguments[1], l = arguments[2], c = l, h = a; h < u; h++) {\n            var p = t._edgeList.get(h);\n            p.setEdgeDepths(Sh.RIGHT, c), c = p.getDepth(Sh.LEFT);\n          }\n          return c;\n        }\n      }, e.prototype.mergeSymLabels = function () {\n        for (var t = this.iterator(); t.hasNext();) {\n          var e = t.next();\n          e.getLabel().merge(e.getSym().getLabel());\n        }\n      }, e.prototype.linkMinimalDirectedEdges = function (t) {\n        for (var e = this, n = null, r = null, i = this._SCANNING_FOR_INCOMING, o = this._resultAreaEdgeList.size() - 1; o >= 0; o--) {\n          var s = e._resultAreaEdgeList.get(o),\n            a = s.getSym();\n          switch (null === n && s.getEdgeRing() === t && (n = s), i) {\n            case e._SCANNING_FOR_INCOMING:\n              if (a.getEdgeRing() !== t) continue;\n              r = a, i = e._LINKING_TO_OUTGOING;\n              break;\n            case e._LINKING_TO_OUTGOING:\n              if (s.getEdgeRing() !== t) continue;\n              r.setNextMin(s), i = e._SCANNING_FOR_INCOMING;\n          }\n        }\n        i === this._LINKING_TO_OUTGOING && (ql.isTrue(null !== n, \"found null for first outgoing dirEdge\"), ql.isTrue(n.getEdgeRing() === t, \"unable to link last incoming dirEdge\"), r.setNextMin(n));\n      }, e.prototype.getOutgoingDegree = function () {\n        if (0 === arguments.length) {\n          for (var t = 0, e = this.iterator(); e.hasNext();) {\n            var n = e.next();\n            n.isInResult() && t++;\n          }\n          return t;\n        }\n        if (1 === arguments.length) {\n          for (var r = arguments[0], i = 0, o = this.iterator(); o.hasNext();) {\n            var s = o.next();\n            s.getEdgeRing() === r && i++;\n          }\n          return i;\n        }\n      }, e.prototype.getLabel = function () {\n        return this._label;\n      }, e.prototype.findCoveredLineEdges = function () {\n        for (var t = pl.NONE, e = this.iterator(); e.hasNext();) {\n          var n = e.next(),\n            r = n.getSym();\n          if (!n.isLineEdge()) {\n            if (n.isInResult()) {\n              t = pl.INTERIOR;\n              break;\n            }\n            if (r.isInResult()) {\n              t = pl.EXTERIOR;\n              break;\n            }\n          }\n        }\n        if (t === pl.NONE) return null;\n        for (var i = t, o = this.iterator(); o.hasNext();) {\n          var s = o.next(),\n            a = s.getSym();\n          s.isLineEdge() ? s.getEdge().setCovered(i === pl.INTERIOR) : (s.isInResult() && (i = pl.EXTERIOR), a.isInResult() && (i = pl.INTERIOR));\n        }\n      }, e.prototype.computeLabelling = function (e) {\n        t.prototype.computeLabelling.call(this, e), this._label = new Dh(pl.NONE);\n        for (var n = this.iterator(); n.hasNext();) for (var r = n.next().getEdge().getLabel(), i = 0; i < 2; i++) {\n          var o = r.getLocation(i);\n          o !== pl.INTERIOR && o !== pl.BOUNDARY || this._label.setLocation(i, pl.INTERIOR);\n        }\n      }, e.prototype.interfaces_ = function () {\n        return [];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, e;\n    }(Xp),\n    Hp = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.createNode = function (t) {\n        return new Bh(t, new Yp());\n      }, e.prototype.interfaces_ = function () {\n        return [];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, e;\n    }(Yh),\n    Wp = function t() {\n      this._pts = null, this._orientation = null;\n      var e = arguments[0];\n      this._pts = e, this._orientation = t.orientation(e);\n    };\n  Wp.prototype.compareTo = function (t) {\n    var e = t;\n    return Wp.compareOriented(this._pts, this._orientation, e._pts, e._orientation);\n  }, Wp.prototype.interfaces_ = function () {\n    return [il];\n  }, Wp.prototype.getClass = function () {\n    return Wp;\n  }, Wp.orientation = function (t) {\n    return 1 === pc.increasingDirection(t);\n  }, Wp.compareOriented = function (t, e, n, r) {\n    for (var i = e ? 1 : -1, o = r ? 1 : -1, s = e ? t.length : -1, a = r ? n.length : -1, u = e ? 0 : t.length - 1, l = r ? 0 : n.length - 1;;) {\n      var c = t[u].compareTo(n[l]);\n      if (0 !== c) return c;\n      var h = (u += i) === s,\n        p = (l += o) === a;\n      if (h && !p) return -1;\n      if (!h && p) return 1;\n      if (h && p) return 0;\n    }\n  };\n  var Jp = function Jp() {\n    this._edges = new lc(), this._ocaMap = new Cc();\n  };\n  Jp.prototype.print = function (t) {\n    t.print(\"MULTILINESTRING ( \");\n    for (var e = 0; e < this._edges.size(); e++) {\n      var n = this._edges.get(e);\n      e > 0 && t.print(\",\"), t.print(\"(\");\n      for (var r = n.getCoordinates(), i = 0; i < r.length; i++) i > 0 && t.print(\",\"), t.print(r[i].x + \" \" + r[i].y);\n      t.println(\")\");\n    }\n    t.print(\")  \");\n  }, Jp.prototype.addAll = function (t) {\n    for (var e = t.iterator(); e.hasNext();) this.add(e.next());\n  }, Jp.prototype.findEdgeIndex = function (t) {\n    for (var e = 0; e < this._edges.size(); e++) if (this._edges.get(e).equals(t)) return e;\n    return -1;\n  }, Jp.prototype.iterator = function () {\n    return this._edges.iterator();\n  }, Jp.prototype.getEdges = function () {\n    return this._edges;\n  }, Jp.prototype.get = function (t) {\n    return this._edges.get(t);\n  }, Jp.prototype.findEqualEdge = function (t) {\n    var e = new Wp(t.getCoordinates());\n    return this._ocaMap.get(e);\n  }, Jp.prototype.add = function (t) {\n    this._edges.add(t);\n    var e = new Wp(t.getCoordinates());\n    this._ocaMap.put(e, t);\n  }, Jp.prototype.interfaces_ = function () {\n    return [];\n  }, Jp.prototype.getClass = function () {\n    return Jp;\n  };\n  var Zp = function Zp() {};\n  Zp.prototype.processIntersections = function (t, e, n, r) {}, Zp.prototype.isDone = function () {}, Zp.prototype.interfaces_ = function () {\n    return [];\n  }, Zp.prototype.getClass = function () {\n    return Zp;\n  };\n  var Kp = function Kp() {\n    this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._hasInterior = !1, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;\n    var t = arguments[0];\n    this._li = t;\n  };\n  Kp.prototype.isTrivialIntersection = function (t, e, n, r) {\n    if (t === n && 1 === this._li.getIntersectionNum()) {\n      if (Kp.isAdjacentSegments(e, r)) return !0;\n      if (t.isClosed()) {\n        var i = t.size() - 1;\n        if (0 === e && r === i || 0 === r && e === i) return !0;\n      }\n    }\n    return !1;\n  }, Kp.prototype.getProperIntersectionPoint = function () {\n    return this._properIntersectionPoint;\n  }, Kp.prototype.hasProperInteriorIntersection = function () {\n    return this._hasProperInterior;\n  }, Kp.prototype.getLineIntersector = function () {\n    return this._li;\n  }, Kp.prototype.hasProperIntersection = function () {\n    return this._hasProper;\n  }, Kp.prototype.processIntersections = function (t, e, n, r) {\n    if (t === n && e === r) return null;\n    this.numTests++;\n    var i = t.getCoordinates()[e],\n      o = t.getCoordinates()[e + 1],\n      s = n.getCoordinates()[r],\n      a = n.getCoordinates()[r + 1];\n    this._li.computeIntersection(i, o, s, a), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = !0), this.isTrivialIntersection(t, e, n, r) || (this._hasIntersection = !0, t.addIntersections(this._li, e, 0), n.addIntersections(this._li, r, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = !0, this._hasProperInterior = !0)));\n  }, Kp.prototype.hasIntersection = function () {\n    return this._hasIntersection;\n  }, Kp.prototype.isDone = function () {\n    return !1;\n  }, Kp.prototype.hasInteriorIntersection = function () {\n    return this._hasInterior;\n  }, Kp.prototype.interfaces_ = function () {\n    return [Zp];\n  }, Kp.prototype.getClass = function () {\n    return Kp;\n  }, Kp.isAdjacentSegments = function (t, e) {\n    return 1 === Math.abs(t - e);\n  };\n  var Qp = function Qp() {\n    this.coord = null, this.segmentIndex = null, this.dist = null;\n    var t = arguments[0],\n      e = arguments[1],\n      n = arguments[2];\n    this.coord = new ul(t), this.segmentIndex = e, this.dist = n;\n  };\n  Qp.prototype.getSegmentIndex = function () {\n    return this.segmentIndex;\n  }, Qp.prototype.getCoordinate = function () {\n    return this.coord;\n  }, Qp.prototype.print = function (t) {\n    t.print(this.coord), t.print(\" seg # = \" + this.segmentIndex), t.println(\" dist = \" + this.dist);\n  }, Qp.prototype.compareTo = function (t) {\n    var e = t;\n    return this.compare(e.segmentIndex, e.dist);\n  }, Qp.prototype.isEndPoint = function (t) {\n    return 0 === this.segmentIndex && 0 === this.dist || this.segmentIndex === t;\n  }, Qp.prototype.toString = function () {\n    return this.coord + \" seg # = \" + this.segmentIndex + \" dist = \" + this.dist;\n  }, Qp.prototype.getDistance = function () {\n    return this.dist;\n  }, Qp.prototype.compare = function (t, e) {\n    return this.segmentIndex < t ? -1 : this.segmentIndex > t ? 1 : this.dist < e ? -1 : this.dist > e ? 1 : 0;\n  }, Qp.prototype.interfaces_ = function () {\n    return [il];\n  }, Qp.prototype.getClass = function () {\n    return Qp;\n  };\n  var $p = function $p() {\n    this._nodeMap = new Cc(), this.edge = null;\n    var t = arguments[0];\n    this.edge = t;\n  };\n  $p.prototype.print = function (t) {\n    t.println(\"Intersections:\");\n    for (var e = this.iterator(); e.hasNext();) {\n      e.next().print(t);\n    }\n  }, $p.prototype.iterator = function () {\n    return this._nodeMap.values().iterator();\n  }, $p.prototype.addSplitEdges = function (t) {\n    this.addEndpoints();\n    for (var e = this.iterator(), n = e.next(); e.hasNext();) {\n      var r = e.next(),\n        i = this.createSplitEdge(n, r);\n      t.add(i), n = r;\n    }\n  }, $p.prototype.addEndpoints = function () {\n    var t = this.edge.pts.length - 1;\n    this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t], t, 0);\n  }, $p.prototype.createSplitEdge = function (t, e) {\n    var n = e.segmentIndex - t.segmentIndex + 2,\n      r = this.edge.pts[e.segmentIndex],\n      i = e.dist > 0 || !e.coord.equals2D(r);\n    i || n--;\n    var o = new Array(n).fill(null),\n      s = 0;\n    o[s++] = new ul(t.coord);\n    for (var a = t.segmentIndex + 1; a <= e.segmentIndex; a++) o[s++] = this.edge.pts[a];\n    return i && (o[s] = e.coord), new of(o, new Dh(this.edge._label));\n  }, $p.prototype.add = function (t, e, n) {\n    var r = new Qp(t, e, n),\n      i = this._nodeMap.get(r);\n    return null !== i ? i : (this._nodeMap.put(r, r), r);\n  }, $p.prototype.isIntersection = function (t) {\n    for (var e = this.iterator(); e.hasNext();) {\n      if (e.next().coord.equals(t)) return !0;\n    }\n    return !1;\n  }, $p.prototype.interfaces_ = function () {\n    return [];\n  }, $p.prototype.getClass = function () {\n    return $p;\n  };\n  var tf = function tf() {};\n  tf.prototype.getChainStartIndices = function (t) {\n    var e = 0,\n      n = new lc();\n    n.add(new _l(e));\n    do {\n      var r = this.findChainEnd(t, e);\n      n.add(new _l(r)), e = r;\n    } while (e < t.length - 1);\n    return tf.toIntArray(n);\n  }, tf.prototype.findChainEnd = function (t, e) {\n    for (var n = jh.quadrant(t[e], t[e + 1]), r = e + 1; r < t.length;) {\n      if (jh.quadrant(t[r - 1], t[r]) !== n) break;\n      r++;\n    }\n    return r - 1;\n  }, tf.prototype.interfaces_ = function () {\n    return [];\n  }, tf.prototype.getClass = function () {\n    return tf;\n  }, tf.toIntArray = function (t) {\n    for (var e = new Array(t.size()).fill(null), n = 0; n < e.length; n++) e[n] = t.get(n).intValue();\n    return e;\n  };\n  var ef = function ef() {\n    this.e = null, this.pts = null, this.startIndex = null, this.env1 = new Ll(), this.env2 = new Ll();\n    var t = arguments[0];\n    this.e = t, this.pts = t.getCoordinates();\n    var e = new tf();\n    this.startIndex = e.getChainStartIndices(this.pts);\n  };\n  ef.prototype.getCoordinates = function () {\n    return this.pts;\n  }, ef.prototype.getMaxX = function (t) {\n    var e = this.pts[this.startIndex[t]].x,\n      n = this.pts[this.startIndex[t + 1]].x;\n    return e > n ? e : n;\n  }, ef.prototype.getMinX = function (t) {\n    var e = this.pts[this.startIndex[t]].x,\n      n = this.pts[this.startIndex[t + 1]].x;\n    return e < n ? e : n;\n  }, ef.prototype.computeIntersectsForChain = function () {\n    if (4 === arguments.length) {\n      var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2],\n        r = arguments[3];\n      this.computeIntersectsForChain(this.startIndex[t], this.startIndex[t + 1], e, e.startIndex[n], e.startIndex[n + 1], r);\n    } else if (6 === arguments.length) {\n      var i = arguments[0],\n        o = arguments[1],\n        s = arguments[2],\n        a = arguments[3],\n        u = arguments[4],\n        l = arguments[5],\n        c = this.pts[i],\n        h = this.pts[o],\n        p = s.pts[a],\n        f = s.pts[u];\n      if (o - i == 1 && u - a == 1) return l.addIntersections(this.e, i, s.e, a), null;\n      if (this.env1.init(c, h), this.env2.init(p, f), !this.env1.intersects(this.env2)) return null;\n      var g = Math.trunc((i + o) / 2),\n        d = Math.trunc((a + u) / 2);\n      i < g && (a < d && this.computeIntersectsForChain(i, g, s, a, d, l), d < u && this.computeIntersectsForChain(i, g, s, d, u, l)), g < o && (a < d && this.computeIntersectsForChain(g, o, s, a, d, l), d < u && this.computeIntersectsForChain(g, o, s, d, u, l));\n    }\n  }, ef.prototype.getStartIndexes = function () {\n    return this.startIndex;\n  }, ef.prototype.computeIntersects = function (t, e) {\n    for (var n = 0; n < this.startIndex.length - 1; n++) for (var r = 0; r < t.startIndex.length - 1; r++) this.computeIntersectsForChain(n, t, r, e);\n  }, ef.prototype.interfaces_ = function () {\n    return [];\n  }, ef.prototype.getClass = function () {\n    return ef;\n  };\n  var nf = function t() {\n      this._depth = Array(2).fill().map(function () {\n        return Array(3);\n      });\n      for (var e = 0; e < 2; e++) for (var n = 0; n < 3; n++) this._depth[e][n] = t.NULL_VALUE;\n    },\n    rf = {\n      NULL_VALUE: {\n        configurable: !0\n      }\n    };\n  nf.prototype.getDepth = function (t, e) {\n    return this._depth[t][e];\n  }, nf.prototype.setDepth = function (t, e, n) {\n    this._depth[t][e] = n;\n  }, nf.prototype.isNull = function () {\n    var t = this;\n    if (0 === arguments.length) {\n      for (var e = 0; e < 2; e++) for (var n = 0; n < 3; n++) if (t._depth[e][n] !== nf.NULL_VALUE) return !1;\n      return !0;\n    }\n    if (1 === arguments.length) {\n      var r = arguments[0];\n      return this._depth[r][1] === nf.NULL_VALUE;\n    }\n    if (2 === arguments.length) {\n      var i = arguments[0],\n        o = arguments[1];\n      return this._depth[i][o] === nf.NULL_VALUE;\n    }\n  }, nf.prototype.normalize = function () {\n    for (var t = this, e = 0; e < 2; e++) if (!t.isNull(e)) {\n      var n = t._depth[e][1];\n      t._depth[e][2] < n && (n = t._depth[e][2]), n < 0 && (n = 0);\n      for (var r = 1; r < 3; r++) {\n        var i = 0;\n        t._depth[e][r] > n && (i = 1), t._depth[e][r] = i;\n      }\n    }\n  }, nf.prototype.getDelta = function (t) {\n    return this._depth[t][Sh.RIGHT] - this._depth[t][Sh.LEFT];\n  }, nf.prototype.getLocation = function (t, e) {\n    return this._depth[t][e] <= 0 ? pl.EXTERIOR : pl.INTERIOR;\n  }, nf.prototype.toString = function () {\n    return \"A: \" + this._depth[0][1] + \",\" + this._depth[0][2] + \" B: \" + this._depth[1][1] + \",\" + this._depth[1][2];\n  }, nf.prototype.add = function () {\n    var t = this;\n    if (1 === arguments.length) for (var e = arguments[0], n = 0; n < 2; n++) for (var r = 1; r < 3; r++) {\n      var i = e.getLocation(n, r);\n      i !== pl.EXTERIOR && i !== pl.INTERIOR || (t.isNull(n, r) ? t._depth[n][r] = nf.depthAtLocation(i) : t._depth[n][r] += nf.depthAtLocation(i));\n    } else if (3 === arguments.length) {\n      var o = arguments[0],\n        s = arguments[1],\n        a = arguments[2];\n      a === pl.INTERIOR && this._depth[o][s]++;\n    }\n  }, nf.prototype.interfaces_ = function () {\n    return [];\n  }, nf.prototype.getClass = function () {\n    return nf;\n  }, nf.depthAtLocation = function (t) {\n    return t === pl.EXTERIOR ? 0 : t === pl.INTERIOR ? 1 : nf.NULL_VALUE;\n  }, rf.NULL_VALUE.get = function () {\n    return -1;\n  }, Object.defineProperties(nf, rf);\n  var of = function (t) {\n      function e() {\n        if (t.call(this), this.pts = null, this._env = null, this.eiList = new $p(this), this._name = null, this._mce = null, this._isIsolated = !0, this._depth = new nf(), this._depthDelta = 0, 1 === arguments.length) {\n          var n = arguments[0];\n          e.call(this, n, null);\n        } else if (2 === arguments.length) {\n          var r = arguments[0],\n            i = arguments[1];\n          this.pts = r, this._label = i;\n        }\n      }\n      return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getDepth = function () {\n        return this._depth;\n      }, e.prototype.getCollapsedEdge = function () {\n        var t = new Array(2).fill(null);\n        return t[0] = this.pts[0], t[1] = this.pts[1], new e(t, Dh.toLineLabel(this._label));\n      }, e.prototype.isIsolated = function () {\n        return this._isIsolated;\n      }, e.prototype.getCoordinates = function () {\n        return this.pts;\n      }, e.prototype.setIsolated = function (t) {\n        this._isIsolated = t;\n      }, e.prototype.setName = function (t) {\n        this._name = t;\n      }, e.prototype.equals = function (t) {\n        if (!(t instanceof e)) return !1;\n        var n = t;\n        if (this.pts.length !== n.pts.length) return !1;\n        for (var r = !0, i = !0, o = this.pts.length, s = 0; s < this.pts.length; s++) if (this.pts[s].equals2D(n.pts[s]) || (r = !1), this.pts[s].equals2D(n.pts[--o]) || (i = !1), !r && !i) return !1;\n        return !0;\n      }, e.prototype.getCoordinate = function () {\n        if (0 === arguments.length) return this.pts.length > 0 ? this.pts[0] : null;\n        if (1 === arguments.length) {\n          var t = arguments[0];\n          return this.pts[t];\n        }\n      }, e.prototype.print = function (t) {\n        t.print(\"edge \" + this._name + \": \"), t.print(\"LINESTRING (\");\n        for (var e = 0; e < this.pts.length; e++) e > 0 && t.print(\",\"), t.print(this.pts[e].x + \" \" + this.pts[e].y);\n        t.print(\")  \" + this._label + \" \" + this._depthDelta);\n      }, e.prototype.computeIM = function (t) {\n        e.updateIM(this._label, t);\n      }, e.prototype.isCollapsed = function () {\n        return !!this._label.isArea() && 3 === this.pts.length && !!this.pts[0].equals(this.pts[2]);\n      }, e.prototype.isClosed = function () {\n        return this.pts[0].equals(this.pts[this.pts.length - 1]);\n      }, e.prototype.getMaximumSegmentIndex = function () {\n        return this.pts.length - 1;\n      }, e.prototype.getDepthDelta = function () {\n        return this._depthDelta;\n      }, e.prototype.getNumPoints = function () {\n        return this.pts.length;\n      }, e.prototype.printReverse = function (t) {\n        t.print(\"edge \" + this._name + \": \");\n        for (var e = this.pts.length - 1; e >= 0; e--) t.print(this.pts[e] + \" \");\n        t.println(\"\");\n      }, e.prototype.getMonotoneChainEdge = function () {\n        return null === this._mce && (this._mce = new ef(this)), this._mce;\n      }, e.prototype.getEnvelope = function () {\n        if (null === this._env) {\n          this._env = new Ll();\n          for (var t = 0; t < this.pts.length; t++) this._env.expandToInclude(this.pts[t]);\n        }\n        return this._env;\n      }, e.prototype.addIntersection = function (t, e, n, r) {\n        var i = new ul(t.getIntersection(r)),\n          o = e,\n          s = t.getEdgeDistance(n, r),\n          a = o + 1;\n        if (a < this.pts.length) {\n          var u = this.pts[a];\n          i.equals2D(u) && (o = a, s = 0);\n        }\n        this.eiList.add(i, o, s);\n      }, e.prototype.toString = function () {\n        var t = new vl();\n        t.append(\"edge \" + this._name + \": \"), t.append(\"LINESTRING (\");\n        for (var e = 0; e < this.pts.length; e++) e > 0 && t.append(\",\"), t.append(this.pts[e].x + \" \" + this.pts[e].y);\n        return t.append(\")  \" + this._label + \" \" + this._depthDelta), t.toString();\n      }, e.prototype.isPointwiseEqual = function (t) {\n        if (this.pts.length !== t.pts.length) return !1;\n        for (var e = 0; e < this.pts.length; e++) if (!this.pts[e].equals2D(t.pts[e])) return !1;\n        return !0;\n      }, e.prototype.setDepthDelta = function (t) {\n        this._depthDelta = t;\n      }, e.prototype.getEdgeIntersectionList = function () {\n        return this.eiList;\n      }, e.prototype.addIntersections = function (t, e, n) {\n        for (var r = 0; r < t.getIntersectionNum(); r++) this.addIntersection(t, e, n, r);\n      }, e.prototype.interfaces_ = function () {\n        return [];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, e.updateIM = function () {\n        if (2 !== arguments.length) return t.prototype.updateIM.apply(this, arguments);\n        var e = arguments[0],\n          n = arguments[1];\n        n.setAtLeastIfValid(e.getLocation(0, Sh.ON), e.getLocation(1, Sh.ON), 1), e.isArea() && (n.setAtLeastIfValid(e.getLocation(0, Sh.LEFT), e.getLocation(1, Sh.LEFT), 2), n.setAtLeastIfValid(e.getLocation(0, Sh.RIGHT), e.getLocation(1, Sh.RIGHT), 2));\n      }, e;\n    }(qh),\n    sf = function sf(t) {\n      this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new Jp(), this._bufParams = t || null;\n    };\n  sf.prototype.setWorkingPrecisionModel = function (t) {\n    this._workingPrecisionModel = t;\n  }, sf.prototype.insertUniqueEdge = function (t) {\n    var e = this._edgeList.findEqualEdge(t);\n    if (null !== e) {\n      var n = e.getLabel(),\n        r = t.getLabel();\n      e.isPointwiseEqual(t) || (r = new Dh(t.getLabel())).flip(), n.merge(r);\n      var i = sf.depthDelta(r),\n        o = e.getDepthDelta() + i;\n      e.setDepthDelta(o);\n    } else this._edgeList.add(t), t.setDepthDelta(sf.depthDelta(t.getLabel()));\n  }, sf.prototype.buildSubgraphs = function (t, e) {\n    for (var n = new lc(), r = t.iterator(); r.hasNext();) {\n      var i = r.next(),\n        o = i.getRightmostCoordinate(),\n        s = new kp(n).getDepth(o);\n      i.computeDepth(s), i.findResultEdges(), n.add(i), e.add(i.getDirectedEdges(), i.getNodes());\n    }\n  }, sf.prototype.createSubgraphs = function (t) {\n    for (var e = new lc(), n = t.getNodes().iterator(); n.hasNext();) {\n      var r = n.next();\n      if (!r.isVisited()) {\n        var i = new Th();\n        i.create(r), e.add(i);\n      }\n    }\n    return np.sort(e, np.reverseOrder()), e;\n  }, sf.prototype.createEmptyResultGeometry = function () {\n    return this._geomFact.createPolygon();\n  }, sf.prototype.getNoder = function (t) {\n    if (null !== this._workingNoder) return this._workingNoder;\n    var e = new Ip(),\n      n = new jl();\n    return n.setPrecisionModel(t), e.setSegmentIntersector(new Kp(n)), e;\n  }, sf.prototype.buffer = function (t, e) {\n    var n = this._workingPrecisionModel;\n    null === n && (n = t.getPrecisionModel()), this._geomFact = t.getFactory();\n    var r = new Fp(n, this._bufParams),\n      i = new zp(t, e, r).getCurves();\n    if (i.size() <= 0) return this.createEmptyResultGeometry();\n    this.computeNodedEdges(i, n), this._graph = new Hh(new Hp()), this._graph.addEdges(this._edgeList.getEdges());\n    var o = this.createSubgraphs(this._graph),\n      s = new Wh(this._geomFact);\n    this.buildSubgraphs(o, s);\n    var a = s.getPolygons();\n    return a.size() <= 0 ? this.createEmptyResultGeometry() : this._geomFact.buildGeometry(a);\n  }, sf.prototype.computeNodedEdges = function (t, e) {\n    var n = this.getNoder(e);\n    n.computeNodes(t);\n    for (var r = n.getNodedSubstrings().iterator(); r.hasNext();) {\n      var i = r.next(),\n        o = i.getCoordinates();\n      if (2 !== o.length || !o[0].equals2D(o[1])) {\n        var s = i.getData(),\n          a = new of(i.getCoordinates(), new Dh(s));\n        this.insertUniqueEdge(a);\n      }\n    }\n  }, sf.prototype.setNoder = function (t) {\n    this._workingNoder = t;\n  }, sf.prototype.interfaces_ = function () {\n    return [];\n  }, sf.prototype.getClass = function () {\n    return sf;\n  }, sf.depthDelta = function (t) {\n    var e = t.getLocation(0, Sh.LEFT),\n      n = t.getLocation(0, Sh.RIGHT);\n    return e === pl.INTERIOR && n === pl.EXTERIOR ? 1 : e === pl.EXTERIOR && n === pl.INTERIOR ? -1 : 0;\n  }, sf.convertSegStrings = function (t) {\n    for (var e = new _h(), n = new lc(); t.hasNext();) {\n      var r = t.next(),\n        i = e.createLineString(r.getCoordinates());\n      n.add(i);\n    }\n    return e.buildGeometry(n);\n  };\n  var af = function af() {\n    if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = !1, 2 === arguments.length) {\n      var t = arguments[0],\n        e = arguments[1];\n      this._noder = t, this._scaleFactor = e, this._offsetX = 0, this._offsetY = 0, this._isScaled = !this.isIntegerPrecision();\n    } else if (4 === arguments.length) {\n      var n = arguments[0],\n        r = arguments[1],\n        i = arguments[2],\n        o = arguments[3];\n      this._noder = n, this._scaleFactor = r, this._offsetX = i, this._offsetY = o, this._isScaled = !this.isIntegerPrecision();\n    }\n  };\n  af.prototype.rescale = function () {\n    var t = this;\n    if (gl(arguments[0], ic)) for (var e = arguments[0], n = e.iterator(); n.hasNext();) {\n      var r = n.next();\n      t.rescale(r.getCoordinates());\n    } else if (arguments[0] instanceof Array) {\n      for (var i = arguments[0], o = 0; o < i.length; o++) i[o].x = i[o].x / t._scaleFactor + t._offsetX, i[o].y = i[o].y / t._scaleFactor + t._offsetY;\n      2 === i.length && i[0].equals2D(i[1]) && Pl.out.println(i);\n    }\n  }, af.prototype.scale = function () {\n    var t = this;\n    if (gl(arguments[0], ic)) {\n      for (var e = arguments[0], n = new lc(), r = e.iterator(); r.hasNext();) {\n        var i = r.next();\n        n.add(new yp(t.scale(i.getCoordinates()), i.getData()));\n      }\n      return n;\n    }\n    if (arguments[0] instanceof Array) {\n      for (var o = arguments[0], s = new Array(o.length).fill(null), a = 0; a < o.length; a++) s[a] = new ul(Math.round((o[a].x - t._offsetX) * t._scaleFactor), Math.round((o[a].y - t._offsetY) * t._scaleFactor), o[a].z);\n      var u = pc.removeRepeatedPoints(s);\n      return u;\n    }\n  }, af.prototype.isIntegerPrecision = function () {\n    return 1 === this._scaleFactor;\n  }, af.prototype.getNodedSubstrings = function () {\n    var t = this._noder.getNodedSubstrings();\n    return this._isScaled && this.rescale(t), t;\n  }, af.prototype.computeNodes = function (t) {\n    var e = t;\n    this._isScaled && (e = this.scale(t)), this._noder.computeNodes(e);\n  }, af.prototype.interfaces_ = function () {\n    return [bp];\n  }, af.prototype.getClass = function () {\n    return af;\n  };\n  var uf = function uf() {\n      this._li = new jl(), this._segStrings = null;\n      var t = arguments[0];\n      this._segStrings = t;\n    },\n    lf = {\n      fact: {\n        configurable: !0\n      }\n    };\n  uf.prototype.checkEndPtVertexIntersections = function () {\n    var t = this;\n    if (0 === arguments.length) for (var e = this._segStrings.iterator(); e.hasNext();) {\n      var n = e.next(),\n        r = n.getCoordinates();\n      t.checkEndPtVertexIntersections(r[0], t._segStrings), t.checkEndPtVertexIntersections(r[r.length - 1], t._segStrings);\n    } else if (2 === arguments.length) for (var i = arguments[0], o = arguments[1], s = o.iterator(); s.hasNext();) for (var a = s.next(), u = a.getCoordinates(), l = 1; l < u.length - 1; l++) if (u[l].equals(i)) throw new kl(\"found endpt/interior pt intersection at index \" + l + \" :pt \" + i);\n  }, uf.prototype.checkInteriorIntersections = function () {\n    var t = this;\n    if (0 === arguments.length) for (var e = this._segStrings.iterator(); e.hasNext();) for (var n = e.next(), r = this._segStrings.iterator(); r.hasNext();) {\n      var i = r.next();\n      t.checkInteriorIntersections(n, i);\n    } else if (2 === arguments.length) for (var o = arguments[0], s = arguments[1], a = o.getCoordinates(), u = s.getCoordinates(), l = 0; l < a.length - 1; l++) for (var c = 0; c < u.length - 1; c++) t.checkInteriorIntersections(o, l, s, c);else if (4 === arguments.length) {\n      var h = arguments[0],\n        p = arguments[1],\n        f = arguments[2],\n        g = arguments[3];\n      if (h === f && p === g) return null;\n      var d = h.getCoordinates()[p],\n        y = h.getCoordinates()[p + 1],\n        v = f.getCoordinates()[g],\n        _ = f.getCoordinates()[g + 1];\n      if (this._li.computeIntersection(d, y, v, _), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, d, y) || this.hasInteriorIntersection(this._li, v, _))) throw new kl(\"found non-noded intersection at \" + d + \"-\" + y + \" and \" + v + \"-\" + _);\n    }\n  }, uf.prototype.checkValid = function () {\n    this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses();\n  }, uf.prototype.checkCollapses = function () {\n    var t = this;\n    if (0 === arguments.length) for (var e = this._segStrings.iterator(); e.hasNext();) {\n      var n = e.next();\n      t.checkCollapses(n);\n    } else if (1 === arguments.length) for (var r = arguments[0], i = r.getCoordinates(), o = 0; o < i.length - 2; o++) t.checkCollapse(i[o], i[o + 1], i[o + 2]);\n  }, uf.prototype.hasInteriorIntersection = function (t, e, n) {\n    for (var r = 0; r < t.getIntersectionNum(); r++) {\n      var i = t.getIntersection(r);\n      if (!i.equals(e) && !i.equals(n)) return !0;\n    }\n    return !1;\n  }, uf.prototype.checkCollapse = function (t, e, n) {\n    if (t.equals(n)) throw new kl(\"found non-noded collapse at \" + uf.fact.createLineString([t, e, n]));\n  }, uf.prototype.interfaces_ = function () {\n    return [];\n  }, uf.prototype.getClass = function () {\n    return uf;\n  }, lf.fact.get = function () {\n    return new _h();\n  }, Object.defineProperties(uf, lf);\n  var cf = function cf() {\n      this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null;\n      var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2];\n      if (this._originalPt = t, this._pt = t, this._scaleFactor = e, this._li = n, e <= 0) throw new el(\"Scale factor must be non-zero\");\n      1 !== e && (this._pt = new ul(this.scale(t.x), this.scale(t.y)), this._p0Scaled = new ul(), this._p1Scaled = new ul()), this.initCorners(this._pt);\n    },\n    hf = {\n      SAFE_ENV_EXPANSION_FACTOR: {\n        configurable: !0\n      }\n    };\n  cf.prototype.intersectsScaled = function (t, e) {\n    var n = Math.min(t.x, e.x),\n      r = Math.max(t.x, e.x),\n      i = Math.min(t.y, e.y),\n      o = Math.max(t.y, e.y),\n      s = this._maxx < n || this._minx > r || this._maxy < i || this._miny > o;\n    if (s) return !1;\n    var a = this.intersectsToleranceSquare(t, e);\n    return ql.isTrue(!(s && a), \"Found bad envelope test\"), a;\n  }, cf.prototype.initCorners = function (t) {\n    var e = .5;\n    this._minx = t.x - e, this._maxx = t.x + e, this._miny = t.y - e, this._maxy = t.y + e, this._corner[0] = new ul(this._maxx, this._maxy), this._corner[1] = new ul(this._minx, this._maxy), this._corner[2] = new ul(this._minx, this._miny), this._corner[3] = new ul(this._maxx, this._miny);\n  }, cf.prototype.intersects = function (t, e) {\n    return 1 === this._scaleFactor ? this.intersectsScaled(t, e) : (this.copyScaled(t, this._p0Scaled), this.copyScaled(e, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled));\n  }, cf.prototype.scale = function (t) {\n    return Math.round(t * this._scaleFactor);\n  }, cf.prototype.getCoordinate = function () {\n    return this._originalPt;\n  }, cf.prototype.copyScaled = function (t, e) {\n    e.x = this.scale(t.x), e.y = this.scale(t.y);\n  }, cf.prototype.getSafeEnvelope = function () {\n    if (null === this._safeEnv) {\n      var t = cf.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;\n      this._safeEnv = new Ll(this._originalPt.x - t, this._originalPt.x + t, this._originalPt.y - t, this._originalPt.y + t);\n    }\n    return this._safeEnv;\n  }, cf.prototype.intersectsPixelClosure = function (t, e) {\n    return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), !!this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), !!this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), !!this._li.hasIntersection())));\n  }, cf.prototype.intersectsToleranceSquare = function (t, e) {\n    var n = !1,\n      r = !1;\n    return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!this._li.isProper() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), !!this._li.isProper() || (this._li.hasIntersection() && (n = !0), this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), !!this._li.isProper() || (this._li.hasIntersection() && (r = !0), this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), !!this._li.isProper() || !(!n || !r) || !!t.equals(this._pt) || !!e.equals(this._pt))));\n  }, cf.prototype.addSnappedNode = function (t, e) {\n    var n = t.getCoordinate(e),\n      r = t.getCoordinate(e + 1);\n    return !!this.intersects(n, r) && (t.addIntersection(this.getCoordinate(), e), !0);\n  }, cf.prototype.interfaces_ = function () {\n    return [];\n  }, cf.prototype.getClass = function () {\n    return cf;\n  }, hf.SAFE_ENV_EXPANSION_FACTOR.get = function () {\n    return .75;\n  }, Object.defineProperties(cf, hf);\n  var pf = function pf() {\n    this.tempEnv1 = new Ll(), this.selectedSegment = new vp();\n  };\n  pf.prototype.select = function () {\n    if (1 === arguments.length) ;else if (2 === arguments.length) {\n      var t = arguments[0],\n        e = arguments[1];\n      t.getLineSegment(e, this.selectedSegment), this.select(this.selectedSegment);\n    }\n  }, pf.prototype.interfaces_ = function () {\n    return [];\n  }, pf.prototype.getClass = function () {\n    return pf;\n  };\n  var ff = function ff() {\n      this._index = null;\n      var t = arguments[0];\n      this._index = t;\n    },\n    gf = {\n      HotPixelSnapAction: {\n        configurable: !0\n      }\n    };\n  ff.prototype.snap = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return this.snap(t, null, -1);\n    }\n    if (3 === arguments.length) {\n      var e = arguments[0],\n        n = arguments[1],\n        r = arguments[2],\n        i = e.getSafeEnvelope(),\n        o = new df(e, n, r);\n      return this._index.query(i, {\n        interfaces_: function interfaces_() {\n          return [Qh];\n        },\n        visitItem: function visitItem(t) {\n          t.select(i, o);\n        }\n      }), o.isNodeAdded();\n    }\n  }, ff.prototype.interfaces_ = function () {\n    return [];\n  }, ff.prototype.getClass = function () {\n    return ff;\n  }, gf.HotPixelSnapAction.get = function () {\n    return df;\n  }, Object.defineProperties(ff, gf);\n  var df = function (t) {\n      function e() {\n        t.call(this), this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = !1;\n        var e = arguments[0],\n          n = arguments[1],\n          r = arguments[2];\n        this._hotPixel = e, this._parentEdge = n, this._hotPixelVertexIndex = r;\n      }\n      return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.isNodeAdded = function () {\n        return this._isNodeAdded;\n      }, e.prototype.select = function () {\n        if (2 !== arguments.length) return t.prototype.select.apply(this, arguments);\n        var e = arguments[0],\n          n = arguments[1],\n          r = e.getContext();\n        if (null !== this._parentEdge && r === this._parentEdge && n === this._hotPixelVertexIndex) return null;\n        this._isNodeAdded = this._hotPixel.addSnappedNode(r, n);\n      }, e.prototype.interfaces_ = function () {\n        return [];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, e;\n    }(pf),\n    yf = function yf() {\n      this._li = null, this._interiorIntersections = null;\n      var t = arguments[0];\n      this._li = t, this._interiorIntersections = new lc();\n    };\n  yf.prototype.processIntersections = function (t, e, n, r) {\n    if (t === n && e === r) return null;\n    var i = t.getCoordinates()[e],\n      o = t.getCoordinates()[e + 1],\n      s = n.getCoordinates()[r],\n      a = n.getCoordinates()[r + 1];\n    if (this._li.computeIntersection(i, o, s, a), this._li.hasIntersection() && this._li.isInteriorIntersection()) {\n      for (var u = 0; u < this._li.getIntersectionNum(); u++) this._interiorIntersections.add(this._li.getIntersection(u));\n      t.addIntersections(this._li, e, 0), n.addIntersections(this._li, r, 1);\n    }\n  }, yf.prototype.isDone = function () {\n    return !1;\n  }, yf.prototype.getInteriorIntersections = function () {\n    return this._interiorIntersections;\n  }, yf.prototype.interfaces_ = function () {\n    return [Zp];\n  }, yf.prototype.getClass = function () {\n    return yf;\n  };\n  var vf = function vf() {\n    this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null;\n    var t = arguments[0];\n    this._pm = t, this._li = new jl(), this._li.setPrecisionModel(t), this._scaleFactor = t.getScale();\n  };\n  vf.prototype.checkCorrectness = function (t) {\n    var e = yp.getNodedSubstrings(t),\n      n = new uf(e);\n    try {\n      n.checkValid();\n    } catch (t) {\n      if (!(t instanceof Sl)) throw t;\n      t.printStackTrace();\n    }\n  }, vf.prototype.getNodedSubstrings = function () {\n    return yp.getNodedSubstrings(this._nodedSegStrings);\n  }, vf.prototype.snapRound = function (t, e) {\n    var n = this.findInteriorIntersections(t, e);\n    this.computeIntersectionSnaps(n), this.computeVertexSnaps(t);\n  }, vf.prototype.findInteriorIntersections = function (t, e) {\n    var n = new yf(e);\n    return this._noder.setSegmentIntersector(n), this._noder.computeNodes(t), n.getInteriorIntersections();\n  }, vf.prototype.computeVertexSnaps = function () {\n    var t = this;\n    if (gl(arguments[0], ic)) for (var e = arguments[0], n = e.iterator(); n.hasNext();) {\n      var r = n.next();\n      t.computeVertexSnaps(r);\n    } else if (arguments[0] instanceof yp) for (var i = arguments[0], o = i.getCoordinates(), s = 0; s < o.length; s++) {\n      var a = new cf(o[s], t._scaleFactor, t._li),\n        u = t._pointSnapper.snap(a, i, s);\n      u && i.addIntersection(o[s], s);\n    }\n  }, vf.prototype.computeNodes = function (t) {\n    this._nodedSegStrings = t, this._noder = new Ip(), this._pointSnapper = new ff(this._noder.getIndex()), this.snapRound(t, this._li);\n  }, vf.prototype.computeIntersectionSnaps = function (t) {\n    for (var e = this, n = t.iterator(); n.hasNext();) {\n      var r = n.next(),\n        i = new cf(r, e._scaleFactor, e._li);\n      e._pointSnapper.snap(i);\n    }\n  }, vf.prototype.interfaces_ = function () {\n    return [bp];\n  }, vf.prototype.getClass = function () {\n    return vf;\n  };\n  var _f = function _f() {\n      if (this._argGeom = null, this._distance = null, this._bufParams = new Sp(), this._resultGeometry = null, this._saveException = null, 1 === arguments.length) {\n        var t = arguments[0];\n        this._argGeom = t;\n      } else if (2 === arguments.length) {\n        var e = arguments[0],\n          n = arguments[1];\n        this._argGeom = e, this._bufParams = n;\n      }\n    },\n    mf = {\n      CAP_ROUND: {\n        configurable: !0\n      },\n      CAP_BUTT: {\n        configurable: !0\n      },\n      CAP_FLAT: {\n        configurable: !0\n      },\n      CAP_SQUARE: {\n        configurable: !0\n      },\n      MAX_PRECISION_DIGITS: {\n        configurable: !0\n      }\n    };\n  _f.prototype.bufferFixedPrecision = function (t) {\n    var e = new af(new vf(new gh(1)), t.getScale()),\n      n = new sf(this._bufParams);\n    n.setWorkingPrecisionModel(t), n.setNoder(e), this._resultGeometry = n.buffer(this._argGeom, this._distance);\n  }, _f.prototype.bufferReducedPrecision = function () {\n    var t = this;\n    if (0 === arguments.length) {\n      for (var e = _f.MAX_PRECISION_DIGITS; e >= 0; e--) {\n        try {\n          t.bufferReducedPrecision(e);\n        } catch (e) {\n          if (!(e instanceof Oh)) throw e;\n          t._saveException = e;\n        }\n        if (null !== t._resultGeometry) return null;\n      }\n      throw this._saveException;\n    }\n    if (1 === arguments.length) {\n      var n = arguments[0],\n        r = _f.precisionScaleFactor(this._argGeom, this._distance, n),\n        i = new gh(r);\n      this.bufferFixedPrecision(i);\n    }\n  }, _f.prototype.computeGeometry = function () {\n    if (this.bufferOriginalPrecision(), null !== this._resultGeometry) return null;\n    var t = this._argGeom.getFactory().getPrecisionModel();\n    t.getType() === gh.FIXED ? this.bufferFixedPrecision(t) : this.bufferReducedPrecision();\n  }, _f.prototype.setQuadrantSegments = function (t) {\n    this._bufParams.setQuadrantSegments(t);\n  }, _f.prototype.bufferOriginalPrecision = function () {\n    try {\n      var t = new sf(this._bufParams);\n      this._resultGeometry = t.buffer(this._argGeom, this._distance);\n    } catch (t) {\n      if (!(t instanceof kl)) throw t;\n      this._saveException = t;\n    }\n  }, _f.prototype.getResultGeometry = function (t) {\n    return this._distance = t, this.computeGeometry(), this._resultGeometry;\n  }, _f.prototype.setEndCapStyle = function (t) {\n    this._bufParams.setEndCapStyle(t);\n  }, _f.prototype.interfaces_ = function () {\n    return [];\n  }, _f.prototype.getClass = function () {\n    return _f;\n  }, _f.bufferOp = function () {\n    if (2 === arguments.length) {\n      var t = arguments[0],\n        e = arguments[1],\n        n = new _f(t),\n        r = n.getResultGeometry(e);\n      return r;\n    }\n    if (3 === arguments.length) {\n      if (Number.isInteger(arguments[2]) && arguments[0] instanceof Wl && \"number\" == typeof arguments[1]) {\n        var i = arguments[0],\n          o = arguments[1],\n          s = arguments[2],\n          a = new _f(i);\n        a.setQuadrantSegments(s);\n        var u = a.getResultGeometry(o);\n        return u;\n      }\n      if (arguments[2] instanceof Sp && arguments[0] instanceof Wl && \"number\" == typeof arguments[1]) {\n        var l = arguments[0],\n          c = arguments[1],\n          h = arguments[2],\n          p = new _f(l, h),\n          f = p.getResultGeometry(c);\n        return f;\n      }\n    } else if (4 === arguments.length) {\n      var g = arguments[0],\n        d = arguments[1],\n        y = arguments[2],\n        v = arguments[3],\n        _ = new _f(g);\n      _.setQuadrantSegments(y), _.setEndCapStyle(v);\n      var m = _.getResultGeometry(d);\n      return m;\n    }\n  }, _f.precisionScaleFactor = function (t, e, n) {\n    var r = t.getEnvelopeInternal(),\n      i = dl.max(Math.abs(r.getMaxX()), Math.abs(r.getMaxY()), Math.abs(r.getMinX()), Math.abs(r.getMinY())) + 2 * (e > 0 ? e : 0),\n      o = n - Math.trunc(Math.log(i) / Math.log(10) + 1);\n    return Math.pow(10, o);\n  }, mf.CAP_ROUND.get = function () {\n    return Sp.CAP_ROUND;\n  }, mf.CAP_BUTT.get = function () {\n    return Sp.CAP_FLAT;\n  }, mf.CAP_FLAT.get = function () {\n    return Sp.CAP_FLAT;\n  }, mf.CAP_SQUARE.get = function () {\n    return Sp.CAP_SQUARE;\n  }, mf.MAX_PRECISION_DIGITS.get = function () {\n    return 12;\n  }, Object.defineProperties(_f, mf);\n  var xf = function xf() {\n    this._pt = [new ul(), new ul()], this._distance = nl.NaN, this._isNull = !0;\n  };\n  xf.prototype.getCoordinates = function () {\n    return this._pt;\n  }, xf.prototype.getCoordinate = function (t) {\n    return this._pt[t];\n  }, xf.prototype.setMinimum = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      this.setMinimum(t._pt[0], t._pt[1]);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n        n = arguments[1];\n      if (this._isNull) return this.initialize(e, n), null;\n      var r = e.distance(n);\n      r < this._distance && this.initialize(e, n, r);\n    }\n  }, xf.prototype.initialize = function () {\n    if (0 === arguments.length) this._isNull = !0;else if (2 === arguments.length) {\n      var t = arguments[0],\n        e = arguments[1];\n      this._pt[0].setCoordinate(t), this._pt[1].setCoordinate(e), this._distance = t.distance(e), this._isNull = !1;\n    } else if (3 === arguments.length) {\n      var n = arguments[0],\n        r = arguments[1],\n        i = arguments[2];\n      this._pt[0].setCoordinate(n), this._pt[1].setCoordinate(r), this._distance = i, this._isNull = !1;\n    }\n  }, xf.prototype.getDistance = function () {\n    return this._distance;\n  }, xf.prototype.setMaximum = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      this.setMaximum(t._pt[0], t._pt[1]);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n        n = arguments[1];\n      if (this._isNull) return this.initialize(e, n), null;\n      var r = e.distance(n);\n      r > this._distance && this.initialize(e, n, r);\n    }\n  }, xf.prototype.interfaces_ = function () {\n    return [];\n  }, xf.prototype.getClass = function () {\n    return xf;\n  };\n  var Ef = function Ef() {};\n  Ef.prototype.interfaces_ = function () {\n    return [];\n  }, Ef.prototype.getClass = function () {\n    return Ef;\n  }, Ef.computeDistance = function () {\n    if (arguments[2] instanceof xf && arguments[0] instanceof Zc && arguments[1] instanceof ul) for (var t = arguments[0], e = arguments[1], n = arguments[2], r = t.getCoordinates(), i = new vp(), o = 0; o < r.length - 1; o++) {\n      i.setCoordinates(r[o], r[o + 1]);\n      var s = i.closestPoint(e);\n      n.setMinimum(s, e);\n    } else if (arguments[2] instanceof xf && arguments[0] instanceof th && arguments[1] instanceof ul) {\n      var a = arguments[0],\n        u = arguments[1],\n        l = arguments[2];\n      Ef.computeDistance(a.getExteriorRing(), u, l);\n      for (var c = 0; c < a.getNumInteriorRing(); c++) Ef.computeDistance(a.getInteriorRingN(c), u, l);\n    } else if (arguments[2] instanceof xf && arguments[0] instanceof Wl && arguments[1] instanceof ul) {\n      var h = arguments[0],\n        p = arguments[1],\n        f = arguments[2];\n      if (h instanceof Zc) Ef.computeDistance(h, p, f);else if (h instanceof th) Ef.computeDistance(h, p, f);else if (h instanceof kc) for (var g = h, d = 0; d < g.getNumGeometries(); d++) {\n        var y = g.getGeometryN(d);\n        Ef.computeDistance(y, p, f);\n      } else f.setMinimum(h.getCoordinate(), p);\n    } else if (arguments[2] instanceof xf && arguments[0] instanceof vp && arguments[1] instanceof ul) {\n      var v = arguments[0],\n        _ = arguments[1],\n        m = arguments[2],\n        x = v.closestPoint(_);\n      m.setMinimum(x, _);\n    }\n  };\n  var bf = function bf(t) {\n      this._maxPtDist = new xf(), this._inputGeom = t || null;\n    },\n    wf = {\n      MaxPointDistanceFilter: {\n        configurable: !0\n      },\n      MaxMidpointDistanceFilter: {\n        configurable: !0\n      }\n    };\n  bf.prototype.computeMaxMidpointDistance = function (t) {\n    var e = new Nf(this._inputGeom);\n    t.apply(e), this._maxPtDist.setMaximum(e.getMaxPointDistance());\n  }, bf.prototype.computeMaxVertexDistance = function (t) {\n    var e = new If(this._inputGeom);\n    t.apply(e), this._maxPtDist.setMaximum(e.getMaxPointDistance());\n  }, bf.prototype.findDistance = function (t) {\n    return this.computeMaxVertexDistance(t), this.computeMaxMidpointDistance(t), this._maxPtDist.getDistance();\n  }, bf.prototype.getDistancePoints = function () {\n    return this._maxPtDist;\n  }, bf.prototype.interfaces_ = function () {\n    return [];\n  }, bf.prototype.getClass = function () {\n    return bf;\n  }, wf.MaxPointDistanceFilter.get = function () {\n    return If;\n  }, wf.MaxMidpointDistanceFilter.get = function () {\n    return Nf;\n  }, Object.defineProperties(bf, wf);\n  var If = function If(t) {\n    this._maxPtDist = new xf(), this._minPtDist = new xf(), this._geom = t || null;\n  };\n  If.prototype.filter = function (t) {\n    this._minPtDist.initialize(), Ef.computeDistance(this._geom, t, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);\n  }, If.prototype.getMaxPointDistance = function () {\n    return this._maxPtDist;\n  }, If.prototype.interfaces_ = function () {\n    return [Kl];\n  }, If.prototype.getClass = function () {\n    return If;\n  };\n  var Nf = function Nf(t) {\n    this._maxPtDist = new xf(), this._minPtDist = new xf(), this._geom = t || null;\n  };\n  Nf.prototype.filter = function (t, e) {\n    if (0 === e) return null;\n    var n = t.getCoordinate(e - 1),\n      r = t.getCoordinate(e),\n      i = new ul((n.x + r.x) / 2, (n.y + r.y) / 2);\n    this._minPtDist.initialize(), Ef.computeDistance(this._geom, i, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);\n  }, Nf.prototype.isDone = function () {\n    return !1;\n  }, Nf.prototype.isGeometryChanged = function () {\n    return !1;\n  }, Nf.prototype.getMaxPointDistance = function () {\n    return this._maxPtDist;\n  }, Nf.prototype.interfaces_ = function () {\n    return [Fc];\n  }, Nf.prototype.getClass = function () {\n    return Nf;\n  };\n  var Sf = function Sf(t) {\n    this._comps = t || null;\n  };\n  Sf.prototype.filter = function (t) {\n    t instanceof th && this._comps.add(t);\n  }, Sf.prototype.interfaces_ = function () {\n    return [Dc];\n  }, Sf.prototype.getClass = function () {\n    return Sf;\n  }, Sf.getPolygons = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return Sf.getPolygons(t, new lc());\n    }\n    if (2 === arguments.length) {\n      var e = arguments[0],\n        n = arguments[1];\n      return e instanceof th ? n.add(e) : e instanceof kc && e.apply(new Sf(n)), n;\n    }\n  };\n  var Cf = function Cf() {\n    if (this._lines = null, this._isForcedToLineString = !1, 1 === arguments.length) {\n      var t = arguments[0];\n      this._lines = t;\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n        n = arguments[1];\n      this._lines = e, this._isForcedToLineString = n;\n    }\n  };\n  Cf.prototype.filter = function (t) {\n    if (this._isForcedToLineString && t instanceof nh) {\n      var e = t.getFactory().createLineString(t.getCoordinateSequence());\n      return this._lines.add(e), null;\n    }\n    t instanceof Zc && this._lines.add(t);\n  }, Cf.prototype.setForceToLineString = function (t) {\n    this._isForcedToLineString = t;\n  }, Cf.prototype.interfaces_ = function () {\n    return [Hl];\n  }, Cf.prototype.getClass = function () {\n    return Cf;\n  }, Cf.getGeometry = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return t.getFactory().buildGeometry(Cf.getLines(t));\n    }\n    if (2 === arguments.length) {\n      var e = arguments[0],\n        n = arguments[1];\n      return e.getFactory().buildGeometry(Cf.getLines(e, n));\n    }\n  }, Cf.getLines = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return Cf.getLines(t, !1);\n    }\n    if (2 === arguments.length) {\n      if (gl(arguments[0], ic) && gl(arguments[1], ic)) {\n        for (var e = arguments[0], n = arguments[1], r = e.iterator(); r.hasNext();) {\n          var i = r.next();\n          Cf.getLines(i, n);\n        }\n        return n;\n      }\n      if (arguments[0] instanceof Wl && \"boolean\" == typeof arguments[1]) {\n        var o = arguments[0],\n          s = arguments[1],\n          a = new lc();\n        return o.apply(new Cf(a, s)), a;\n      }\n      if (arguments[0] instanceof Wl && gl(arguments[1], ic)) {\n        var u = arguments[0],\n          l = arguments[1];\n        return u instanceof Zc ? l.add(u) : u.apply(new Cf(l)), l;\n      }\n    } else if (3 === arguments.length) {\n      if (\"boolean\" == typeof arguments[2] && gl(arguments[0], ic) && gl(arguments[1], ic)) {\n        for (var c = arguments[0], h = arguments[1], p = arguments[2], f = c.iterator(); f.hasNext();) {\n          var g = f.next();\n          Cf.getLines(g, h, p);\n        }\n        return h;\n      }\n      if (\"boolean\" == typeof arguments[2] && arguments[0] instanceof Wl && gl(arguments[1], ic)) {\n        var d = arguments[0],\n          y = arguments[1],\n          v = arguments[2];\n        return d.apply(new Cf(y, v)), y;\n      }\n    }\n  };\n  var Pf = function Pf() {\n    if (this._boundaryRule = Ql.OGC_SFS_BOUNDARY_RULE, this._isIn = null, this._numBoundaries = null, 0 === arguments.length) ;else if (1 === arguments.length) {\n      var t = arguments[0];\n      if (null === t) throw new el(\"Rule must be non-null\");\n      this._boundaryRule = t;\n    }\n  };\n  Pf.prototype.locateInternal = function () {\n    var t = this;\n    if (arguments[0] instanceof ul && arguments[1] instanceof th) {\n      var e = arguments[0],\n        n = arguments[1];\n      if (n.isEmpty()) return pl.EXTERIOR;\n      var r = n.getExteriorRing(),\n        i = this.locateInPolygonRing(e, r);\n      if (i === pl.EXTERIOR) return pl.EXTERIOR;\n      if (i === pl.BOUNDARY) return pl.BOUNDARY;\n      for (var o = 0; o < n.getNumInteriorRing(); o++) {\n        var s = n.getInteriorRingN(o),\n          a = t.locateInPolygonRing(e, s);\n        if (a === pl.INTERIOR) return pl.EXTERIOR;\n        if (a === pl.BOUNDARY) return pl.BOUNDARY;\n      }\n      return pl.INTERIOR;\n    }\n    if (arguments[0] instanceof ul && arguments[1] instanceof Zc) {\n      var u = arguments[0],\n        l = arguments[1];\n      if (!l.getEnvelopeInternal().intersects(u)) return pl.EXTERIOR;\n      var c = l.getCoordinates();\n      return l.isClosed() || !u.equals(c[0]) && !u.equals(c[c.length - 1]) ? Xl.isOnLine(u, c) ? pl.INTERIOR : pl.EXTERIOR : pl.BOUNDARY;\n    }\n    if (arguments[0] instanceof ul && arguments[1] instanceof Qc) {\n      var h = arguments[0],\n        p = arguments[1],\n        f = p.getCoordinate();\n      return f.equals2D(h) ? pl.INTERIOR : pl.EXTERIOR;\n    }\n  }, Pf.prototype.locateInPolygonRing = function (t, e) {\n    return e.getEnvelopeInternal().intersects(t) ? Xl.locatePointInRing(t, e.getCoordinates()) : pl.EXTERIOR;\n  }, Pf.prototype.intersects = function (t, e) {\n    return this.locate(t, e) !== pl.EXTERIOR;\n  }, Pf.prototype.updateLocationInfo = function (t) {\n    t === pl.INTERIOR && (this._isIn = !0), t === pl.BOUNDARY && this._numBoundaries++;\n  }, Pf.prototype.computeLocation = function (t, e) {\n    var n = this;\n    if (e instanceof Qc && this.updateLocationInfo(this.locateInternal(t, e)), e instanceof Zc) this.updateLocationInfo(this.locateInternal(t, e));else if (e instanceof th) this.updateLocationInfo(this.locateInternal(t, e));else if (e instanceof Gc) for (var r = e, i = 0; i < r.getNumGeometries(); i++) {\n      var o = r.getGeometryN(i);\n      n.updateLocationInfo(n.locateInternal(t, o));\n    } else if (e instanceof rh) for (var s = e, a = 0; a < s.getNumGeometries(); a++) {\n      var u = s.getGeometryN(a);\n      n.updateLocationInfo(n.locateInternal(t, u));\n    } else if (e instanceof kc) for (var l = new Up(e); l.hasNext();) {\n      var c = l.next();\n      c !== e && n.computeLocation(t, c);\n    }\n  }, Pf.prototype.locate = function (t, e) {\n    return e.isEmpty() ? pl.EXTERIOR : e instanceof Zc || e instanceof th ? this.locateInternal(t, e) : (this._isIn = !1, this._numBoundaries = 0, this.computeLocation(t, e), this._boundaryRule.isInBoundary(this._numBoundaries) ? pl.BOUNDARY : this._numBoundaries > 0 || this._isIn ? pl.INTERIOR : pl.EXTERIOR);\n  }, Pf.prototype.interfaces_ = function () {\n    return [];\n  }, Pf.prototype.getClass = function () {\n    return Pf;\n  };\n  var Mf = function t() {\n      if (this._component = null, this._segIndex = null, this._pt = null, 2 === arguments.length) {\n        var e = arguments[0],\n          n = arguments[1];\n        t.call(this, e, t.INSIDE_AREA, n);\n      } else if (3 === arguments.length) {\n        var r = arguments[0],\n          i = arguments[1],\n          o = arguments[2];\n        this._component = r, this._segIndex = i, this._pt = o;\n      }\n    },\n    Lf = {\n      INSIDE_AREA: {\n        configurable: !0\n      }\n    };\n  Mf.prototype.isInsideArea = function () {\n    return this._segIndex === Mf.INSIDE_AREA;\n  }, Mf.prototype.getCoordinate = function () {\n    return this._pt;\n  }, Mf.prototype.getGeometryComponent = function () {\n    return this._component;\n  }, Mf.prototype.getSegmentIndex = function () {\n    return this._segIndex;\n  }, Mf.prototype.interfaces_ = function () {\n    return [];\n  }, Mf.prototype.getClass = function () {\n    return Mf;\n  }, Lf.INSIDE_AREA.get = function () {\n    return -1;\n  }, Object.defineProperties(Mf, Lf);\n  var Of = function Of(t) {\n    this._pts = t || null;\n  };\n  Of.prototype.filter = function (t) {\n    t instanceof Qc && this._pts.add(t);\n  }, Of.prototype.interfaces_ = function () {\n    return [Dc];\n  }, Of.prototype.getClass = function () {\n    return Of;\n  }, Of.getPoints = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return t instanceof Qc ? np.singletonList(t) : Of.getPoints(t, new lc());\n    }\n    if (2 === arguments.length) {\n      var e = arguments[0],\n        n = arguments[1];\n      return e instanceof Qc ? n.add(e) : e instanceof kc && e.apply(new Of(n)), n;\n    }\n  };\n  var Rf = function Rf() {\n    this._locations = null;\n    var t = arguments[0];\n    this._locations = t;\n  };\n  Rf.prototype.filter = function (t) {\n    (t instanceof Qc || t instanceof Zc || t instanceof th) && this._locations.add(new Mf(t, 0, t.getCoordinate()));\n  }, Rf.prototype.interfaces_ = function () {\n    return [Dc];\n  }, Rf.prototype.getClass = function () {\n    return Rf;\n  }, Rf.getLocations = function (t) {\n    var e = new lc();\n    return t.apply(new Rf(e)), e;\n  };\n  var Tf = function Tf() {\n    if (this._geom = null, this._terminateDistance = 0, this._ptLocator = new Pf(), this._minDistanceLocation = null, this._minDistance = nl.MAX_VALUE, 2 === arguments.length) {\n      var t = arguments[0],\n        e = arguments[1];\n      this._geom = [t, e], this._terminateDistance = 0;\n    } else if (3 === arguments.length) {\n      var n = arguments[0],\n        r = arguments[1],\n        i = arguments[2];\n      this._geom = new Array(2).fill(null), this._geom[0] = n, this._geom[1] = r, this._terminateDistance = i;\n    }\n  };\n  Tf.prototype.computeContainmentDistance = function () {\n    var t = this;\n    if (0 === arguments.length) {\n      var e = new Array(2).fill(null);\n      if (this.computeContainmentDistance(0, e), this._minDistance <= this._terminateDistance) return null;\n      this.computeContainmentDistance(1, e);\n    } else if (2 === arguments.length) {\n      var n = arguments[0],\n        r = arguments[1],\n        i = 1 - n,\n        o = Sf.getPolygons(this._geom[n]);\n      if (o.size() > 0) {\n        var s = Rf.getLocations(this._geom[i]);\n        if (this.computeContainmentDistance(s, o, r), this._minDistance <= this._terminateDistance) return this._minDistanceLocation[i] = r[0], this._minDistanceLocation[n] = r[1], null;\n      }\n    } else if (3 === arguments.length) if (arguments[2] instanceof Array && gl(arguments[0], ac) && gl(arguments[1], ac)) {\n      for (var a = arguments[0], u = arguments[1], l = arguments[2], c = 0; c < a.size(); c++) for (var h = a.get(c), p = 0; p < u.size(); p++) if (t.computeContainmentDistance(h, u.get(p), l), t._minDistance <= t._terminateDistance) return null;\n    } else if (arguments[2] instanceof Array && arguments[0] instanceof Mf && arguments[1] instanceof th) {\n      var f = arguments[0],\n        g = arguments[1],\n        d = arguments[2],\n        y = f.getCoordinate();\n      if (pl.EXTERIOR !== this._ptLocator.locate(y, g)) return this._minDistance = 0, d[0] = f, d[1] = new Mf(g, y), null;\n    }\n  }, Tf.prototype.computeMinDistanceLinesPoints = function (t, e, n) {\n    for (var r = this, i = 0; i < t.size(); i++) for (var o = t.get(i), s = 0; s < e.size(); s++) {\n      var a = e.get(s);\n      if (r.computeMinDistance(o, a, n), r._minDistance <= r._terminateDistance) return null;\n    }\n  }, Tf.prototype.computeFacetDistance = function () {\n    var t = new Array(2).fill(null),\n      e = Cf.getLines(this._geom[0]),\n      n = Cf.getLines(this._geom[1]),\n      r = Of.getPoints(this._geom[0]),\n      i = Of.getPoints(this._geom[1]);\n    return this.computeMinDistanceLines(e, n, t), this.updateMinDistance(t, !1), this._minDistance <= this._terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(e, i, t), this.updateMinDistance(t, !1), this._minDistance <= this._terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(n, r, t), this.updateMinDistance(t, !0), this._minDistance <= this._terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistancePoints(r, i, t), void this.updateMinDistance(t, !1))));\n  }, Tf.prototype.nearestLocations = function () {\n    return this.computeMinDistance(), this._minDistanceLocation;\n  }, Tf.prototype.updateMinDistance = function (t, e) {\n    if (null === t[0]) return null;\n    e ? (this._minDistanceLocation[0] = t[1], this._minDistanceLocation[1] = t[0]) : (this._minDistanceLocation[0] = t[0], this._minDistanceLocation[1] = t[1]);\n  }, Tf.prototype.nearestPoints = function () {\n    return this.computeMinDistance(), [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()];\n  }, Tf.prototype.computeMinDistance = function () {\n    var t = this;\n    if (0 === arguments.length) {\n      if (null !== this._minDistanceLocation) return null;\n      if (this._minDistanceLocation = new Array(2).fill(null), this.computeContainmentDistance(), this._minDistance <= this._terminateDistance) return null;\n      this.computeFacetDistance();\n    } else if (3 === arguments.length) if (arguments[2] instanceof Array && arguments[0] instanceof Zc && arguments[1] instanceof Qc) {\n      var e = arguments[0],\n        n = arguments[1],\n        r = arguments[2];\n      if (e.getEnvelopeInternal().distance(n.getEnvelopeInternal()) > this._minDistance) return null;\n      for (var i = e.getCoordinates(), o = n.getCoordinate(), s = 0; s < i.length - 1; s++) {\n        var a = Xl.distancePointLine(o, i[s], i[s + 1]);\n        if (a < t._minDistance) {\n          t._minDistance = a;\n          var u = new vp(i[s], i[s + 1]),\n            l = u.closestPoint(o);\n          r[0] = new Mf(e, s, l), r[1] = new Mf(n, 0, o);\n        }\n        if (t._minDistance <= t._terminateDistance) return null;\n      }\n    } else if (arguments[2] instanceof Array && arguments[0] instanceof Zc && arguments[1] instanceof Zc) {\n      var c = arguments[0],\n        h = arguments[1],\n        p = arguments[2];\n      if (c.getEnvelopeInternal().distance(h.getEnvelopeInternal()) > this._minDistance) return null;\n      for (var f = c.getCoordinates(), g = h.getCoordinates(), d = 0; d < f.length - 1; d++) for (var y = 0; y < g.length - 1; y++) {\n        var v = Xl.distanceLineLine(f[d], f[d + 1], g[y], g[y + 1]);\n        if (v < t._minDistance) {\n          t._minDistance = v;\n          var _ = new vp(f[d], f[d + 1]),\n            m = new vp(g[y], g[y + 1]),\n            x = _.closestPoints(m);\n          p[0] = new Mf(c, d, x[0]), p[1] = new Mf(h, y, x[1]);\n        }\n        if (t._minDistance <= t._terminateDistance) return null;\n      }\n    }\n  }, Tf.prototype.computeMinDistancePoints = function (t, e, n) {\n    for (var r = this, i = 0; i < t.size(); i++) for (var o = t.get(i), s = 0; s < e.size(); s++) {\n      var a = e.get(s),\n        u = o.getCoordinate().distance(a.getCoordinate());\n      if (u < r._minDistance && (r._minDistance = u, n[0] = new Mf(o, 0, o.getCoordinate()), n[1] = new Mf(a, 0, a.getCoordinate())), r._minDistance <= r._terminateDistance) return null;\n    }\n  }, Tf.prototype.distance = function () {\n    if (null === this._geom[0] || null === this._geom[1]) throw new el(\"null geometries are not supported\");\n    return this._geom[0].isEmpty() || this._geom[1].isEmpty() ? 0 : (this.computeMinDistance(), this._minDistance);\n  }, Tf.prototype.computeMinDistanceLines = function (t, e, n) {\n    for (var r = this, i = 0; i < t.size(); i++) for (var o = t.get(i), s = 0; s < e.size(); s++) {\n      var a = e.get(s);\n      if (r.computeMinDistance(o, a, n), r._minDistance <= r._terminateDistance) return null;\n    }\n  }, Tf.prototype.interfaces_ = function () {\n    return [];\n  }, Tf.prototype.getClass = function () {\n    return Tf;\n  }, Tf.distance = function (t, e) {\n    return new Tf(t, e).distance();\n  }, Tf.isWithinDistance = function (t, e, n) {\n    return new Tf(t, e, n).distance() <= n;\n  }, Tf.nearestPoints = function (t, e) {\n    return new Tf(t, e).nearestPoints();\n  };\n  var Af = function Af() {\n    this._pt = [new ul(), new ul()], this._distance = nl.NaN, this._isNull = !0;\n  };\n  Af.prototype.getCoordinates = function () {\n    return this._pt;\n  }, Af.prototype.getCoordinate = function (t) {\n    return this._pt[t];\n  }, Af.prototype.setMinimum = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      this.setMinimum(t._pt[0], t._pt[1]);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n        n = arguments[1];\n      if (this._isNull) return this.initialize(e, n), null;\n      var r = e.distance(n);\n      r < this._distance && this.initialize(e, n, r);\n    }\n  }, Af.prototype.initialize = function () {\n    if (0 === arguments.length) this._isNull = !0;else if (2 === arguments.length) {\n      var t = arguments[0],\n        e = arguments[1];\n      this._pt[0].setCoordinate(t), this._pt[1].setCoordinate(e), this._distance = t.distance(e), this._isNull = !1;\n    } else if (3 === arguments.length) {\n      var n = arguments[0],\n        r = arguments[1],\n        i = arguments[2];\n      this._pt[0].setCoordinate(n), this._pt[1].setCoordinate(r), this._distance = i, this._isNull = !1;\n    }\n  }, Af.prototype.toString = function () {\n    return Fl.toLineString(this._pt[0], this._pt[1]);\n  }, Af.prototype.getDistance = function () {\n    return this._distance;\n  }, Af.prototype.setMaximum = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      this.setMaximum(t._pt[0], t._pt[1]);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n        n = arguments[1];\n      if (this._isNull) return this.initialize(e, n), null;\n      var r = e.distance(n);\n      r > this._distance && this.initialize(e, n, r);\n    }\n  }, Af.prototype.interfaces_ = function () {\n    return [];\n  }, Af.prototype.getClass = function () {\n    return Af;\n  };\n  var Df = function Df() {};\n  Df.prototype.interfaces_ = function () {\n    return [];\n  }, Df.prototype.getClass = function () {\n    return Df;\n  }, Df.computeDistance = function () {\n    if (arguments[2] instanceof Af && arguments[0] instanceof Zc && arguments[1] instanceof ul) for (var t = arguments[0], e = arguments[1], n = arguments[2], r = new vp(), i = t.getCoordinates(), o = 0; o < i.length - 1; o++) {\n      r.setCoordinates(i[o], i[o + 1]);\n      var s = r.closestPoint(e);\n      n.setMinimum(s, e);\n    } else if (arguments[2] instanceof Af && arguments[0] instanceof th && arguments[1] instanceof ul) {\n      var a = arguments[0],\n        u = arguments[1],\n        l = arguments[2];\n      Df.computeDistance(a.getExteriorRing(), u, l);\n      for (var c = 0; c < a.getNumInteriorRing(); c++) Df.computeDistance(a.getInteriorRingN(c), u, l);\n    } else if (arguments[2] instanceof Af && arguments[0] instanceof Wl && arguments[1] instanceof ul) {\n      var h = arguments[0],\n        p = arguments[1],\n        f = arguments[2];\n      if (h instanceof Zc) Df.computeDistance(h, p, f);else if (h instanceof th) Df.computeDistance(h, p, f);else if (h instanceof kc) for (var g = h, d = 0; d < g.getNumGeometries(); d++) {\n        var y = g.getGeometryN(d);\n        Df.computeDistance(y, p, f);\n      } else f.setMinimum(h.getCoordinate(), p);\n    } else if (arguments[2] instanceof Af && arguments[0] instanceof vp && arguments[1] instanceof ul) {\n      var v = arguments[0],\n        _ = arguments[1],\n        m = arguments[2],\n        x = v.closestPoint(_);\n      m.setMinimum(x, _);\n    }\n  };\n  var Ff = function Ff() {\n      this._g0 = null, this._g1 = null, this._ptDist = new Af(), this._densifyFrac = 0;\n      var t = arguments[0],\n        e = arguments[1];\n      this._g0 = t, this._g1 = e;\n    },\n    kf = {\n      MaxPointDistanceFilter: {\n        configurable: !0\n      },\n      MaxDensifiedByFractionDistanceFilter: {\n        configurable: !0\n      }\n    };\n  Ff.prototype.getCoordinates = function () {\n    return this._ptDist.getCoordinates();\n  }, Ff.prototype.setDensifyFraction = function (t) {\n    if (t > 1 || t <= 0) throw new el(\"Fraction is not in range (0.0 - 1.0]\");\n    this._densifyFrac = t;\n  }, Ff.prototype.compute = function (t, e) {\n    this.computeOrientedDistance(t, e, this._ptDist), this.computeOrientedDistance(e, t, this._ptDist);\n  }, Ff.prototype.distance = function () {\n    return this.compute(this._g0, this._g1), this._ptDist.getDistance();\n  }, Ff.prototype.computeOrientedDistance = function (t, e, n) {\n    var r = new Gf(e);\n    if (t.apply(r), n.setMaximum(r.getMaxPointDistance()), this._densifyFrac > 0) {\n      var i = new qf(e, this._densifyFrac);\n      t.apply(i), n.setMaximum(i.getMaxPointDistance());\n    }\n  }, Ff.prototype.orientedDistance = function () {\n    return this.computeOrientedDistance(this._g0, this._g1, this._ptDist), this._ptDist.getDistance();\n  }, Ff.prototype.interfaces_ = function () {\n    return [];\n  }, Ff.prototype.getClass = function () {\n    return Ff;\n  }, Ff.distance = function () {\n    if (2 === arguments.length) {\n      var t = arguments[0],\n        e = arguments[1],\n        n = new Ff(t, e);\n      return n.distance();\n    }\n    if (3 === arguments.length) {\n      var r = arguments[0],\n        i = arguments[1],\n        o = arguments[2],\n        s = new Ff(r, i);\n      return s.setDensifyFraction(o), s.distance();\n    }\n  }, kf.MaxPointDistanceFilter.get = function () {\n    return Gf;\n  }, kf.MaxDensifiedByFractionDistanceFilter.get = function () {\n    return qf;\n  }, Object.defineProperties(Ff, kf);\n  var Gf = function Gf() {\n    this._maxPtDist = new Af(), this._minPtDist = new Af(), this._euclideanDist = new Df(), this._geom = null;\n    var t = arguments[0];\n    this._geom = t;\n  };\n  Gf.prototype.filter = function (t) {\n    this._minPtDist.initialize(), Df.computeDistance(this._geom, t, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);\n  }, Gf.prototype.getMaxPointDistance = function () {\n    return this._maxPtDist;\n  }, Gf.prototype.interfaces_ = function () {\n    return [Kl];\n  }, Gf.prototype.getClass = function () {\n    return Gf;\n  };\n  var qf = function qf() {\n    this._maxPtDist = new Af(), this._minPtDist = new Af(), this._geom = null, this._numSubSegs = 0;\n    var t = arguments[0],\n      e = arguments[1];\n    this._geom = t, this._numSubSegs = Math.trunc(Math.round(1 / e));\n  };\n  qf.prototype.filter = function (t, e) {\n    var n = this;\n    if (0 === e) return null;\n    for (var r = t.getCoordinate(e - 1), i = t.getCoordinate(e), o = (i.x - r.x) / this._numSubSegs, s = (i.y - r.y) / this._numSubSegs, a = 0; a < this._numSubSegs; a++) {\n      var u = r.x + a * o,\n        l = r.y + a * s,\n        c = new ul(u, l);\n      n._minPtDist.initialize(), Df.computeDistance(n._geom, c, n._minPtDist), n._maxPtDist.setMaximum(n._minPtDist);\n    }\n  }, qf.prototype.isDone = function () {\n    return !1;\n  }, qf.prototype.isGeometryChanged = function () {\n    return !1;\n  }, qf.prototype.getMaxPointDistance = function () {\n    return this._maxPtDist;\n  }, qf.prototype.interfaces_ = function () {\n    return [Fc];\n  }, qf.prototype.getClass = function () {\n    return qf;\n  };\n  var Bf = function Bf(t, e, n) {\n      this._minValidDistance = null, this._maxValidDistance = null, this._minDistanceFound = null, this._maxDistanceFound = null, this._isValid = !0, this._errMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = t || null, this._bufDistance = e || null, this._result = n || null;\n    },\n    zf = {\n      VERBOSE: {\n        configurable: !0\n      },\n      MAX_DISTANCE_DIFF_FRAC: {\n        configurable: !0\n      }\n    };\n  Bf.prototype.checkMaximumDistance = function (t, e, n) {\n    var r = new Ff(e, t);\n    if (r.setDensifyFraction(.25), this._maxDistanceFound = r.orientedDistance(), this._maxDistanceFound > n) {\n      this._isValid = !1;\n      var i = r.getCoordinates();\n      this._errorLocation = i[1], this._errorIndicator = t.getFactory().createLineString(i), this._errMsg = \"Distance between buffer curve and input is too large (\" + this._maxDistanceFound + \" at \" + Fl.toLineString(i[0], i[1]) + \")\";\n    }\n  }, Bf.prototype.isValid = function () {\n    var t = Math.abs(this._bufDistance),\n      e = Bf.MAX_DISTANCE_DIFF_FRAC * t;\n    return this._minValidDistance = t - e, this._maxValidDistance = t + e, !(!this._input.isEmpty() && !this._result.isEmpty()) || (this._bufDistance > 0 ? this.checkPositiveValid() : this.checkNegativeValid(), Bf.VERBOSE && Pl.out.println(\"Min Dist= \" + this._minDistanceFound + \"  err= \" + (1 - this._minDistanceFound / this._bufDistance) + \"  Max Dist= \" + this._maxDistanceFound + \"  err= \" + (this._maxDistanceFound / this._bufDistance - 1)), this._isValid);\n  }, Bf.prototype.checkNegativeValid = function () {\n    if (!(this._input instanceof th || this._input instanceof rh || this._input instanceof kc)) return null;\n    var t = this.getPolygonLines(this._input);\n    if (this.checkMinimumDistance(t, this._result, this._minValidDistance), !this._isValid) return null;\n    this.checkMaximumDistance(t, this._result, this._maxValidDistance);\n  }, Bf.prototype.getErrorIndicator = function () {\n    return this._errorIndicator;\n  }, Bf.prototype.checkMinimumDistance = function (t, e, n) {\n    var r = new Tf(t, e, n);\n    if (this._minDistanceFound = r.distance(), this._minDistanceFound < n) {\n      this._isValid = !1;\n      var i = r.nearestPoints();\n      this._errorLocation = r.nearestPoints()[1], this._errorIndicator = t.getFactory().createLineString(i), this._errMsg = \"Distance between buffer curve and input is too small (\" + this._minDistanceFound + \" at \" + Fl.toLineString(i[0], i[1]) + \" )\";\n    }\n  }, Bf.prototype.checkPositiveValid = function () {\n    var t = this._result.getBoundary();\n    if (this.checkMinimumDistance(this._input, t, this._minValidDistance), !this._isValid) return null;\n    this.checkMaximumDistance(this._input, t, this._maxValidDistance);\n  }, Bf.prototype.getErrorLocation = function () {\n    return this._errorLocation;\n  }, Bf.prototype.getPolygonLines = function (t) {\n    for (var e = new lc(), n = new Cf(e), r = Sf.getPolygons(t).iterator(); r.hasNext();) {\n      r.next().apply(n);\n    }\n    return t.getFactory().buildGeometry(e);\n  }, Bf.prototype.getErrorMessage = function () {\n    return this._errMsg;\n  }, Bf.prototype.interfaces_ = function () {\n    return [];\n  }, Bf.prototype.getClass = function () {\n    return Bf;\n  }, zf.VERBOSE.get = function () {\n    return !1;\n  }, zf.MAX_DISTANCE_DIFF_FRAC.get = function () {\n    return .012;\n  }, Object.defineProperties(Bf, zf);\n  var jf = function jf(t, e, n) {\n      this._isValid = !0, this._errorMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = t || null, this._distance = e || null, this._result = n || null;\n    },\n    Uf = {\n      VERBOSE: {\n        configurable: !0\n      },\n      MAX_ENV_DIFF_FRAC: {\n        configurable: !0\n      }\n    };\n  jf.prototype.isValid = function () {\n    return this.checkPolygonal(), this._isValid ? (this.checkExpectedEmpty(), this._isValid ? (this.checkEnvelope(), this._isValid ? (this.checkArea(), this._isValid ? (this.checkDistance(), this._isValid) : this._isValid) : this._isValid) : this._isValid) : this._isValid;\n  }, jf.prototype.checkEnvelope = function () {\n    if (this._distance < 0) return null;\n    var t = this._distance * jf.MAX_ENV_DIFF_FRAC;\n    0 === t && (t = .001);\n    var e = new Ll(this._input.getEnvelopeInternal());\n    e.expandBy(this._distance);\n    var n = new Ll(this._result.getEnvelopeInternal());\n    n.expandBy(t), n.contains(e) || (this._isValid = !1, this._errorMsg = \"Buffer envelope is incorrect\", this._errorIndicator = this._input.getFactory().toGeometry(n)), this.report(\"Envelope\");\n  }, jf.prototype.checkDistance = function () {\n    var t = new Bf(this._input, this._distance, this._result);\n    t.isValid() || (this._isValid = !1, this._errorMsg = t.getErrorMessage(), this._errorLocation = t.getErrorLocation(), this._errorIndicator = t.getErrorIndicator()), this.report(\"Distance\");\n  }, jf.prototype.checkArea = function () {\n    var t = this._input.getArea(),\n      e = this._result.getArea();\n    this._distance > 0 && t > e && (this._isValid = !1, this._errorMsg = \"Area of positive buffer is smaller than input\", this._errorIndicator = this._result), this._distance < 0 && t < e && (this._isValid = !1, this._errorMsg = \"Area of negative buffer is larger than input\", this._errorIndicator = this._result), this.report(\"Area\");\n  }, jf.prototype.checkPolygonal = function () {\n    this._result instanceof th || this._result instanceof rh || (this._isValid = !1), this._errorMsg = \"Result is not polygonal\", this._errorIndicator = this._result, this.report(\"Polygonal\");\n  }, jf.prototype.getErrorIndicator = function () {\n    return this._errorIndicator;\n  }, jf.prototype.getErrorLocation = function () {\n    return this._errorLocation;\n  }, jf.prototype.checkExpectedEmpty = function () {\n    return this._input.getDimension() >= 2 || this._distance > 0 ? null : (this._result.isEmpty() || (this._isValid = !1, this._errorMsg = \"Result is non-empty\", this._errorIndicator = this._result), void this.report(\"ExpectedEmpty\"));\n  }, jf.prototype.report = function (t) {\n    if (!jf.VERBOSE) return null;\n    Pl.out.println(\"Check \" + t + \": \" + (this._isValid ? \"passed\" : \"FAILED\"));\n  }, jf.prototype.getErrorMessage = function () {\n    return this._errorMsg;\n  }, jf.prototype.interfaces_ = function () {\n    return [];\n  }, jf.prototype.getClass = function () {\n    return jf;\n  }, jf.isValidMsg = function (t, e, n) {\n    var r = new jf(t, e, n);\n    return r.isValid() ? null : r.getErrorMessage();\n  }, jf.isValid = function (t, e, n) {\n    return !!new jf(t, e, n).isValid();\n  }, Uf.VERBOSE.get = function () {\n    return !1;\n  }, Uf.MAX_ENV_DIFF_FRAC.get = function () {\n    return .012;\n  }, Object.defineProperties(jf, Uf);\n  var Vf = function Vf() {\n    this._pts = null, this._data = null;\n    var t = arguments[0],\n      e = arguments[1];\n    this._pts = t, this._data = e;\n  };\n  Vf.prototype.getCoordinates = function () {\n    return this._pts;\n  }, Vf.prototype.size = function () {\n    return this._pts.length;\n  }, Vf.prototype.getCoordinate = function (t) {\n    return this._pts[t];\n  }, Vf.prototype.isClosed = function () {\n    return this._pts[0].equals(this._pts[this._pts.length - 1]);\n  }, Vf.prototype.getSegmentOctant = function (t) {\n    return t === this._pts.length - 1 ? -1 : fp.octant(this.getCoordinate(t), this.getCoordinate(t + 1));\n  }, Vf.prototype.setData = function (t) {\n    this._data = t;\n  }, Vf.prototype.getData = function () {\n    return this._data;\n  }, Vf.prototype.toString = function () {\n    return Fl.toLineString(new lh(this._pts));\n  }, Vf.prototype.interfaces_ = function () {\n    return [gp];\n  }, Vf.prototype.getClass = function () {\n    return Vf;\n  };\n  var Xf = function Xf() {\n    this._findAllIntersections = !1, this._isCheckEndSegmentsOnly = !1, this._li = null, this._interiorIntersection = null, this._intSegments = null, this._intersections = new lc(), this._intersectionCount = 0, this._keepIntersections = !0;\n    var t = arguments[0];\n    this._li = t, this._interiorIntersection = null;\n  };\n  Xf.prototype.getInteriorIntersection = function () {\n    return this._interiorIntersection;\n  }, Xf.prototype.setCheckEndSegmentsOnly = function (t) {\n    this._isCheckEndSegmentsOnly = t;\n  }, Xf.prototype.getIntersectionSegments = function () {\n    return this._intSegments;\n  }, Xf.prototype.count = function () {\n    return this._intersectionCount;\n  }, Xf.prototype.getIntersections = function () {\n    return this._intersections;\n  }, Xf.prototype.setFindAllIntersections = function (t) {\n    this._findAllIntersections = t;\n  }, Xf.prototype.setKeepIntersections = function (t) {\n    this._keepIntersections = t;\n  }, Xf.prototype.processIntersections = function (t, e, n, r) {\n    if (!this._findAllIntersections && this.hasIntersection()) return null;\n    if (t === n && e === r) return null;\n    if (this._isCheckEndSegmentsOnly && !(this.isEndSegment(t, e) || this.isEndSegment(n, r))) return null;\n    var i = t.getCoordinates()[e],\n      o = t.getCoordinates()[e + 1],\n      s = n.getCoordinates()[r],\n      a = n.getCoordinates()[r + 1];\n    this._li.computeIntersection(i, o, s, a), this._li.hasIntersection() && this._li.isInteriorIntersection() && (this._intSegments = new Array(4).fill(null), this._intSegments[0] = i, this._intSegments[1] = o, this._intSegments[2] = s, this._intSegments[3] = a, this._interiorIntersection = this._li.getIntersection(0), this._keepIntersections && this._intersections.add(this._interiorIntersection), this._intersectionCount++);\n  }, Xf.prototype.isEndSegment = function (t, e) {\n    return 0 === e || e >= t.size() - 2;\n  }, Xf.prototype.hasIntersection = function () {\n    return null !== this._interiorIntersection;\n  }, Xf.prototype.isDone = function () {\n    return !this._findAllIntersections && null !== this._interiorIntersection;\n  }, Xf.prototype.interfaces_ = function () {\n    return [Zp];\n  }, Xf.prototype.getClass = function () {\n    return Xf;\n  }, Xf.createAllIntersectionsFinder = function (t) {\n    var e = new Xf(t);\n    return e.setFindAllIntersections(!0), e;\n  }, Xf.createAnyIntersectionFinder = function (t) {\n    return new Xf(t);\n  }, Xf.createIntersectionCounter = function (t) {\n    var e = new Xf(t);\n    return e.setFindAllIntersections(!0), e.setKeepIntersections(!1), e;\n  };\n  var Yf = function Yf() {\n    this._li = new jl(), this._segStrings = null, this._findAllIntersections = !1, this._segInt = null, this._isValid = !0;\n    var t = arguments[0];\n    this._segStrings = t;\n  };\n  Yf.prototype.execute = function () {\n    if (null !== this._segInt) return null;\n    this.checkInteriorIntersections();\n  }, Yf.prototype.getIntersections = function () {\n    return this._segInt.getIntersections();\n  }, Yf.prototype.isValid = function () {\n    return this.execute(), this._isValid;\n  }, Yf.prototype.setFindAllIntersections = function (t) {\n    this._findAllIntersections = t;\n  }, Yf.prototype.checkInteriorIntersections = function () {\n    this._isValid = !0, this._segInt = new Xf(this._li), this._segInt.setFindAllIntersections(this._findAllIntersections);\n    var t = new Ip();\n    if (t.setSegmentIntersector(this._segInt), t.computeNodes(this._segStrings), this._segInt.hasIntersection()) return this._isValid = !1, null;\n  }, Yf.prototype.checkValid = function () {\n    if (this.execute(), !this._isValid) throw new Oh(this.getErrorMessage(), this._segInt.getInteriorIntersection());\n  }, Yf.prototype.getErrorMessage = function () {\n    if (this._isValid) return \"no intersections found\";\n    var t = this._segInt.getIntersectionSegments();\n    return \"found non-noded intersection between \" + Fl.toLineString(t[0], t[1]) + \" and \" + Fl.toLineString(t[2], t[3]);\n  }, Yf.prototype.interfaces_ = function () {\n    return [];\n  }, Yf.prototype.getClass = function () {\n    return Yf;\n  }, Yf.computeIntersections = function (t) {\n    var e = new Yf(t);\n    return e.setFindAllIntersections(!0), e.isValid(), e.getIntersections();\n  };\n  var Hf = function t() {\n    this._nv = null;\n    var e = arguments[0];\n    this._nv = new Yf(t.toSegmentStrings(e));\n  };\n  Hf.prototype.checkValid = function () {\n    this._nv.checkValid();\n  }, Hf.prototype.interfaces_ = function () {\n    return [];\n  }, Hf.prototype.getClass = function () {\n    return Hf;\n  }, Hf.toSegmentStrings = function (t) {\n    for (var e = new lc(), n = t.iterator(); n.hasNext();) {\n      var r = n.next();\n      e.add(new Vf(r.getCoordinates(), r));\n    }\n    return e;\n  }, Hf.checkValid = function (t) {\n    new Hf(t).checkValid();\n  };\n  var Wf = function Wf(t) {\n    this._mapOp = t;\n  };\n  Wf.prototype.map = function (t) {\n    for (var e = new lc(), n = 0; n < t.getNumGeometries(); n++) {\n      var r = this._mapOp.map(t.getGeometryN(n));\n      r.isEmpty() || e.add(r);\n    }\n    return t.getFactory().createGeometryCollection(_h.toGeometryArray(e));\n  }, Wf.prototype.interfaces_ = function () {\n    return [];\n  }, Wf.prototype.getClass = function () {\n    return Wf;\n  }, Wf.map = function (t, e) {\n    return new Wf(e).map(t);\n  };\n  var Jf = function Jf() {\n    this._op = null, this._geometryFactory = null, this._ptLocator = null, this._lineEdgesList = new lc(), this._resultLineList = new lc();\n    var t = arguments[0],\n      e = arguments[1],\n      n = arguments[2];\n    this._op = t, this._geometryFactory = e, this._ptLocator = n;\n  };\n  Jf.prototype.collectLines = function (t) {\n    for (var e = this, n = this._op.getGraph().getEdgeEnds().iterator(); n.hasNext();) {\n      var r = n.next();\n      e.collectLineEdge(r, t, e._lineEdgesList), e.collectBoundaryTouchEdge(r, t, e._lineEdgesList);\n    }\n  }, Jf.prototype.labelIsolatedLine = function (t, e) {\n    var n = this._ptLocator.locate(t.getCoordinate(), this._op.getArgGeometry(e));\n    t.getLabel().setLocation(e, n);\n  }, Jf.prototype.build = function (t) {\n    return this.findCoveredLineEdges(), this.collectLines(t), this.buildLines(t), this._resultLineList;\n  }, Jf.prototype.collectLineEdge = function (t, e, n) {\n    var r = t.getLabel(),\n      i = t.getEdge();\n    t.isLineEdge() && (t.isVisited() || !Mg.isResultOfOp(r, e) || i.isCovered() || (n.add(i), t.setVisitedEdge(!0)));\n  }, Jf.prototype.findCoveredLineEdges = function () {\n    for (var t = this._op.getGraph().getNodes().iterator(); t.hasNext();) {\n      t.next().getEdges().findCoveredLineEdges();\n    }\n    for (var e = this._op.getGraph().getEdgeEnds().iterator(); e.hasNext();) {\n      var n = e.next(),\n        r = n.getEdge();\n      if (n.isLineEdge() && !r.isCoveredSet()) {\n        var i = this._op.isCoveredByA(n.getCoordinate());\n        r.setCovered(i);\n      }\n    }\n  }, Jf.prototype.labelIsolatedLines = function (t) {\n    for (var e = t.iterator(); e.hasNext();) {\n      var n = e.next(),\n        r = n.getLabel();\n      n.isIsolated() && (r.isNull(0) ? this.labelIsolatedLine(n, 0) : this.labelIsolatedLine(n, 1));\n    }\n  }, Jf.prototype.buildLines = function (t) {\n    for (var e = this._lineEdgesList.iterator(); e.hasNext();) {\n      var n = e.next(),\n        r = this._geometryFactory.createLineString(n.getCoordinates());\n      this._resultLineList.add(r), n.setInResult(!0);\n    }\n  }, Jf.prototype.collectBoundaryTouchEdge = function (t, e, n) {\n    var r = t.getLabel();\n    return t.isLineEdge() || t.isVisited() || t.isInteriorAreaEdge() || t.getEdge().isInResult() ? null : (ql.isTrue(!(t.isInResult() || t.getSym().isInResult()) || !t.getEdge().isInResult()), void (Mg.isResultOfOp(r, e) && e === Mg.INTERSECTION && (n.add(t.getEdge()), t.setVisitedEdge(!0))));\n  }, Jf.prototype.interfaces_ = function () {\n    return [];\n  }, Jf.prototype.getClass = function () {\n    return Jf;\n  };\n  var Zf = function Zf() {\n    this._op = null, this._geometryFactory = null, this._resultPointList = new lc();\n    var t = arguments[0],\n      e = arguments[1];\n    this._op = t, this._geometryFactory = e;\n  };\n  Zf.prototype.filterCoveredNodeToPoint = function (t) {\n    var e = t.getCoordinate();\n    if (!this._op.isCoveredByLA(e)) {\n      var n = this._geometryFactory.createPoint(e);\n      this._resultPointList.add(n);\n    }\n  }, Zf.prototype.extractNonCoveredResultNodes = function (t) {\n    for (var e = this._op.getGraph().getNodes().iterator(); e.hasNext();) {\n      var n = e.next();\n      if (!n.isInResult() && !n.isIncidentEdgeInResult() && (0 === n.getEdges().getDegree() || t === Mg.INTERSECTION)) {\n        var r = n.getLabel();\n        Mg.isResultOfOp(r, t) && this.filterCoveredNodeToPoint(n);\n      }\n    }\n  }, Zf.prototype.build = function (t) {\n    return this.extractNonCoveredResultNodes(t), this._resultPointList;\n  }, Zf.prototype.interfaces_ = function () {\n    return [];\n  }, Zf.prototype.getClass = function () {\n    return Zf;\n  };\n  var Kf = function Kf() {\n    this._inputGeom = null, this._factory = null, this._pruneEmptyGeometry = !0, this._preserveGeometryCollectionType = !0, this._preserveCollections = !1, this._preserveType = !1;\n  };\n  Kf.prototype.transformPoint = function (t, e) {\n    return this._factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(), t));\n  }, Kf.prototype.transformPolygon = function (t, e) {\n    var n = !0,\n      r = this.transformLinearRing(t.getExteriorRing(), t);\n    null !== r && r instanceof nh && !r.isEmpty() || (n = !1);\n    for (var i = new lc(), o = 0; o < t.getNumInteriorRing(); o++) {\n      var s = this.transformLinearRing(t.getInteriorRingN(o), t);\n      null === s || s.isEmpty() || (s instanceof nh || (n = !1), i.add(s));\n    }\n    if (n) return this._factory.createPolygon(r, i.toArray([]));\n    var a = new lc();\n    return null !== r && a.add(r), a.addAll(i), this._factory.buildGeometry(a);\n  }, Kf.prototype.createCoordinateSequence = function (t) {\n    return this._factory.getCoordinateSequenceFactory().create(t);\n  }, Kf.prototype.getInputGeometry = function () {\n    return this._inputGeom;\n  }, Kf.prototype.transformMultiLineString = function (t, e) {\n    for (var n = new lc(), r = 0; r < t.getNumGeometries(); r++) {\n      var i = this.transformLineString(t.getGeometryN(r), t);\n      null !== i && (i.isEmpty() || n.add(i));\n    }\n    return this._factory.buildGeometry(n);\n  }, Kf.prototype.transformCoordinates = function (t, e) {\n    return this.copy(t);\n  }, Kf.prototype.transformLineString = function (t, e) {\n    return this._factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(), t));\n  }, Kf.prototype.transformMultiPoint = function (t, e) {\n    for (var n = new lc(), r = 0; r < t.getNumGeometries(); r++) {\n      var i = this.transformPoint(t.getGeometryN(r), t);\n      null !== i && (i.isEmpty() || n.add(i));\n    }\n    return this._factory.buildGeometry(n);\n  }, Kf.prototype.transformMultiPolygon = function (t, e) {\n    for (var n = new lc(), r = 0; r < t.getNumGeometries(); r++) {\n      var i = this.transformPolygon(t.getGeometryN(r), t);\n      null !== i && (i.isEmpty() || n.add(i));\n    }\n    return this._factory.buildGeometry(n);\n  }, Kf.prototype.copy = function (t) {\n    return t.copy();\n  }, Kf.prototype.transformGeometryCollection = function (t, e) {\n    for (var n = new lc(), r = 0; r < t.getNumGeometries(); r++) {\n      var i = this.transform(t.getGeometryN(r));\n      null !== i && (this._pruneEmptyGeometry && i.isEmpty() || n.add(i));\n    }\n    return this._preserveGeometryCollectionType ? this._factory.createGeometryCollection(_h.toGeometryArray(n)) : this._factory.buildGeometry(n);\n  }, Kf.prototype.transform = function (t) {\n    if (this._inputGeom = t, this._factory = t.getFactory(), t instanceof Qc) return this.transformPoint(t, null);\n    if (t instanceof eh) return this.transformMultiPoint(t, null);\n    if (t instanceof nh) return this.transformLinearRing(t, null);\n    if (t instanceof Zc) return this.transformLineString(t, null);\n    if (t instanceof Gc) return this.transformMultiLineString(t, null);\n    if (t instanceof th) return this.transformPolygon(t, null);\n    if (t instanceof rh) return this.transformMultiPolygon(t, null);\n    if (t instanceof kc) return this.transformGeometryCollection(t, null);\n    throw new el(\"Unknown Geometry subtype: \" + t.getClass().getName());\n  }, Kf.prototype.transformLinearRing = function (t, e) {\n    var n = this.transformCoordinates(t.getCoordinateSequence(), t);\n    if (null === n) return this._factory.createLinearRing(null);\n    var r = n.size();\n    return r > 0 && r < 4 && !this._preserveType ? this._factory.createLineString(n) : this._factory.createLinearRing(n);\n  }, Kf.prototype.interfaces_ = function () {\n    return [];\n  }, Kf.prototype.getClass = function () {\n    return Kf;\n  };\n  var Qf = function t() {\n    if (this._snapTolerance = 0, this._srcPts = null, this._seg = new vp(), this._allowSnappingToSourceVertices = !1, this._isClosed = !1, arguments[0] instanceof Zc && \"number\" == typeof arguments[1]) {\n      var e = arguments[0],\n        n = arguments[1];\n      t.call(this, e.getCoordinates(), n);\n    } else if (arguments[0] instanceof Array && \"number\" == typeof arguments[1]) {\n      var r = arguments[0],\n        i = arguments[1];\n      this._srcPts = r, this._isClosed = t.isClosed(r), this._snapTolerance = i;\n    }\n  };\n  Qf.prototype.snapVertices = function (t, e) {\n    for (var n = this._isClosed ? t.size() - 1 : t.size(), r = 0; r < n; r++) {\n      var i = t.get(r),\n        o = this.findSnapForVertex(i, e);\n      null !== o && (t.set(r, new ul(o)), 0 === r && this._isClosed && t.set(t.size() - 1, new ul(o)));\n    }\n  }, Qf.prototype.findSnapForVertex = function (t, e) {\n    for (var n = 0; n < e.length; n++) {\n      if (t.equals2D(e[n])) return null;\n      if (t.distance(e[n]) < this._snapTolerance) return e[n];\n    }\n    return null;\n  }, Qf.prototype.snapTo = function (t) {\n    var e = new hc(this._srcPts);\n    return this.snapVertices(e, t), this.snapSegments(e, t), e.toCoordinateArray();\n  }, Qf.prototype.snapSegments = function (t, e) {\n    if (0 === e.length) return null;\n    var n = e.length;\n    e[0].equals2D(e[e.length - 1]) && (n = e.length - 1);\n    for (var r = 0; r < n; r++) {\n      var i = e[r],\n        o = this.findSegmentIndexToSnap(i, t);\n      o >= 0 && t.add(o + 1, new ul(i), !1);\n    }\n  }, Qf.prototype.findSegmentIndexToSnap = function (t, e) {\n    for (var n = this, r = nl.MAX_VALUE, i = -1, o = 0; o < e.size() - 1; o++) {\n      if (n._seg.p0 = e.get(o), n._seg.p1 = e.get(o + 1), n._seg.p0.equals2D(t) || n._seg.p1.equals2D(t)) {\n        if (n._allowSnappingToSourceVertices) continue;\n        return -1;\n      }\n      var s = n._seg.distance(t);\n      s < n._snapTolerance && s < r && (r = s, i = o);\n    }\n    return i;\n  }, Qf.prototype.setAllowSnappingToSourceVertices = function (t) {\n    this._allowSnappingToSourceVertices = t;\n  }, Qf.prototype.interfaces_ = function () {\n    return [];\n  }, Qf.prototype.getClass = function () {\n    return Qf;\n  }, Qf.isClosed = function (t) {\n    return !(t.length <= 1) && t[0].equals2D(t[t.length - 1]);\n  };\n  var $f = function $f(t) {\n      this._srcGeom = t || null;\n    },\n    tg = {\n      SNAP_PRECISION_FACTOR: {\n        configurable: !0\n      }\n    };\n  $f.prototype.snapTo = function (t, e) {\n    var n = this.extractTargetCoordinates(t);\n    return new eg(e, n).transform(this._srcGeom);\n  }, $f.prototype.snapToSelf = function (t, e) {\n    var n = this.extractTargetCoordinates(this._srcGeom),\n      r = new eg(t, n, !0).transform(this._srcGeom),\n      i = r;\n    return e && gl(i, $c) && (i = r.buffer(0)), i;\n  }, $f.prototype.computeSnapTolerance = function (t) {\n    return this.computeMinimumSegmentLength(t) / 10;\n  }, $f.prototype.extractTargetCoordinates = function (t) {\n    for (var e = new Lc(), n = t.getCoordinates(), r = 0; r < n.length; r++) e.add(n[r]);\n    return e.toArray(new Array(0).fill(null));\n  }, $f.prototype.computeMinimumSegmentLength = function (t) {\n    for (var e = nl.MAX_VALUE, n = 0; n < t.length - 1; n++) {\n      var r = t[n].distance(t[n + 1]);\n      r < e && (e = r);\n    }\n    return e;\n  }, $f.prototype.interfaces_ = function () {\n    return [];\n  }, $f.prototype.getClass = function () {\n    return $f;\n  }, $f.snap = function (t, e, n) {\n    var r = new Array(2).fill(null),\n      i = new $f(t);\n    r[0] = i.snapTo(e, n);\n    var o = new $f(e);\n    return r[1] = o.snapTo(r[0], n), r;\n  }, $f.computeOverlaySnapTolerance = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0],\n        e = $f.computeSizeBasedSnapTolerance(t),\n        n = t.getPrecisionModel();\n      if (n.getType() === gh.FIXED) {\n        var r = 1 / n.getScale() * 2 / 1.415;\n        r > e && (e = r);\n      }\n      return e;\n    }\n    if (2 === arguments.length) {\n      var i = arguments[0],\n        o = arguments[1];\n      return Math.min($f.computeOverlaySnapTolerance(i), $f.computeOverlaySnapTolerance(o));\n    }\n  }, $f.computeSizeBasedSnapTolerance = function (t) {\n    var e = t.getEnvelopeInternal();\n    return Math.min(e.getHeight(), e.getWidth()) * $f.SNAP_PRECISION_FACTOR;\n  }, $f.snapToSelf = function (t, e, n) {\n    return new $f(t).snapToSelf(e, n);\n  }, tg.SNAP_PRECISION_FACTOR.get = function () {\n    return 1e-9;\n  }, Object.defineProperties($f, tg);\n  var eg = function (t) {\n      function e(e, n, r) {\n        t.call(this), this._snapTolerance = e || null, this._snapPts = n || null, this._isSelfSnap = void 0 !== r && r;\n      }\n      return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.snapLine = function (t, e) {\n        var n = new Qf(t, this._snapTolerance);\n        return n.setAllowSnappingToSourceVertices(this._isSelfSnap), n.snapTo(e);\n      }, e.prototype.transformCoordinates = function (t, e) {\n        var n = t.toCoordinateArray(),\n          r = this.snapLine(n, this._snapPts);\n        return this._factory.getCoordinateSequenceFactory().create(r);\n      }, e.prototype.interfaces_ = function () {\n        return [];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, e;\n    }(Kf),\n    ng = function ng() {\n      this._isFirst = !0, this._commonMantissaBitsCount = 53, this._commonBits = 0, this._commonSignExp = null;\n    };\n  ng.prototype.getCommon = function () {\n    return nl.longBitsToDouble(this._commonBits);\n  }, ng.prototype.add = function (t) {\n    var e = nl.doubleToLongBits(t);\n    return this._isFirst ? (this._commonBits = e, this._commonSignExp = ng.signExpBits(this._commonBits), this._isFirst = !1, null) : ng.signExpBits(e) !== this._commonSignExp ? (this._commonBits = 0, null) : (this._commonMantissaBitsCount = ng.numCommonMostSigMantissaBits(this._commonBits, e), void (this._commonBits = ng.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount))));\n  }, ng.prototype.toString = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0],\n        e = nl.longBitsToDouble(t),\n        n = nl.toBinaryString(t),\n        r = \"0000000000000000000000000000000000000000000000000000000000000000\" + n,\n        i = r.substring(r.length - 64),\n        o = i.substring(0, 1) + \"  \" + i.substring(1, 12) + \"(exp) \" + i.substring(12) + \" [ \" + e + \" ]\";\n      return o;\n    }\n  }, ng.prototype.interfaces_ = function () {\n    return [];\n  }, ng.prototype.getClass = function () {\n    return ng;\n  }, ng.getBit = function (t, e) {\n    return 0 != (t & 1 << e) ? 1 : 0;\n  }, ng.signExpBits = function (t) {\n    return t >> 52;\n  }, ng.zeroLowerBits = function (t, e) {\n    return t & ~((1 << e) - 1);\n  }, ng.numCommonMostSigMantissaBits = function (t, e) {\n    for (var n = 0, r = 52; r >= 0; r--) {\n      if (ng.getBit(t, r) !== ng.getBit(e, r)) return n;\n      n++;\n    }\n    return 52;\n  };\n  var rg = function rg() {\n      this._commonCoord = null, this._ccFilter = new og();\n    },\n    ig = {\n      CommonCoordinateFilter: {\n        configurable: !0\n      },\n      Translater: {\n        configurable: !0\n      }\n    };\n  rg.prototype.addCommonBits = function (t) {\n    var e = new sg(this._commonCoord);\n    t.apply(e), t.geometryChanged();\n  }, rg.prototype.removeCommonBits = function (t) {\n    if (0 === this._commonCoord.x && 0 === this._commonCoord.y) return t;\n    var e = new ul(this._commonCoord);\n    e.x = -e.x, e.y = -e.y;\n    var n = new sg(e);\n    return t.apply(n), t.geometryChanged(), t;\n  }, rg.prototype.getCommonCoordinate = function () {\n    return this._commonCoord;\n  }, rg.prototype.add = function (t) {\n    t.apply(this._ccFilter), this._commonCoord = this._ccFilter.getCommonCoordinate();\n  }, rg.prototype.interfaces_ = function () {\n    return [];\n  }, rg.prototype.getClass = function () {\n    return rg;\n  }, ig.CommonCoordinateFilter.get = function () {\n    return og;\n  }, ig.Translater.get = function () {\n    return sg;\n  }, Object.defineProperties(rg, ig);\n  var og = function og() {\n    this._commonBitsX = new ng(), this._commonBitsY = new ng();\n  };\n  og.prototype.filter = function (t) {\n    this._commonBitsX.add(t.x), this._commonBitsY.add(t.y);\n  }, og.prototype.getCommonCoordinate = function () {\n    return new ul(this._commonBitsX.getCommon(), this._commonBitsY.getCommon());\n  }, og.prototype.interfaces_ = function () {\n    return [Kl];\n  }, og.prototype.getClass = function () {\n    return og;\n  };\n  var sg = function sg() {\n    this.trans = null;\n    var t = arguments[0];\n    this.trans = t;\n  };\n  sg.prototype.filter = function (t, e) {\n    var n = t.getOrdinate(e, 0) + this.trans.x,\n      r = t.getOrdinate(e, 1) + this.trans.y;\n    t.setOrdinate(e, 0, n), t.setOrdinate(e, 1, r);\n  }, sg.prototype.isDone = function () {\n    return !1;\n  }, sg.prototype.isGeometryChanged = function () {\n    return !0;\n  }, sg.prototype.interfaces_ = function () {\n    return [Fc];\n  }, sg.prototype.getClass = function () {\n    return sg;\n  };\n  var ag = function ag(t, e) {\n    this._geom = new Array(2).fill(null), this._snapTolerance = null, this._cbr = null, this._geom[0] = t, this._geom[1] = e, this.computeSnapTolerance();\n  };\n  ag.prototype.selfSnap = function (t) {\n    return new $f(t).snapTo(t, this._snapTolerance);\n  }, ag.prototype.removeCommonBits = function (t) {\n    this._cbr = new rg(), this._cbr.add(t[0]), this._cbr.add(t[1]);\n    var e = new Array(2).fill(null);\n    return e[0] = this._cbr.removeCommonBits(t[0].copy()), e[1] = this._cbr.removeCommonBits(t[1].copy()), e;\n  }, ag.prototype.prepareResult = function (t) {\n    return this._cbr.addCommonBits(t), t;\n  }, ag.prototype.getResultGeometry = function (t) {\n    var e = this.snap(this._geom),\n      n = Mg.overlayOp(e[0], e[1], t);\n    return this.prepareResult(n);\n  }, ag.prototype.checkValid = function (t) {\n    t.isValid() || Pl.out.println(\"Snapped geometry is invalid\");\n  }, ag.prototype.computeSnapTolerance = function () {\n    this._snapTolerance = $f.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);\n  }, ag.prototype.snap = function (t) {\n    var e = this.removeCommonBits(t);\n    return $f.snap(e[0], e[1], this._snapTolerance);\n  }, ag.prototype.interfaces_ = function () {\n    return [];\n  }, ag.prototype.getClass = function () {\n    return ag;\n  }, ag.overlayOp = function (t, e, n) {\n    return new ag(t, e).getResultGeometry(n);\n  }, ag.union = function (t, e) {\n    return ag.overlayOp(t, e, Mg.UNION);\n  }, ag.intersection = function (t, e) {\n    return ag.overlayOp(t, e, Mg.INTERSECTION);\n  }, ag.symDifference = function (t, e) {\n    return ag.overlayOp(t, e, Mg.SYMDIFFERENCE);\n  }, ag.difference = function (t, e) {\n    return ag.overlayOp(t, e, Mg.DIFFERENCE);\n  };\n  var ug = function ug(t, e) {\n    this._geom = new Array(2).fill(null), this._geom[0] = t, this._geom[1] = e;\n  };\n  ug.prototype.getResultGeometry = function (t) {\n    var e = null,\n      n = !1,\n      r = null;\n    try {\n      e = Mg.overlayOp(this._geom[0], this._geom[1], t);\n      n = !0;\n    } catch (t) {\n      if (!(t instanceof kl)) throw t;\n      r = t;\n    }\n    if (!n) try {\n      e = ag.overlayOp(this._geom[0], this._geom[1], t);\n    } catch (t) {\n      throw t instanceof kl ? r : t;\n    }\n    return e;\n  }, ug.prototype.interfaces_ = function () {\n    return [];\n  }, ug.prototype.getClass = function () {\n    return ug;\n  }, ug.overlayOp = function (t, e, n) {\n    return new ug(t, e).getResultGeometry(n);\n  }, ug.union = function (t, e) {\n    return ug.overlayOp(t, e, Mg.UNION);\n  }, ug.intersection = function (t, e) {\n    return ug.overlayOp(t, e, Mg.INTERSECTION);\n  }, ug.symDifference = function (t, e) {\n    return ug.overlayOp(t, e, Mg.SYMDIFFERENCE);\n  }, ug.difference = function (t, e) {\n    return ug.overlayOp(t, e, Mg.DIFFERENCE);\n  };\n  var lg = function lg() {\n    this.mce = null, this.chainIndex = null;\n    var t = arguments[0],\n      e = arguments[1];\n    this.mce = t, this.chainIndex = e;\n  };\n  lg.prototype.computeIntersections = function (t, e) {\n    this.mce.computeIntersectsForChain(this.chainIndex, t.mce, t.chainIndex, e);\n  }, lg.prototype.interfaces_ = function () {\n    return [];\n  }, lg.prototype.getClass = function () {\n    return lg;\n  };\n  var cg = function t() {\n      if (this._label = null, this._xValue = null, this._eventType = null, this._insertEvent = null, this._deleteEventIndex = null, this._obj = null, 2 === arguments.length) {\n        var e = arguments[0],\n          n = arguments[1];\n        this._eventType = t.DELETE, this._xValue = e, this._insertEvent = n;\n      } else if (3 === arguments.length) {\n        var r = arguments[0],\n          i = arguments[1],\n          o = arguments[2];\n        this._eventType = t.INSERT, this._label = r, this._xValue = i, this._obj = o;\n      }\n    },\n    hg = {\n      INSERT: {\n        configurable: !0\n      },\n      DELETE: {\n        configurable: !0\n      }\n    };\n  cg.prototype.isDelete = function () {\n    return this._eventType === cg.DELETE;\n  }, cg.prototype.setDeleteEventIndex = function (t) {\n    this._deleteEventIndex = t;\n  }, cg.prototype.getObject = function () {\n    return this._obj;\n  }, cg.prototype.compareTo = function (t) {\n    var e = t;\n    return this._xValue < e._xValue ? -1 : this._xValue > e._xValue ? 1 : this._eventType < e._eventType ? -1 : this._eventType > e._eventType ? 1 : 0;\n  }, cg.prototype.getInsertEvent = function () {\n    return this._insertEvent;\n  }, cg.prototype.isInsert = function () {\n    return this._eventType === cg.INSERT;\n  }, cg.prototype.isSameLabel = function (t) {\n    return null !== this._label && this._label === t._label;\n  }, cg.prototype.getDeleteEventIndex = function () {\n    return this._deleteEventIndex;\n  }, cg.prototype.interfaces_ = function () {\n    return [il];\n  }, cg.prototype.getClass = function () {\n    return cg;\n  }, hg.INSERT.get = function () {\n    return 1;\n  }, hg.DELETE.get = function () {\n    return 2;\n  }, Object.defineProperties(cg, hg);\n  var pg = function pg() {};\n  pg.prototype.interfaces_ = function () {\n    return [];\n  }, pg.prototype.getClass = function () {\n    return pg;\n  };\n  var fg = function fg() {\n    this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._properIntersectionPoint = null, this._li = null, this._includeProper = null, this._recordIsolated = null, this._isSelfIntersection = null, this._numIntersections = 0, this.numTests = 0, this._bdyNodes = null, this._isDone = !1, this._isDoneWhenProperInt = !1;\n    var t = arguments[0],\n      e = arguments[1],\n      n = arguments[2];\n    this._li = t, this._includeProper = e, this._recordIsolated = n;\n  };\n  fg.prototype.isTrivialIntersection = function (t, e, n, r) {\n    if (t === n && 1 === this._li.getIntersectionNum()) {\n      if (fg.isAdjacentSegments(e, r)) return !0;\n      if (t.isClosed()) {\n        var i = t.getNumPoints() - 1;\n        if (0 === e && r === i || 0 === r && e === i) return !0;\n      }\n    }\n    return !1;\n  }, fg.prototype.getProperIntersectionPoint = function () {\n    return this._properIntersectionPoint;\n  }, fg.prototype.setIsDoneIfProperInt = function (t) {\n    this._isDoneWhenProperInt = t;\n  }, fg.prototype.hasProperInteriorIntersection = function () {\n    return this._hasProperInterior;\n  }, fg.prototype.isBoundaryPointInternal = function (t, e) {\n    for (var n = e.iterator(); n.hasNext();) {\n      var r = n.next().getCoordinate();\n      if (t.isIntersection(r)) return !0;\n    }\n    return !1;\n  }, fg.prototype.hasProperIntersection = function () {\n    return this._hasProper;\n  }, fg.prototype.hasIntersection = function () {\n    return this._hasIntersection;\n  }, fg.prototype.isDone = function () {\n    return this._isDone;\n  }, fg.prototype.isBoundaryPoint = function (t, e) {\n    return null !== e && (!!this.isBoundaryPointInternal(t, e[0]) || !!this.isBoundaryPointInternal(t, e[1]));\n  }, fg.prototype.setBoundaryNodes = function (t, e) {\n    this._bdyNodes = new Array(2).fill(null), this._bdyNodes[0] = t, this._bdyNodes[1] = e;\n  }, fg.prototype.addIntersections = function (t, e, n, r) {\n    if (t === n && e === r) return null;\n    this.numTests++;\n    var i = t.getCoordinates()[e],\n      o = t.getCoordinates()[e + 1],\n      s = n.getCoordinates()[r],\n      a = n.getCoordinates()[r + 1];\n    this._li.computeIntersection(i, o, s, a), this._li.hasIntersection() && (this._recordIsolated && (t.setIsolated(!1), n.setIsolated(!1)), this._numIntersections++, this.isTrivialIntersection(t, e, n, r) || (this._hasIntersection = !0, !this._includeProper && this._li.isProper() || (t.addIntersections(this._li, e, 0), n.addIntersections(this._li, r, 1)), this._li.isProper() && (this._properIntersectionPoint = this._li.getIntersection(0).copy(), this._hasProper = !0, this._isDoneWhenProperInt && (this._isDone = !0), this.isBoundaryPoint(this._li, this._bdyNodes) || (this._hasProperInterior = !0))));\n  }, fg.prototype.interfaces_ = function () {\n    return [];\n  }, fg.prototype.getClass = function () {\n    return fg;\n  }, fg.isAdjacentSegments = function (t, e) {\n    return 1 === Math.abs(t - e);\n  };\n  var gg = function (t) {\n      function e() {\n        t.call(this), this.events = new lc(), this.nOverlaps = null;\n      }\n      return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.prepareEvents = function () {\n        np.sort(this.events);\n        for (var t = 0; t < this.events.size(); t++) {\n          var e = this.events.get(t);\n          e.isDelete() && e.getInsertEvent().setDeleteEventIndex(t);\n        }\n      }, e.prototype.computeIntersections = function () {\n        var t = this;\n        if (1 === arguments.length) {\n          var e = arguments[0];\n          this.nOverlaps = 0, this.prepareEvents();\n          for (var n = 0; n < this.events.size(); n++) {\n            var r = t.events.get(n);\n            if (r.isInsert() && t.processOverlaps(n, r.getDeleteEventIndex(), r, e), e.isDone()) break;\n          }\n        } else if (3 === arguments.length) if (arguments[2] instanceof fg && gl(arguments[0], ac) && gl(arguments[1], ac)) {\n          var i = arguments[0],\n            o = arguments[1],\n            s = arguments[2];\n          this.addEdges(i, i), this.addEdges(o, o), this.computeIntersections(s);\n        } else if (\"boolean\" == typeof arguments[2] && gl(arguments[0], ac) && arguments[1] instanceof fg) {\n          var a = arguments[0],\n            u = arguments[1],\n            l = arguments[2];\n          l ? this.addEdges(a, null) : this.addEdges(a), this.computeIntersections(u);\n        }\n      }, e.prototype.addEdge = function (t, e) {\n        for (var n = t.getMonotoneChainEdge(), r = n.getStartIndexes(), i = 0; i < r.length - 1; i++) {\n          var o = new lg(n, i),\n            s = new cg(e, n.getMinX(i), o);\n          this.events.add(s), this.events.add(new cg(n.getMaxX(i), s));\n        }\n      }, e.prototype.processOverlaps = function (t, e, n, r) {\n        for (var i = n.getObject(), o = t; o < e; o++) {\n          var s = this.events.get(o);\n          if (s.isInsert()) {\n            var a = s.getObject();\n            n.isSameLabel(s) || (i.computeIntersections(a, r), this.nOverlaps++);\n          }\n        }\n      }, e.prototype.addEdges = function () {\n        var t = this;\n        if (1 === arguments.length) for (var e = arguments[0], n = e.iterator(); n.hasNext();) {\n          var r = n.next();\n          t.addEdge(r, r);\n        } else if (2 === arguments.length) for (var i = arguments[0], o = arguments[1], s = i.iterator(); s.hasNext();) {\n          var a = s.next();\n          t.addEdge(a, o);\n        }\n      }, e.prototype.interfaces_ = function () {\n        return [];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, e;\n    }(pg),\n    dg = function dg() {\n      this._min = nl.POSITIVE_INFINITY, this._max = nl.NEGATIVE_INFINITY;\n    },\n    yg = {\n      NodeComparator: {\n        configurable: !0\n      }\n    };\n  dg.prototype.getMin = function () {\n    return this._min;\n  }, dg.prototype.intersects = function (t, e) {\n    return !(this._min > e || this._max < t);\n  }, dg.prototype.getMax = function () {\n    return this._max;\n  }, dg.prototype.toString = function () {\n    return Fl.toLineString(new ul(this._min, 0), new ul(this._max, 0));\n  }, dg.prototype.interfaces_ = function () {\n    return [];\n  }, dg.prototype.getClass = function () {\n    return dg;\n  }, yg.NodeComparator.get = function () {\n    return vg;\n  }, Object.defineProperties(dg, yg);\n  var vg = function vg() {};\n  vg.prototype.compare = function (t, e) {\n    var n = t,\n      r = e,\n      i = (n._min + n._max) / 2,\n      o = (r._min + r._max) / 2;\n    return i < o ? -1 : i > o ? 1 : 0;\n  }, vg.prototype.interfaces_ = function () {\n    return [sl];\n  }, vg.prototype.getClass = function () {\n    return vg;\n  };\n  var _g = function (t) {\n      function e() {\n        t.call(this), this._item = null;\n        var e = arguments[0],\n          n = arguments[1],\n          r = arguments[2];\n        this._min = e, this._max = n, this._item = r;\n      }\n      return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.query = function (t, e, n) {\n        if (!this.intersects(t, e)) return null;\n        n.visitItem(this._item);\n      }, e.prototype.interfaces_ = function () {\n        return [];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, e;\n    }(dg),\n    mg = function (t) {\n      function e() {\n        t.call(this), this._node1 = null, this._node2 = null;\n        var e = arguments[0],\n          n = arguments[1];\n        this._node1 = e, this._node2 = n, this.buildExtent(this._node1, this._node2);\n      }\n      return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.buildExtent = function (t, e) {\n        this._min = Math.min(t._min, e._min), this._max = Math.max(t._max, e._max);\n      }, e.prototype.query = function (t, e, n) {\n        if (!this.intersects(t, e)) return null;\n        null !== this._node1 && this._node1.query(t, e, n), null !== this._node2 && this._node2.query(t, e, n);\n      }, e.prototype.interfaces_ = function () {\n        return [];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, e;\n    }(dg),\n    xg = function xg() {\n      this._leaves = new lc(), this._root = null, this._level = 0;\n    };\n  xg.prototype.buildTree = function () {\n    np.sort(this._leaves, new dg.NodeComparator());\n    for (var t = this._leaves, e = null, n = new lc();;) {\n      if (this.buildLevel(t, n), 1 === n.size()) return n.get(0);\n      e = t, t = n, n = e;\n    }\n  }, xg.prototype.insert = function (t, e, n) {\n    if (null !== this._root) throw new Error(\"Index cannot be added to once it has been queried\");\n    this._leaves.add(new _g(t, e, n));\n  }, xg.prototype.query = function (t, e, n) {\n    this.init(), this._root.query(t, e, n);\n  }, xg.prototype.buildRoot = function () {\n    if (null !== this._root) return null;\n    this._root = this.buildTree();\n  }, xg.prototype.printNode = function (t) {\n    Pl.out.println(Fl.toLineString(new ul(t._min, this._level), new ul(t._max, this._level)));\n  }, xg.prototype.init = function () {\n    if (null !== this._root) return null;\n    this.buildRoot();\n  }, xg.prototype.buildLevel = function (t, e) {\n    this._level++, e.clear();\n    for (var n = 0; n < t.size(); n += 2) {\n      var r = t.get(n);\n      if (null === (n + 1 < t.size() ? t.get(n) : null)) e.add(r);else {\n        var i = new mg(t.get(n), t.get(n + 1));\n        e.add(i);\n      }\n    }\n  }, xg.prototype.interfaces_ = function () {\n    return [];\n  }, xg.prototype.getClass = function () {\n    return xg;\n  };\n  var Eg = function Eg() {\n    this._items = new lc();\n  };\n  Eg.prototype.visitItem = function (t) {\n    this._items.add(t);\n  }, Eg.prototype.getItems = function () {\n    return this._items;\n  }, Eg.prototype.interfaces_ = function () {\n    return [Qh];\n  }, Eg.prototype.getClass = function () {\n    return Eg;\n  };\n  var bg = function bg() {\n      this._index = null;\n      var t = arguments[0];\n      if (!gl(t, $c)) throw new el(\"Argument must be Polygonal\");\n      this._index = new Ng(t);\n    },\n    wg = {\n      SegmentVisitor: {\n        configurable: !0\n      },\n      IntervalIndexedGeometry: {\n        configurable: !0\n      }\n    };\n  bg.prototype.locate = function (t) {\n    var e = new Vl(t),\n      n = new Ig(e);\n    return this._index.query(t.y, t.y, n), e.getLocation();\n  }, bg.prototype.interfaces_ = function () {\n    return [jp];\n  }, bg.prototype.getClass = function () {\n    return bg;\n  }, wg.SegmentVisitor.get = function () {\n    return Ig;\n  }, wg.IntervalIndexedGeometry.get = function () {\n    return Ng;\n  }, Object.defineProperties(bg, wg);\n  var Ig = function Ig() {\n    this._counter = null;\n    var t = arguments[0];\n    this._counter = t;\n  };\n  Ig.prototype.visitItem = function (t) {\n    var e = t;\n    this._counter.countSegment(e.getCoordinate(0), e.getCoordinate(1));\n  }, Ig.prototype.interfaces_ = function () {\n    return [Qh];\n  }, Ig.prototype.getClass = function () {\n    return Ig;\n  };\n  var Ng = function Ng() {\n    this._index = new xg();\n    var t = arguments[0];\n    this.init(t);\n  };\n  Ng.prototype.init = function (t) {\n    for (var e = Cf.getLines(t).iterator(); e.hasNext();) {\n      var n = e.next().getCoordinates();\n      this.addLine(n);\n    }\n  }, Ng.prototype.addLine = function (t) {\n    for (var e = 1; e < t.length; e++) {\n      var n = new vp(t[e - 1], t[e]),\n        r = Math.min(n.p0.y, n.p1.y),\n        i = Math.max(n.p0.y, n.p1.y);\n      this._index.insert(r, i, n);\n    }\n  }, Ng.prototype.query = function () {\n    if (2 === arguments.length) {\n      var t = arguments[0],\n        e = arguments[1],\n        n = new Eg();\n      return this._index.query(t, e, n), n.getItems();\n    }\n    if (3 === arguments.length) {\n      var r = arguments[0],\n        i = arguments[1],\n        o = arguments[2];\n      this._index.query(r, i, o);\n    }\n  }, Ng.prototype.interfaces_ = function () {\n    return [];\n  }, Ng.prototype.getClass = function () {\n    return Ng;\n  };\n  var Sg = function (t) {\n      function e() {\n        if (t.call(this), this._parentGeom = null, this._lineEdgeMap = new fh(), this._boundaryNodeRule = null, this._useBoundaryDeterminationRule = !0, this._argIndex = null, this._boundaryNodes = null, this._hasTooFewPoints = !1, this._invalidPoint = null, this._areaPtLocator = null, this._ptLocator = new Pf(), 2 === arguments.length) {\n          var e = arguments[0],\n            n = arguments[1],\n            r = Ql.OGC_SFS_BOUNDARY_RULE;\n          this._argIndex = e, this._parentGeom = n, this._boundaryNodeRule = r, null !== n && this.add(n);\n        } else if (3 === arguments.length) {\n          var i = arguments[0],\n            o = arguments[1],\n            s = arguments[2];\n          this._argIndex = i, this._parentGeom = o, this._boundaryNodeRule = s, null !== o && this.add(o);\n        }\n      }\n      return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.insertBoundaryPoint = function (t, n) {\n        var r = this._nodes.addNode(n).getLabel(),\n          i = 1;\n        r.getLocation(t, Sh.ON) === pl.BOUNDARY && i++;\n        var o = e.determineBoundary(this._boundaryNodeRule, i);\n        r.setLocation(t, o);\n      }, e.prototype.computeSelfNodes = function () {\n        if (2 === arguments.length) {\n          var t = arguments[0],\n            e = arguments[1];\n          return this.computeSelfNodes(t, e, !1);\n        }\n        if (3 === arguments.length) {\n          var n = arguments[0],\n            r = arguments[1],\n            i = arguments[2],\n            o = new fg(n, !0, !1);\n          o.setIsDoneIfProperInt(i);\n          var s = this.createEdgeSetIntersector(),\n            a = this._parentGeom instanceof nh || this._parentGeom instanceof th || this._parentGeom instanceof rh,\n            u = r || !a;\n          return s.computeIntersections(this._edges, o, u), this.addSelfIntersectionNodes(this._argIndex), o;\n        }\n      }, e.prototype.computeSplitEdges = function (t) {\n        for (var e = this._edges.iterator(); e.hasNext();) {\n          e.next().eiList.addSplitEdges(t);\n        }\n      }, e.prototype.computeEdgeIntersections = function (t, e, n) {\n        var r = new fg(e, n, !0);\n        return r.setBoundaryNodes(this.getBoundaryNodes(), t.getBoundaryNodes()), this.createEdgeSetIntersector().computeIntersections(this._edges, t._edges, r), r;\n      }, e.prototype.getGeometry = function () {\n        return this._parentGeom;\n      }, e.prototype.getBoundaryNodeRule = function () {\n        return this._boundaryNodeRule;\n      }, e.prototype.hasTooFewPoints = function () {\n        return this._hasTooFewPoints;\n      }, e.prototype.addPoint = function () {\n        if (arguments[0] instanceof Qc) {\n          var t = arguments[0],\n            e = t.getCoordinate();\n          this.insertPoint(this._argIndex, e, pl.INTERIOR);\n        } else if (arguments[0] instanceof ul) {\n          var n = arguments[0];\n          this.insertPoint(this._argIndex, n, pl.INTERIOR);\n        }\n      }, e.prototype.addPolygon = function (t) {\n        this.addPolygonRing(t.getExteriorRing(), pl.EXTERIOR, pl.INTERIOR);\n        for (var e = 0; e < t.getNumInteriorRing(); e++) {\n          var n = t.getInteriorRingN(e);\n          this.addPolygonRing(n, pl.INTERIOR, pl.EXTERIOR);\n        }\n      }, e.prototype.addEdge = function (t) {\n        this.insertEdge(t);\n        var e = t.getCoordinates();\n        this.insertPoint(this._argIndex, e[0], pl.BOUNDARY), this.insertPoint(this._argIndex, e[e.length - 1], pl.BOUNDARY);\n      }, e.prototype.addLineString = function (t) {\n        var e = pc.removeRepeatedPoints(t.getCoordinates());\n        if (e.length < 2) return this._hasTooFewPoints = !0, this._invalidPoint = e[0], null;\n        var n = new of(e, new Dh(this._argIndex, pl.INTERIOR));\n        this._lineEdgeMap.put(t, n), this.insertEdge(n), ql.isTrue(e.length >= 2, \"found LineString with single point\"), this.insertBoundaryPoint(this._argIndex, e[0]), this.insertBoundaryPoint(this._argIndex, e[e.length - 1]);\n      }, e.prototype.getInvalidPoint = function () {\n        return this._invalidPoint;\n      }, e.prototype.getBoundaryPoints = function () {\n        for (var t = this.getBoundaryNodes(), e = new Array(t.size()).fill(null), n = 0, r = t.iterator(); r.hasNext();) {\n          var i = r.next();\n          e[n++] = i.getCoordinate().copy();\n        }\n        return e;\n      }, e.prototype.getBoundaryNodes = function () {\n        return null === this._boundaryNodes && (this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex)), this._boundaryNodes;\n      }, e.prototype.addSelfIntersectionNode = function (t, e, n) {\n        if (this.isBoundaryNode(t, e)) return null;\n        n === pl.BOUNDARY && this._useBoundaryDeterminationRule ? this.insertBoundaryPoint(t, e) : this.insertPoint(t, e, n);\n      }, e.prototype.addPolygonRing = function (t, e, n) {\n        if (t.isEmpty()) return null;\n        var r = pc.removeRepeatedPoints(t.getCoordinates());\n        if (r.length < 4) return this._hasTooFewPoints = !0, this._invalidPoint = r[0], null;\n        var i = e,\n          o = n;\n        Xl.isCCW(r) && (i = n, o = e);\n        var s = new of(r, new Dh(this._argIndex, pl.BOUNDARY, i, o));\n        this._lineEdgeMap.put(t, s), this.insertEdge(s), this.insertPoint(this._argIndex, r[0], pl.BOUNDARY);\n      }, e.prototype.insertPoint = function (t, e, n) {\n        var r = this._nodes.addNode(e),\n          i = r.getLabel();\n        null === i ? r._label = new Dh(t, n) : i.setLocation(t, n);\n      }, e.prototype.createEdgeSetIntersector = function () {\n        return new gg();\n      }, e.prototype.addSelfIntersectionNodes = function (t) {\n        for (var e = this._edges.iterator(); e.hasNext();) for (var n = e.next(), r = n.getLabel().getLocation(t), i = n.eiList.iterator(); i.hasNext();) {\n          var o = i.next();\n          this.addSelfIntersectionNode(t, o.coord, r);\n        }\n      }, e.prototype.add = function () {\n        if (1 !== arguments.length) return t.prototype.add.apply(this, arguments);\n        var e = arguments[0];\n        if (e.isEmpty()) return null;\n        if (e instanceof rh && (this._useBoundaryDeterminationRule = !1), e instanceof th) this.addPolygon(e);else if (e instanceof Zc) this.addLineString(e);else if (e instanceof Qc) this.addPoint(e);else if (e instanceof eh) this.addCollection(e);else if (e instanceof Gc) this.addCollection(e);else if (e instanceof rh) this.addCollection(e);else {\n          if (!(e instanceof kc)) throw new Error(e.getClass().getName());\n          this.addCollection(e);\n        }\n      }, e.prototype.addCollection = function (t) {\n        for (var e = 0; e < t.getNumGeometries(); e++) {\n          var n = t.getGeometryN(e);\n          this.add(n);\n        }\n      }, e.prototype.locate = function (t) {\n        return gl(this._parentGeom, $c) && this._parentGeom.getNumGeometries() > 50 ? (null === this._areaPtLocator && (this._areaPtLocator = new bg(this._parentGeom)), this._areaPtLocator.locate(t)) : this._ptLocator.locate(t, this._parentGeom);\n      }, e.prototype.findEdge = function () {\n        if (1 === arguments.length) {\n          var e = arguments[0];\n          return this._lineEdgeMap.get(e);\n        }\n        return t.prototype.findEdge.apply(this, arguments);\n      }, e.prototype.interfaces_ = function () {\n        return [];\n      }, e.prototype.getClass = function () {\n        return e;\n      }, e.determineBoundary = function (t, e) {\n        return t.isInBoundary(e) ? pl.BOUNDARY : pl.INTERIOR;\n      }, e;\n    }(Hh),\n    Cg = function Cg() {\n      if (this._li = new jl(), this._resultPrecisionModel = null, this._arg = null, 1 === arguments.length) {\n        var t = arguments[0];\n        this.setComputationPrecision(t.getPrecisionModel()), this._arg = new Array(1).fill(null), this._arg[0] = new Sg(0, t);\n      } else if (2 === arguments.length) {\n        var e = arguments[0],\n          n = arguments[1],\n          r = Ql.OGC_SFS_BOUNDARY_RULE;\n        e.getPrecisionModel().compareTo(n.getPrecisionModel()) >= 0 ? this.setComputationPrecision(e.getPrecisionModel()) : this.setComputationPrecision(n.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new Sg(0, e, r), this._arg[1] = new Sg(1, n, r);\n      } else if (3 === arguments.length) {\n        var i = arguments[0],\n          o = arguments[1],\n          s = arguments[2];\n        i.getPrecisionModel().compareTo(o.getPrecisionModel()) >= 0 ? this.setComputationPrecision(i.getPrecisionModel()) : this.setComputationPrecision(o.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new Sg(0, i, s), this._arg[1] = new Sg(1, o, s);\n      }\n    };\n  Cg.prototype.getArgGeometry = function (t) {\n    return this._arg[t].getGeometry();\n  }, Cg.prototype.setComputationPrecision = function (t) {\n    this._resultPrecisionModel = t, this._li.setPrecisionModel(this._resultPrecisionModel);\n  }, Cg.prototype.interfaces_ = function () {\n    return [];\n  }, Cg.prototype.getClass = function () {\n    return Cg;\n  };\n  var Pg = function Pg() {};\n  Pg.prototype.interfaces_ = function () {\n    return [];\n  }, Pg.prototype.getClass = function () {\n    return Pg;\n  }, Pg.map = function () {\n    if (arguments[0] instanceof Wl && gl(arguments[1], Pg.MapOp)) {\n      for (var t = arguments[0], e = arguments[1], n = new lc(), r = 0; r < t.getNumGeometries(); r++) {\n        var i = e.map(t.getGeometryN(r));\n        null !== i && n.add(i);\n      }\n      return t.getFactory().buildGeometry(n);\n    }\n    if (gl(arguments[0], ic) && gl(arguments[1], Pg.MapOp)) {\n      for (var o = arguments[0], s = arguments[1], a = new lc(), u = o.iterator(); u.hasNext();) {\n        var l = u.next(),\n          c = s.map(l);\n        null !== c && a.add(c);\n      }\n      return a;\n    }\n  }, Pg.MapOp = function () {};\n  var Mg = function (t) {\n    function e() {\n      var e = arguments[0],\n        n = arguments[1];\n      t.call(this, e, n), this._ptLocator = new Pf(), this._geomFact = null, this._resultGeom = null, this._graph = null, this._edgeList = new Jp(), this._resultPolyList = new lc(), this._resultLineList = new lc(), this._resultPointList = new lc(), this._graph = new Hh(new Hp()), this._geomFact = e.getFactory();\n    }\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.insertUniqueEdge = function (t) {\n      var e = this._edgeList.findEqualEdge(t);\n      if (null !== e) {\n        var n = e.getLabel(),\n          r = t.getLabel();\n        e.isPointwiseEqual(t) || (r = new Dh(t.getLabel())).flip();\n        var i = e.getDepth();\n        i.isNull() && i.add(n), i.add(r), n.merge(r);\n      } else this._edgeList.add(t);\n    }, e.prototype.getGraph = function () {\n      return this._graph;\n    }, e.prototype.cancelDuplicateResultEdges = function () {\n      for (var t = this._graph.getEdgeEnds().iterator(); t.hasNext();) {\n        var e = t.next(),\n          n = e.getSym();\n        e.isInResult() && n.isInResult() && (e.setInResult(!1), n.setInResult(!1));\n      }\n    }, e.prototype.isCoveredByLA = function (t) {\n      return !!this.isCovered(t, this._resultLineList) || !!this.isCovered(t, this._resultPolyList);\n    }, e.prototype.computeGeometry = function (t, n, r, i) {\n      var o = new lc();\n      return o.addAll(t), o.addAll(n), o.addAll(r), o.isEmpty() ? e.createEmptyResult(i, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact) : this._geomFact.buildGeometry(o);\n    }, e.prototype.mergeSymLabels = function () {\n      for (var t = this._graph.getNodes().iterator(); t.hasNext();) {\n        t.next().getEdges().mergeSymLabels();\n      }\n    }, e.prototype.isCovered = function (t, e) {\n      for (var n = e.iterator(); n.hasNext();) {\n        var r = n.next();\n        if (this._ptLocator.locate(t, r) !== pl.EXTERIOR) return !0;\n      }\n      return !1;\n    }, e.prototype.replaceCollapsedEdges = function () {\n      for (var t = new lc(), e = this._edgeList.iterator(); e.hasNext();) {\n        var n = e.next();\n        n.isCollapsed() && (e.remove(), t.add(n.getCollapsedEdge()));\n      }\n      this._edgeList.addAll(t);\n    }, e.prototype.updateNodeLabelling = function () {\n      for (var t = this._graph.getNodes().iterator(); t.hasNext();) {\n        var e = t.next(),\n          n = e.getEdges().getLabel();\n        e.getLabel().merge(n);\n      }\n    }, e.prototype.getResultGeometry = function (t) {\n      return this.computeOverlay(t), this._resultGeom;\n    }, e.prototype.insertUniqueEdges = function (t) {\n      for (var e = t.iterator(); e.hasNext();) {\n        var n = e.next();\n        this.insertUniqueEdge(n);\n      }\n    }, e.prototype.computeOverlay = function (t) {\n      this.copyPoints(0), this.copyPoints(1), this._arg[0].computeSelfNodes(this._li, !1), this._arg[1].computeSelfNodes(this._li, !1), this._arg[0].computeEdgeIntersections(this._arg[1], this._li, !0);\n      var e = new lc();\n      this._arg[0].computeSplitEdges(e), this._arg[1].computeSplitEdges(e), this.insertUniqueEdges(e), this.computeLabelsFromDepths(), this.replaceCollapsedEdges(), Hf.checkValid(this._edgeList.getEdges()), this._graph.addEdges(this._edgeList.getEdges()), this.computeLabelling(), this.labelIncompleteNodes(), this.findResultAreaEdges(t), this.cancelDuplicateResultEdges();\n      var n = new Wh(this._geomFact);\n      n.add(this._graph), this._resultPolyList = n.getPolygons();\n      var r = new Jf(this, this._geomFact, this._ptLocator);\n      this._resultLineList = r.build(t);\n      var i = new Zf(this, this._geomFact, this._ptLocator);\n      this._resultPointList = i.build(t), this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, t);\n    }, e.prototype.labelIncompleteNode = function (t, e) {\n      var n = this._ptLocator.locate(t.getCoordinate(), this._arg[e].getGeometry());\n      t.getLabel().setLocation(e, n);\n    }, e.prototype.copyPoints = function (t) {\n      for (var e = this._arg[t].getNodeIterator(); e.hasNext();) {\n        var n = e.next();\n        this._graph.addNode(n.getCoordinate()).setLabel(t, n.getLabel().getLocation(t));\n      }\n    }, e.prototype.findResultAreaEdges = function (t) {\n      for (var n = this._graph.getEdgeEnds().iterator(); n.hasNext();) {\n        var r = n.next(),\n          i = r.getLabel();\n        i.isArea() && !r.isInteriorAreaEdge() && e.isResultOfOp(i.getLocation(0, Sh.RIGHT), i.getLocation(1, Sh.RIGHT), t) && r.setInResult(!0);\n      }\n    }, e.prototype.computeLabelsFromDepths = function () {\n      for (var t = this._edgeList.iterator(); t.hasNext();) {\n        var e = t.next(),\n          n = e.getLabel(),\n          r = e.getDepth();\n        if (!r.isNull()) {\n          r.normalize();\n          for (var i = 0; i < 2; i++) n.isNull(i) || !n.isArea() || r.isNull(i) || (0 === r.getDelta(i) ? n.toLine(i) : (ql.isTrue(!r.isNull(i, Sh.LEFT), \"depth of LEFT side has not been initialized\"), n.setLocation(i, Sh.LEFT, r.getLocation(i, Sh.LEFT)), ql.isTrue(!r.isNull(i, Sh.RIGHT), \"depth of RIGHT side has not been initialized\"), n.setLocation(i, Sh.RIGHT, r.getLocation(i, Sh.RIGHT))));\n        }\n      }\n    }, e.prototype.computeLabelling = function () {\n      for (var t = this._graph.getNodes().iterator(); t.hasNext();) {\n        t.next().getEdges().computeLabelling(this._arg);\n      }\n      this.mergeSymLabels(), this.updateNodeLabelling();\n    }, e.prototype.labelIncompleteNodes = function () {\n      for (var t = this._graph.getNodes().iterator(); t.hasNext();) {\n        var e = t.next(),\n          n = e.getLabel();\n        e.isIsolated() && (n.isNull(0) ? this.labelIncompleteNode(e, 0) : this.labelIncompleteNode(e, 1)), e.getEdges().updateLabelling(n);\n      }\n    }, e.prototype.isCoveredByA = function (t) {\n      return !!this.isCovered(t, this._resultPolyList);\n    }, e.prototype.interfaces_ = function () {\n      return [];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, e;\n  }(Cg);\n  Mg.overlayOp = function (t, e, n) {\n    return new Mg(t, e).getResultGeometry(n);\n  }, Mg.intersection = function (t, e) {\n    if (t.isEmpty() || e.isEmpty()) return Mg.createEmptyResult(Mg.INTERSECTION, t, e, t.getFactory());\n    if (t.isGeometryCollection()) {\n      var n = e;\n      return Wf.map(t, {\n        interfaces_: function interfaces_() {\n          return [Pg.MapOp];\n        },\n        map: function map(t) {\n          return t.intersection(n);\n        }\n      });\n    }\n    return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), ug.overlayOp(t, e, Mg.INTERSECTION);\n  }, Mg.symDifference = function (t, e) {\n    if (t.isEmpty() || e.isEmpty()) {\n      if (t.isEmpty() && e.isEmpty()) return Mg.createEmptyResult(Mg.SYMDIFFERENCE, t, e, t.getFactory());\n      if (t.isEmpty()) return e.copy();\n      if (e.isEmpty()) return t.copy();\n    }\n    return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), ug.overlayOp(t, e, Mg.SYMDIFFERENCE);\n  }, Mg.resultDimension = function (t, e, n) {\n    var r = e.getDimension(),\n      i = n.getDimension(),\n      o = -1;\n    switch (t) {\n      case Mg.INTERSECTION:\n        o = Math.min(r, i);\n        break;\n      case Mg.UNION:\n        o = Math.max(r, i);\n        break;\n      case Mg.DIFFERENCE:\n        o = r;\n        break;\n      case Mg.SYMDIFFERENCE:\n        o = Math.max(r, i);\n    }\n    return o;\n  }, Mg.createEmptyResult = function (t, e, n, r) {\n    var i = null;\n    switch (Mg.resultDimension(t, e, n)) {\n      case -1:\n        i = r.createGeometryCollection(new Array(0).fill(null));\n        break;\n      case 0:\n        i = r.createPoint();\n        break;\n      case 1:\n        i = r.createLineString();\n        break;\n      case 2:\n        i = r.createPolygon();\n    }\n    return i;\n  }, Mg.difference = function (t, e) {\n    return t.isEmpty() ? Mg.createEmptyResult(Mg.DIFFERENCE, t, e, t.getFactory()) : e.isEmpty() ? t.copy() : (t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), ug.overlayOp(t, e, Mg.DIFFERENCE));\n  }, Mg.isResultOfOp = function () {\n    if (2 === arguments.length) {\n      var t = arguments[0],\n        e = arguments[1],\n        n = t.getLocation(0),\n        r = t.getLocation(1);\n      return Mg.isResultOfOp(n, r, e);\n    }\n    if (3 === arguments.length) {\n      var i = arguments[0],\n        o = arguments[1],\n        s = arguments[2];\n      switch (i === pl.BOUNDARY && (i = pl.INTERIOR), o === pl.BOUNDARY && (o = pl.INTERIOR), s) {\n        case Mg.INTERSECTION:\n          return i === pl.INTERIOR && o === pl.INTERIOR;\n        case Mg.UNION:\n          return i === pl.INTERIOR || o === pl.INTERIOR;\n        case Mg.DIFFERENCE:\n          return i === pl.INTERIOR && o !== pl.INTERIOR;\n        case Mg.SYMDIFFERENCE:\n          return i === pl.INTERIOR && o !== pl.INTERIOR || i !== pl.INTERIOR && o === pl.INTERIOR;\n      }\n      return !1;\n    }\n  }, Mg.INTERSECTION = 1, Mg.UNION = 2, Mg.DIFFERENCE = 3, Mg.SYMDIFFERENCE = 4;\n  var Lg = function Lg() {\n    this._g = null, this._boundaryDistanceTolerance = null, this._linework = null, this._ptLocator = new Pf(), this._seg = new vp();\n    var t = arguments[0],\n      e = arguments[1];\n    this._g = t, this._boundaryDistanceTolerance = e, this._linework = this.extractLinework(t);\n  };\n  Lg.prototype.isWithinToleranceOfBoundary = function (t) {\n    for (var e = this, n = 0; n < this._linework.getNumGeometries(); n++) for (var r = e._linework.getGeometryN(n).getCoordinateSequence(), i = 0; i < r.size() - 1; i++) {\n      if (r.getCoordinate(i, e._seg.p0), r.getCoordinate(i + 1, e._seg.p1), e._seg.distance(t) <= e._boundaryDistanceTolerance) return !0;\n    }\n    return !1;\n  }, Lg.prototype.getLocation = function (t) {\n    return this.isWithinToleranceOfBoundary(t) ? pl.BOUNDARY : this._ptLocator.locate(t, this._g);\n  }, Lg.prototype.extractLinework = function (t) {\n    var e = new Og();\n    t.apply(e);\n    var n = e.getLinework(),\n      r = _h.toLineStringArray(n);\n    return t.getFactory().createMultiLineString(r);\n  }, Lg.prototype.interfaces_ = function () {\n    return [];\n  }, Lg.prototype.getClass = function () {\n    return Lg;\n  };\n  var Og = function Og() {\n    this._linework = null, this._linework = new lc();\n  };\n  Og.prototype.getLinework = function () {\n    return this._linework;\n  }, Og.prototype.filter = function (t) {\n    if (t instanceof th) {\n      var e = t;\n      this._linework.add(e.getExteriorRing());\n      for (var n = 0; n < e.getNumInteriorRing(); n++) this._linework.add(e.getInteriorRingN(n));\n    }\n  }, Og.prototype.interfaces_ = function () {\n    return [Dc];\n  }, Og.prototype.getClass = function () {\n    return Og;\n  };\n  var Rg = function Rg() {\n    this._g = null, this._doLeft = !0, this._doRight = !0;\n    var t = arguments[0];\n    this._g = t;\n  };\n  Rg.prototype.extractPoints = function (t, e, n) {\n    for (var r = t.getCoordinates(), i = 0; i < r.length - 1; i++) this.computeOffsetPoints(r[i], r[i + 1], e, n);\n  }, Rg.prototype.setSidesToGenerate = function (t, e) {\n    this._doLeft = t, this._doRight = e;\n  }, Rg.prototype.getPoints = function (t) {\n    for (var e = new lc(), n = Cf.getLines(this._g).iterator(); n.hasNext();) {\n      var r = n.next();\n      this.extractPoints(r, t, e);\n    }\n    return e;\n  }, Rg.prototype.computeOffsetPoints = function (t, e, n, r) {\n    var i = e.x - t.x,\n      o = e.y - t.y,\n      s = Math.sqrt(i * i + o * o),\n      a = n * i / s,\n      u = n * o / s,\n      l = (e.x + t.x) / 2,\n      c = (e.y + t.y) / 2;\n    if (this._doLeft) {\n      var h = new ul(l - u, c + a);\n      r.add(h);\n    }\n    if (this._doRight) {\n      var p = new ul(l + u, c - a);\n      r.add(p);\n    }\n  }, Rg.prototype.interfaces_ = function () {\n    return [];\n  }, Rg.prototype.getClass = function () {\n    return Rg;\n  };\n  var Tg = function t() {\n      this._geom = null, this._locFinder = null, this._location = new Array(3).fill(null), this._invalidLocation = null, this._boundaryDistanceTolerance = t.TOLERANCE, this._testCoords = new lc();\n      var e = arguments[0],\n        n = arguments[1],\n        r = arguments[2];\n      this._boundaryDistanceTolerance = t.computeBoundaryDistanceTolerance(e, n), this._geom = [e, n, r], this._locFinder = [new Lg(this._geom[0], this._boundaryDistanceTolerance), new Lg(this._geom[1], this._boundaryDistanceTolerance), new Lg(this._geom[2], this._boundaryDistanceTolerance)];\n    },\n    Ag = {\n      TOLERANCE: {\n        configurable: !0\n      }\n    };\n  Tg.prototype.reportResult = function (t, e, n) {\n    Pl.out.println(\"Overlay result invalid - A:\" + pl.toLocationSymbol(e[0]) + \" B:\" + pl.toLocationSymbol(e[1]) + \" expected:\" + (n ? \"i\" : \"e\") + \" actual:\" + pl.toLocationSymbol(e[2]));\n  }, Tg.prototype.isValid = function (t) {\n    this.addTestPts(this._geom[0]), this.addTestPts(this._geom[1]);\n    var e = this.checkValid(t);\n    return e;\n  }, Tg.prototype.checkValid = function () {\n    var t = this;\n    if (1 === arguments.length) {\n      for (var e = arguments[0], n = 0; n < this._testCoords.size(); n++) {\n        var r = t._testCoords.get(n);\n        if (!t.checkValid(e, r)) return t._invalidLocation = r, !1;\n      }\n      return !0;\n    }\n    if (2 === arguments.length) {\n      var i = arguments[0],\n        o = arguments[1];\n      return this._location[0] = this._locFinder[0].getLocation(o), this._location[1] = this._locFinder[1].getLocation(o), this._location[2] = this._locFinder[2].getLocation(o), !!Tg.hasLocation(this._location, pl.BOUNDARY) || this.isValidResult(i, this._location);\n    }\n  }, Tg.prototype.addTestPts = function (t) {\n    var e = new Rg(t);\n    this._testCoords.addAll(e.getPoints(5 * this._boundaryDistanceTolerance));\n  }, Tg.prototype.isValidResult = function (t, e) {\n    var n = Mg.isResultOfOp(e[0], e[1], t),\n      r = !(n ^ e[2] === pl.INTERIOR);\n    return r || this.reportResult(t, e, n), r;\n  }, Tg.prototype.getInvalidLocation = function () {\n    return this._invalidLocation;\n  }, Tg.prototype.interfaces_ = function () {\n    return [];\n  }, Tg.prototype.getClass = function () {\n    return Tg;\n  }, Tg.hasLocation = function (t, e) {\n    for (var n = 0; n < 3; n++) if (t[n] === e) return !0;\n    return !1;\n  }, Tg.computeBoundaryDistanceTolerance = function (t, e) {\n    return Math.min($f.computeSizeBasedSnapTolerance(t), $f.computeSizeBasedSnapTolerance(e));\n  }, Tg.isValid = function (t, e, n, r) {\n    return new Tg(t, e, r).isValid(n);\n  }, Ag.TOLERANCE.get = function () {\n    return 1e-6;\n  }, Object.defineProperties(Tg, Ag);\n  var Dg = function t(e) {\n    this._geomFactory = null, this._skipEmpty = !1, this._inputGeoms = null, this._geomFactory = t.extractFactory(e), this._inputGeoms = e;\n  };\n  Dg.prototype.extractElements = function (t, e) {\n    if (null === t) return null;\n    for (var n = 0; n < t.getNumGeometries(); n++) {\n      var r = t.getGeometryN(n);\n      this._skipEmpty && r.isEmpty() || e.add(r);\n    }\n  }, Dg.prototype.combine = function () {\n    for (var t = new lc(), e = this._inputGeoms.iterator(); e.hasNext();) {\n      var n = e.next();\n      this.extractElements(n, t);\n    }\n    return 0 === t.size() ? null !== this._geomFactory ? this._geomFactory.createGeometryCollection(null) : null : this._geomFactory.buildGeometry(t);\n  }, Dg.prototype.interfaces_ = function () {\n    return [];\n  }, Dg.prototype.getClass = function () {\n    return Dg;\n  }, Dg.combine = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0],\n        e = new Dg(t);\n      return e.combine();\n    }\n    if (2 === arguments.length) {\n      var n = arguments[0],\n        r = arguments[1],\n        i = new Dg(Dg.createList(n, r));\n      return i.combine();\n    }\n    if (3 === arguments.length) {\n      var o = arguments[0],\n        s = arguments[1],\n        a = arguments[2],\n        u = new Dg(Dg.createList(o, s, a));\n      return u.combine();\n    }\n  }, Dg.extractFactory = function (t) {\n    return t.isEmpty() ? null : t.iterator().next().getFactory();\n  }, Dg.createList = function () {\n    if (2 === arguments.length) {\n      var t = arguments[0],\n        e = arguments[1],\n        n = new lc();\n      return n.add(t), n.add(e), n;\n    }\n    if (3 === arguments.length) {\n      var r = arguments[0],\n        i = arguments[1],\n        o = arguments[2],\n        s = new lc();\n      return s.add(r), s.add(i), s.add(o), s;\n    }\n  };\n  var Fg = function Fg() {\n      this._inputPolys = null, this._geomFactory = null;\n      var t = arguments[0];\n      this._inputPolys = t, null === this._inputPolys && (this._inputPolys = new lc());\n    },\n    kg = {\n      STRTREE_NODE_CAPACITY: {\n        configurable: !0\n      }\n    };\n  Fg.prototype.reduceToGeometries = function (t) {\n    for (var e = new lc(), n = t.iterator(); n.hasNext();) {\n      var r = n.next(),\n        i = null;\n      gl(r, ac) ? i = this.unionTree(r) : r instanceof Wl && (i = r), e.add(i);\n    }\n    return e;\n  }, Fg.prototype.extractByEnvelope = function (t, e, n) {\n    for (var r = new lc(), i = 0; i < e.getNumGeometries(); i++) {\n      var o = e.getGeometryN(i);\n      o.getEnvelopeInternal().intersects(t) ? r.add(o) : n.add(o);\n    }\n    return this._geomFactory.buildGeometry(r);\n  }, Fg.prototype.unionOptimized = function (t, e) {\n    var n = t.getEnvelopeInternal(),\n      r = e.getEnvelopeInternal();\n    if (!n.intersects(r)) return Dg.combine(t, e);\n    if (t.getNumGeometries() <= 1 && e.getNumGeometries() <= 1) return this.unionActual(t, e);\n    var i = n.intersection(r);\n    return this.unionUsingEnvelopeIntersection(t, e, i);\n  }, Fg.prototype.union = function () {\n    if (null === this._inputPolys) throw new Error(\"union() method cannot be called twice\");\n    if (this._inputPolys.isEmpty()) return null;\n    this._geomFactory = this._inputPolys.iterator().next().getFactory();\n    for (var t = new up(Fg.STRTREE_NODE_CAPACITY), e = this._inputPolys.iterator(); e.hasNext();) {\n      var n = e.next();\n      t.insert(n.getEnvelopeInternal(), n);\n    }\n    this._inputPolys = null;\n    var r = t.itemsTree();\n    return this.unionTree(r);\n  }, Fg.prototype.binaryUnion = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return this.binaryUnion(t, 0, t.size());\n    }\n    if (3 === arguments.length) {\n      var e = arguments[0],\n        n = arguments[1],\n        r = arguments[2];\n      if (r - n <= 1) {\n        var i = Fg.getGeometry(e, n);\n        return this.unionSafe(i, null);\n      }\n      if (r - n == 2) return this.unionSafe(Fg.getGeometry(e, n), Fg.getGeometry(e, n + 1));\n      var o = Math.trunc((r + n) / 2),\n        s = this.binaryUnion(e, n, o),\n        a = this.binaryUnion(e, o, r);\n      return this.unionSafe(s, a);\n    }\n  }, Fg.prototype.repeatedUnion = function (t) {\n    for (var e = null, n = t.iterator(); n.hasNext();) {\n      var r = n.next();\n      e = null === e ? r.copy() : e.union(r);\n    }\n    return e;\n  }, Fg.prototype.unionSafe = function (t, e) {\n    return null === t && null === e ? null : null === t ? e.copy() : null === e ? t.copy() : this.unionOptimized(t, e);\n  }, Fg.prototype.unionActual = function (t, e) {\n    return Fg.restrictToPolygons(t.union(e));\n  }, Fg.prototype.unionTree = function (t) {\n    var e = this.reduceToGeometries(t);\n    return this.binaryUnion(e);\n  }, Fg.prototype.unionUsingEnvelopeIntersection = function (t, e, n) {\n    var r = new lc(),\n      i = this.extractByEnvelope(n, t, r),\n      o = this.extractByEnvelope(n, e, r),\n      s = this.unionActual(i, o);\n    return r.add(s), Dg.combine(r);\n  }, Fg.prototype.bufferUnion = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0],\n        e = t.get(0).getFactory(),\n        n = e.buildGeometry(t),\n        r = n.buffer(0);\n      return r;\n    }\n    if (2 === arguments.length) {\n      var i = arguments[0],\n        o = arguments[1],\n        s = i.getFactory(),\n        a = s.createGeometryCollection([i, o]),\n        u = a.buffer(0);\n      return u;\n    }\n  }, Fg.prototype.interfaces_ = function () {\n    return [];\n  }, Fg.prototype.getClass = function () {\n    return Fg;\n  }, Fg.restrictToPolygons = function (t) {\n    if (gl(t, $c)) return t;\n    var e = Sf.getPolygons(t);\n    return 1 === e.size() ? e.get(0) : t.getFactory().createMultiPolygon(_h.toPolygonArray(e));\n  }, Fg.getGeometry = function (t, e) {\n    return e >= t.size() ? null : t.get(e);\n  }, Fg.union = function (t) {\n    return new Fg(t).union();\n  }, kg.STRTREE_NODE_CAPACITY.get = function () {\n    return 4;\n  }, Object.defineProperties(Fg, kg);\n  var Gg = function Gg() {};\n  function qg() {\n    return new Bg();\n  }\n  function Bg() {\n    this.reset();\n  }\n  Gg.prototype.interfaces_ = function () {\n    return [];\n  }, Gg.prototype.getClass = function () {\n    return Gg;\n  }, Gg.union = function (t, e) {\n    if (t.isEmpty() || e.isEmpty()) {\n      if (t.isEmpty() && e.isEmpty()) return Mg.createEmptyResult(Mg.UNION, t, e, t.getFactory());\n      if (t.isEmpty()) return e.copy();\n      if (e.isEmpty()) return t.copy();\n    }\n    return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), ug.overlayOp(t, e, Mg.UNION);\n  }, Bg.prototype = {\n    constructor: Bg,\n    reset: function reset() {\n      this.s = this.t = 0;\n    },\n    add: function add(t) {\n      jg(zg, t, this.t), jg(this, zg.s, this.s), this.s ? this.t += zg.t : this.s = zg.t;\n    },\n    valueOf: function valueOf() {\n      return this.s;\n    }\n  };\n  var zg = new Bg();\n  function jg(t, e, n) {\n    var r = t.s = e + n,\n      i = r - e,\n      o = r - i;\n    t.t = e - o + (n - i);\n  }\n  var Ug = 1e-6,\n    Vg = Math.PI,\n    Xg = Vg / 2,\n    Yg = Vg / 4,\n    Hg = 2 * Vg,\n    Wg = 180 / Vg,\n    Jg = Vg / 180,\n    Zg = Math.abs,\n    Kg = Math.atan,\n    Qg = Math.atan2,\n    $g = Math.cos,\n    td = Math.sin,\n    ed = Math.sqrt;\n  function nd(t) {\n    return t > 1 ? 0 : t < -1 ? Vg : Math.acos(t);\n  }\n  function rd(t) {\n    return t > 1 ? Xg : t < -1 ? -Xg : Math.asin(t);\n  }\n  function id() {}\n  function od(t, e) {\n    t && ad.hasOwnProperty(t.type) && ad[t.type](t, e);\n  }\n  var sd = {\n      Feature: function Feature(t, e) {\n        od(t.geometry, e);\n      },\n      FeatureCollection: function FeatureCollection(t, e) {\n        for (var n = t.features, r = -1, i = n.length; ++r < i;) od(n[r].geometry, e);\n      }\n    },\n    ad = {\n      Sphere: function Sphere(t, e) {\n        e.sphere();\n      },\n      Point: function Point(t, e) {\n        t = t.coordinates, e.point(t[0], t[1], t[2]);\n      },\n      MultiPoint: function MultiPoint(t, e) {\n        for (var n = t.coordinates, r = -1, i = n.length; ++r < i;) t = n[r], e.point(t[0], t[1], t[2]);\n      },\n      LineString: function LineString(t, e) {\n        ud(t.coordinates, e, 0);\n      },\n      MultiLineString: function MultiLineString(t, e) {\n        for (var n = t.coordinates, r = -1, i = n.length; ++r < i;) ud(n[r], e, 0);\n      },\n      Polygon: function Polygon(t, e) {\n        ld(t.coordinates, e);\n      },\n      MultiPolygon: function MultiPolygon(t, e) {\n        for (var n = t.coordinates, r = -1, i = n.length; ++r < i;) ld(n[r], e);\n      },\n      GeometryCollection: function GeometryCollection(t, e) {\n        for (var n = t.geometries, r = -1, i = n.length; ++r < i;) od(n[r], e);\n      }\n    };\n  function ud(t, e, n) {\n    var r,\n      i = -1,\n      o = t.length - n;\n    for (e.lineStart(); ++i < o;) r = t[i], e.point(r[0], r[1], r[2]);\n    e.lineEnd();\n  }\n  function ld(t, e) {\n    var n = -1,\n      r = t.length;\n    for (e.polygonStart(); ++n < r;) ud(t[n], e, 1);\n    e.polygonEnd();\n  }\n  qg(), qg();\n  function cd(t) {\n    return [Qg(t[1], t[0]), rd(t[2])];\n  }\n  function hd(t) {\n    var e = t[0],\n      n = t[1],\n      r = $g(n);\n    return [r * $g(e), r * td(e), td(n)];\n  }\n  function pd(t, e) {\n    return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];\n  }\n  function fd(t, e) {\n    return [t[1] * e[2] - t[2] * e[1], t[2] * e[0] - t[0] * e[2], t[0] * e[1] - t[1] * e[0]];\n  }\n  function gd(t, e) {\n    t[0] += e[0], t[1] += e[1], t[2] += e[2];\n  }\n  function dd(t, e) {\n    return [t[0] * e, t[1] * e, t[2] * e];\n  }\n  function yd(t) {\n    var e = ed(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);\n    t[0] /= e, t[1] /= e, t[2] /= e;\n  }\n  qg();\n  function vd(t, e) {\n    function n(n, r) {\n      return n = t(n, r), e(n[0], n[1]);\n    }\n    return t.invert && e.invert && (n.invert = function (n, r) {\n      return (n = e.invert(n, r)) && t.invert(n[0], n[1]);\n    }), n;\n  }\n  function _d(t, e) {\n    return [t > Vg ? t - Hg : t < -Vg ? t + Hg : t, e];\n  }\n  function md(t) {\n    return function (e, n) {\n      return [(e += t) > Vg ? e - Hg : e < -Vg ? e + Hg : e, n];\n    };\n  }\n  function xd(t) {\n    var e = md(t);\n    return e.invert = md(-t), e;\n  }\n  function Ed(t, e) {\n    var n = $g(t),\n      r = td(t),\n      i = $g(e),\n      o = td(e);\n    function s(t, e) {\n      var s = $g(e),\n        a = $g(t) * s,\n        u = td(t) * s,\n        l = td(e),\n        c = l * n + a * r;\n      return [Qg(u * i - c * o, a * n - l * r), rd(c * i + u * o)];\n    }\n    return s.invert = function (t, e) {\n      var s = $g(e),\n        a = $g(t) * s,\n        u = td(t) * s,\n        l = td(e),\n        c = l * i - u * o;\n      return [Qg(u * i + l * o, a * n + c * r), rd(c * n - a * r)];\n    }, s;\n  }\n  function bd(t, e) {\n    (e = hd(e))[0] -= t, yd(e);\n    var n = nd(-e[1]);\n    return ((-e[2] < 0 ? -n : n) + Hg - Ug) % Hg;\n  }\n  function wd() {\n    var t,\n      e = [];\n    return {\n      point: function point(e, n) {\n        t.push([e, n]);\n      },\n      lineStart: function lineStart() {\n        e.push(t = []);\n      },\n      lineEnd: id,\n      rejoin: function rejoin() {\n        e.length > 1 && e.push(e.pop().concat(e.shift()));\n      },\n      result: function result() {\n        var n = e;\n        return e = [], t = null, n;\n      }\n    };\n  }\n  function Id(t, e) {\n    return Zg(t[0] - e[0]) < Ug && Zg(t[1] - e[1]) < Ug;\n  }\n  function Nd(t, e, n, r) {\n    this.x = t, this.z = e, this.o = n, this.e = r, this.v = !1, this.n = this.p = null;\n  }\n  function Sd(t, e, n, r, i) {\n    var o,\n      s,\n      a = [],\n      u = [];\n    if (t.forEach(function (t) {\n      if (!((e = t.length - 1) <= 0)) {\n        var e,\n          n,\n          r = t[0],\n          s = t[e];\n        if (Id(r, s)) {\n          for (i.lineStart(), o = 0; o < e; ++o) i.point((r = t[o])[0], r[1]);\n          i.lineEnd();\n        } else a.push(n = new Nd(r, t, null, !0)), u.push(n.o = new Nd(r, null, n, !1)), a.push(n = new Nd(s, t, null, !1)), u.push(n.o = new Nd(s, null, n, !0));\n      }\n    }), a.length) {\n      for (u.sort(e), Cd(a), Cd(u), o = 0, s = u.length; o < s; ++o) u[o].e = n = !n;\n      for (var l, c, h = a[0];;) {\n        for (var p = h, f = !0; p.v;) if ((p = p.n) === h) return;\n        l = p.z, i.lineStart();\n        do {\n          if (p.v = p.o.v = !0, p.e) {\n            if (f) for (o = 0, s = l.length; o < s; ++o) i.point((c = l[o])[0], c[1]);else r(p.x, p.n.x, 1, i);\n            p = p.n;\n          } else {\n            if (f) for (l = p.p.z, o = l.length - 1; o >= 0; --o) i.point((c = l[o])[0], c[1]);else r(p.x, p.p.x, -1, i);\n            p = p.p;\n          }\n          l = (p = p.o).z, f = !f;\n        } while (!p.v);\n        i.lineEnd();\n      }\n    }\n  }\n  function Cd(t) {\n    if (e = t.length) {\n      for (var e, n, r = 0, i = t[0]; ++r < e;) i.n = n = t[r], n.p = i, i = n;\n      i.n = n = t[0], n.p = i;\n    }\n  }\n  function Pd(t, e) {\n    return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;\n  }\n  _d.invert = _d;\n  var Md, Ld;\n  1 === (Md = Pd).length && (Ld = Md, Md = function Md(t, e) {\n    return Pd(Ld(t), e);\n  });\n  function Od(t) {\n    for (var e, n, r, i = t.length, o = -1, s = 0; ++o < i;) s += t[o].length;\n    for (n = new Array(s); --i >= 0;) for (e = (r = t[i]).length; --e >= 0;) n[--s] = r[e];\n    return n;\n  }\n  var Rd = 1e9,\n    Td = -Rd;\n  function Ad(t, e, n, r) {\n    function i(i, o) {\n      return t <= i && i <= n && e <= o && o <= r;\n    }\n    function o(i, o, a, l) {\n      var c = 0,\n        h = 0;\n      if (null == i || (c = s(i, a)) !== (h = s(o, a)) || u(i, o) < 0 ^ a > 0) do {\n        l.point(0 === c || 3 === c ? t : n, c > 1 ? r : e);\n      } while ((c = (c + a + 4) % 4) !== h);else l.point(o[0], o[1]);\n    }\n    function s(r, i) {\n      return Zg(r[0] - t) < Ug ? i > 0 ? 0 : 3 : Zg(r[0] - n) < Ug ? i > 0 ? 2 : 1 : Zg(r[1] - e) < Ug ? i > 0 ? 1 : 0 : i > 0 ? 3 : 2;\n    }\n    function a(t, e) {\n      return u(t.x, e.x);\n    }\n    function u(t, e) {\n      var n = s(t, 1),\n        r = s(e, 1);\n      return n !== r ? n - r : 0 === n ? e[1] - t[1] : 1 === n ? t[0] - e[0] : 2 === n ? t[1] - e[1] : e[0] - t[0];\n    }\n    return function (s) {\n      var u,\n        l,\n        c,\n        h,\n        p,\n        f,\n        g,\n        d,\n        y,\n        v,\n        _,\n        m = s,\n        x = wd(),\n        E = {\n          point: b,\n          lineStart: function lineStart() {\n            E.point = w, l && l.push(c = []);\n            v = !0, y = !1, g = d = NaN;\n          },\n          lineEnd: function lineEnd() {\n            u && (w(h, p), f && y && x.rejoin(), u.push(x.result()));\n            E.point = b, y && m.lineEnd();\n          },\n          polygonStart: function polygonStart() {\n            m = x, u = [], l = [], _ = !0;\n          },\n          polygonEnd: function polygonEnd() {\n            var e = function () {\n                for (var e = 0, n = 0, i = l.length; n < i; ++n) for (var o, s, a = l[n], u = 1, c = a.length, h = a[0], p = h[0], f = h[1]; u < c; ++u) o = p, s = f, p = (h = a[u])[0], f = h[1], s <= r ? f > r && (p - o) * (r - s) > (f - s) * (t - o) && ++e : f <= r && (p - o) * (r - s) < (f - s) * (t - o) && --e;\n                return e;\n              }(),\n              n = _ && e,\n              i = (u = Od(u)).length;\n            (n || i) && (s.polygonStart(), n && (s.lineStart(), o(null, null, 1, s), s.lineEnd()), i && Sd(u, a, e, o, s), s.polygonEnd());\n            m = s, u = l = c = null;\n          }\n        };\n      function b(t, e) {\n        i(t, e) && m.point(t, e);\n      }\n      function w(o, s) {\n        var a = i(o, s);\n        if (l && c.push([o, s]), v) h = o, p = s, f = a, v = !1, a && (m.lineStart(), m.point(o, s));else if (a && y) m.point(o, s);else {\n          var u = [g = Math.max(Td, Math.min(Rd, g)), d = Math.max(Td, Math.min(Rd, d))],\n            x = [o = Math.max(Td, Math.min(Rd, o)), s = Math.max(Td, Math.min(Rd, s))];\n          !function (t, e, n, r, i, o) {\n            var s,\n              a = t[0],\n              u = t[1],\n              l = 0,\n              c = 1,\n              h = e[0] - a,\n              p = e[1] - u;\n            if (s = n - a, h || !(s > 0)) {\n              if (s /= h, h < 0) {\n                if (s < l) return;\n                s < c && (c = s);\n              } else if (h > 0) {\n                if (s > c) return;\n                s > l && (l = s);\n              }\n              if (s = i - a, h || !(s < 0)) {\n                if (s /= h, h < 0) {\n                  if (s > c) return;\n                  s > l && (l = s);\n                } else if (h > 0) {\n                  if (s < l) return;\n                  s < c && (c = s);\n                }\n                if (s = r - u, p || !(s > 0)) {\n                  if (s /= p, p < 0) {\n                    if (s < l) return;\n                    s < c && (c = s);\n                  } else if (p > 0) {\n                    if (s > c) return;\n                    s > l && (l = s);\n                  }\n                  if (s = o - u, p || !(s < 0)) {\n                    if (s /= p, p < 0) {\n                      if (s > c) return;\n                      s > l && (l = s);\n                    } else if (p > 0) {\n                      if (s < l) return;\n                      s < c && (c = s);\n                    }\n                    return l > 0 && (t[0] = a + l * h, t[1] = u + l * p), c < 1 && (e[0] = a + c * h, e[1] = u + c * p), !0;\n                  }\n                }\n              }\n            }\n          }(u, x, t, e, n, r) ? a && (m.lineStart(), m.point(o, s), _ = !1) : (y || (m.lineStart(), m.point(u[0], u[1])), m.point(x[0], x[1]), a || m.lineEnd(), _ = !1);\n        }\n        g = o, d = s, y = a;\n      }\n      return E;\n    };\n  }\n  var Dd = qg();\n  qg();\n  function Fd(t) {\n    return t;\n  }\n  qg(), qg();\n  var kd = 1 / 0,\n    Gd = kd,\n    qd = -kd,\n    Bd = qd,\n    zd = {\n      point: function point(t, e) {\n        t < kd && (kd = t);\n        t > qd && (qd = t);\n        e < Gd && (Gd = e);\n        e > Bd && (Bd = e);\n      },\n      lineStart: id,\n      lineEnd: id,\n      polygonStart: id,\n      polygonEnd: id,\n      result: function result() {\n        var t = [[kd, Gd], [qd, Bd]];\n        return qd = Bd = -(Gd = kd = 1 / 0), t;\n      }\n    };\n  qg();\n  function jd(t, e, n, r) {\n    return function (i, o) {\n      var s,\n        a,\n        u,\n        l = e(o),\n        c = i.invert(r[0], r[1]),\n        h = wd(),\n        p = e(h),\n        f = !1,\n        g = {\n          point: d,\n          lineStart: v,\n          lineEnd: _,\n          polygonStart: function polygonStart() {\n            g.point = m, g.lineStart = x, g.lineEnd = E, a = [], s = [];\n          },\n          polygonEnd: function polygonEnd() {\n            g.point = d, g.lineStart = v, g.lineEnd = _, a = Od(a);\n            var t = function (t, e) {\n              var n = e[0],\n                r = e[1],\n                i = [td(n), -$g(n), 0],\n                o = 0,\n                s = 0;\n              Dd.reset();\n              for (var a = 0, u = t.length; a < u; ++a) if (c = (l = t[a]).length) for (var l, c, h = l[c - 1], p = h[0], f = h[1] / 2 + Yg, g = td(f), d = $g(f), y = 0; y < c; ++y, p = _, g = x, d = E, h = v) {\n                var v = l[y],\n                  _ = v[0],\n                  m = v[1] / 2 + Yg,\n                  x = td(m),\n                  E = $g(m),\n                  b = _ - p,\n                  w = b >= 0 ? 1 : -1,\n                  I = w * b,\n                  N = I > Vg,\n                  S = g * x;\n                if (Dd.add(Qg(S * w * td(I), d * E + S * $g(I))), o += N ? b + w * Hg : b, N ^ p >= n ^ _ >= n) {\n                  var C = fd(hd(h), hd(v));\n                  yd(C);\n                  var P = fd(i, C);\n                  yd(P);\n                  var M = (N ^ b >= 0 ? -1 : 1) * rd(P[2]);\n                  (r > M || r === M && (C[0] || C[1])) && (s += N ^ b >= 0 ? 1 : -1);\n                }\n              }\n              return (o < -1e-6 || o < Ug && Dd < -1e-6) ^ 1 & s;\n            }(s, c);\n            a.length ? (f || (o.polygonStart(), f = !0), Sd(a, Vd, t, n, o)) : t && (f || (o.polygonStart(), f = !0), o.lineStart(), n(null, null, 1, o), o.lineEnd()), f && (o.polygonEnd(), f = !1), a = s = null;\n          },\n          sphere: function sphere() {\n            o.polygonStart(), o.lineStart(), n(null, null, 1, o), o.lineEnd(), o.polygonEnd();\n          }\n        };\n      function d(e, n) {\n        var r = i(e, n);\n        t(e = r[0], n = r[1]) && o.point(e, n);\n      }\n      function y(t, e) {\n        var n = i(t, e);\n        l.point(n[0], n[1]);\n      }\n      function v() {\n        g.point = y, l.lineStart();\n      }\n      function _() {\n        g.point = d, l.lineEnd();\n      }\n      function m(t, e) {\n        u.push([t, e]);\n        var n = i(t, e);\n        p.point(n[0], n[1]);\n      }\n      function x() {\n        p.lineStart(), u = [];\n      }\n      function E() {\n        m(u[0][0], u[0][1]), p.lineEnd();\n        var t,\n          e,\n          n,\n          r,\n          i = p.clean(),\n          l = h.result(),\n          c = l.length;\n        if (u.pop(), s.push(u), u = null, c) if (1 & i) {\n          if ((e = (n = l[0]).length - 1) > 0) {\n            for (f || (o.polygonStart(), f = !0), o.lineStart(), t = 0; t < e; ++t) o.point((r = n[t])[0], r[1]);\n            o.lineEnd();\n          }\n        } else c > 1 && 2 & i && l.push(l.pop().concat(l.shift())), a.push(l.filter(Ud));\n      }\n      return g;\n    };\n  }\n  function Ud(t) {\n    return t.length > 1;\n  }\n  function Vd(t, e) {\n    return ((t = t.x)[0] < 0 ? t[1] - Xg - Ug : Xg - t[1]) - ((e = e.x)[0] < 0 ? e[1] - Xg - Ug : Xg - e[1]);\n  }\n  var Xd = jd(function () {\n    return !0;\n  }, function (t) {\n    var e,\n      n = NaN,\n      r = NaN,\n      i = NaN;\n    return {\n      lineStart: function lineStart() {\n        t.lineStart(), e = 1;\n      },\n      point: function point(o, s) {\n        var a = o > 0 ? Vg : -Vg,\n          u = Zg(o - n);\n        Zg(u - Vg) < Ug ? (t.point(n, r = (r + s) / 2 > 0 ? Xg : -Xg), t.point(i, r), t.lineEnd(), t.lineStart(), t.point(a, r), t.point(o, r), e = 0) : i !== a && u >= Vg && (Zg(n - i) < Ug && (n -= i * Ug), Zg(o - a) < Ug && (o -= a * Ug), r = function (t, e, n, r) {\n          var i,\n            o,\n            s = td(t - n);\n          return Zg(s) > Ug ? Kg((td(e) * (o = $g(r)) * td(n) - td(r) * (i = $g(e)) * td(t)) / (i * o * s)) : (e + r) / 2;\n        }(n, r, o, s), t.point(i, r), t.lineEnd(), t.lineStart(), t.point(a, r), e = 0), t.point(n = o, r = s), i = a;\n      },\n      lineEnd: function lineEnd() {\n        t.lineEnd(), n = r = NaN;\n      },\n      clean: function clean() {\n        return 2 - e;\n      }\n    };\n  }, function (t, e, n, r) {\n    var i;\n    if (null == t) i = n * Xg, r.point(-Vg, i), r.point(0, i), r.point(Vg, i), r.point(Vg, 0), r.point(Vg, -i), r.point(0, -i), r.point(-Vg, -i), r.point(-Vg, 0), r.point(-Vg, i);else if (Zg(t[0] - e[0]) > Ug) {\n      var o = t[0] < e[0] ? Vg : -Vg;\n      i = n * o / 2, r.point(-o, i), r.point(0, i), r.point(o, i);\n    } else r.point(e[0], e[1]);\n  }, [-Vg, -Xg]);\n  function Yd(t, e) {\n    var n = $g(t),\n      r = n > 0,\n      i = Zg(n) > Ug;\n    function o(t, e) {\n      return $g(t) * $g(e) > n;\n    }\n    function s(t, e, r) {\n      var i = [1, 0, 0],\n        o = fd(hd(t), hd(e)),\n        s = pd(o, o),\n        a = o[0],\n        u = s - a * a;\n      if (!u) return !r && t;\n      var l = n * s / u,\n        c = -n * a / u,\n        h = fd(i, o),\n        p = dd(i, l);\n      gd(p, dd(o, c));\n      var f = h,\n        g = pd(p, f),\n        d = pd(f, f),\n        y = g * g - d * (pd(p, p) - 1);\n      if (!(y < 0)) {\n        var v = ed(y),\n          _ = dd(f, (-g - v) / d);\n        if (gd(_, p), _ = cd(_), !r) return _;\n        var m,\n          x = t[0],\n          E = e[0],\n          b = t[1],\n          w = e[1];\n        E < x && (m = x, x = E, E = m);\n        var I = E - x,\n          N = Zg(I - Vg) < Ug;\n        if (!N && w < b && (m = b, b = w, w = m), N || I < Ug ? N ? b + w > 0 ^ _[1] < (Zg(_[0] - x) < Ug ? b : w) : b <= _[1] && _[1] <= w : I > Vg ^ (x <= _[0] && _[0] <= E)) {\n          var S = dd(f, (-g + v) / d);\n          return gd(S, p), [_, cd(S)];\n        }\n      }\n    }\n    function a(e, n) {\n      var i = r ? t : Vg - t,\n        o = 0;\n      return e < -i ? o |= 1 : e > i && (o |= 2), n < -i ? o |= 4 : n > i && (o |= 8), o;\n    }\n    return jd(o, function (t) {\n      var e, n, u, l, c;\n      return {\n        lineStart: function lineStart() {\n          l = u = !1, c = 1;\n        },\n        point: function point(h, p) {\n          var f,\n            g = [h, p],\n            d = o(h, p),\n            y = r ? d ? 0 : a(h, p) : d ? a(h + (h < 0 ? Vg : -Vg), p) : 0;\n          if (!e && (l = u = d) && t.lineStart(), d !== u && (!(f = s(e, g)) || Id(e, f) || Id(g, f)) && (g[0] += Ug, g[1] += Ug, d = o(g[0], g[1])), d !== u) c = 0, d ? (t.lineStart(), f = s(g, e), t.point(f[0], f[1])) : (f = s(e, g), t.point(f[0], f[1]), t.lineEnd()), e = f;else if (i && e && r ^ d) {\n            var v;\n            y & n || !(v = s(g, e, !0)) || (c = 0, r ? (t.lineStart(), t.point(v[0][0], v[0][1]), t.point(v[1][0], v[1][1]), t.lineEnd()) : (t.point(v[1][0], v[1][1]), t.lineEnd(), t.lineStart(), t.point(v[0][0], v[0][1])));\n          }\n          !d || e && Id(e, g) || t.point(g[0], g[1]), e = g, u = d, n = y;\n        },\n        lineEnd: function lineEnd() {\n          u && t.lineEnd(), e = null;\n        },\n        clean: function clean() {\n          return c | (l && u) << 1;\n        }\n      };\n    }, function (n, r, i, o) {\n      !function (t, e, n, r, i, o) {\n        if (n) {\n          var s = $g(e),\n            a = td(e),\n            u = r * n;\n          null == i ? (i = e + r * Hg, o = e - u / 2) : (i = bd(s, i), o = bd(s, o), (r > 0 ? i < o : i > o) && (i += r * Hg));\n          for (var l, c = i; r > 0 ? c > o : c < o; c -= u) l = cd([s, -a * $g(c), -a * td(c)]), t.point(l[0], l[1]);\n        }\n      }(o, t, e, i, n, r);\n    }, r ? [0, -t] : [-Vg, t - Vg]);\n  }\n  function Hd(t) {\n    return function (e) {\n      var n = new Wd();\n      for (var r in t) n[r] = t[r];\n      return n.stream = e, n;\n    };\n  }\n  function Wd() {}\n  function Jd(t, e, n) {\n    var r = e[1][0] - e[0][0],\n      i = e[1][1] - e[0][1],\n      o = t.clipExtent && t.clipExtent();\n    t.scale(150).translate([0, 0]), null != o && t.clipExtent(null), function (t, e) {\n      t && sd.hasOwnProperty(t.type) ? sd[t.type](t, e) : od(t, e);\n    }(n, t.stream(zd));\n    var s = zd.result(),\n      a = Math.min(r / (s[1][0] - s[0][0]), i / (s[1][1] - s[0][1])),\n      u = +e[0][0] + (r - a * (s[1][0] + s[0][0])) / 2,\n      l = +e[0][1] + (i - a * (s[1][1] + s[0][1])) / 2;\n    return null != o && t.clipExtent(o), t.scale(150 * a).translate([u, l]);\n  }\n  Wd.prototype = {\n    constructor: Wd,\n    point: function point(t, e) {\n      this.stream.point(t, e);\n    },\n    sphere: function sphere() {\n      this.stream.sphere();\n    },\n    lineStart: function lineStart() {\n      this.stream.lineStart();\n    },\n    lineEnd: function lineEnd() {\n      this.stream.lineEnd();\n    },\n    polygonStart: function polygonStart() {\n      this.stream.polygonStart();\n    },\n    polygonEnd: function polygonEnd() {\n      this.stream.polygonEnd();\n    }\n  };\n  var Zd = $g(30 * Jg);\n  function Kd(t, e) {\n    return +e ? function (t, e) {\n      function n(r, i, o, s, a, u, l, c, h, p, f, g, d, y) {\n        var v = l - r,\n          _ = c - i,\n          m = v * v + _ * _;\n        if (m > 4 * e && d--) {\n          var x = s + p,\n            E = a + f,\n            b = u + g,\n            w = ed(x * x + E * E + b * b),\n            I = rd(b /= w),\n            N = Zg(Zg(b) - 1) < Ug || Zg(o - h) < Ug ? (o + h) / 2 : Qg(E, x),\n            S = t(N, I),\n            C = S[0],\n            P = S[1],\n            M = C - r,\n            L = P - i,\n            O = _ * M - v * L;\n          (O * O / m > e || Zg((v * M + _ * L) / m - .5) > .3 || s * p + a * f + u * g < Zd) && (n(r, i, o, s, a, u, C, P, N, x /= w, E /= w, b, d, y), y.point(C, P), n(C, P, N, x, E, b, l, c, h, p, f, g, d, y));\n        }\n      }\n      return function (e) {\n        var r,\n          i,\n          o,\n          s,\n          a,\n          u,\n          l,\n          c,\n          h,\n          p,\n          f,\n          g,\n          d = {\n            point: y,\n            lineStart: v,\n            lineEnd: m,\n            polygonStart: function polygonStart() {\n              e.polygonStart(), d.lineStart = x;\n            },\n            polygonEnd: function polygonEnd() {\n              e.polygonEnd(), d.lineStart = v;\n            }\n          };\n        function y(n, r) {\n          n = t(n, r), e.point(n[0], n[1]);\n        }\n        function v() {\n          c = NaN, d.point = _, e.lineStart();\n        }\n        function _(r, i) {\n          var o = hd([r, i]),\n            s = t(r, i);\n          n(c, h, l, p, f, g, c = s[0], h = s[1], l = r, p = o[0], f = o[1], g = o[2], 16, e), e.point(c, h);\n        }\n        function m() {\n          d.point = y, e.lineEnd();\n        }\n        function x() {\n          v(), d.point = E, d.lineEnd = b;\n        }\n        function E(t, e) {\n          _(r = t, e), i = c, o = h, s = p, a = f, u = g, d.point = _;\n        }\n        function b() {\n          n(c, h, l, p, f, g, i, o, r, s, a, u, 16, e), d.lineEnd = m, m();\n        }\n        return d;\n      };\n    }(t, e) : function (t) {\n      return Hd({\n        point: function point(e, n) {\n          e = t(e, n), this.stream.point(e[0], e[1]);\n        }\n      });\n    }(t);\n  }\n  var Qd = Hd({\n    point: function point(t, e) {\n      this.stream.point(t * Jg, e * Jg);\n    }\n  });\n  function $d(t) {\n    return function (t) {\n      var e,\n        n,\n        r,\n        i,\n        o,\n        s,\n        a,\n        u,\n        l,\n        c,\n        h = 150,\n        p = 480,\n        f = 250,\n        g = 0,\n        d = 0,\n        y = 0,\n        v = 0,\n        _ = 0,\n        m = null,\n        x = Xd,\n        E = null,\n        b = Fd,\n        w = .5,\n        I = Kd(C, w);\n      function N(t) {\n        return [(t = o(t[0] * Jg, t[1] * Jg))[0] * h + n, r - t[1] * h];\n      }\n      function S(t) {\n        return (t = o.invert((t[0] - n) / h, (r - t[1]) / h)) && [t[0] * Wg, t[1] * Wg];\n      }\n      function C(t, i) {\n        return [(t = e(t, i))[0] * h + n, r - t[1] * h];\n      }\n      function P() {\n        o = vd(i = function (t, e, n) {\n          return (t %= Hg) ? e || n ? vd(xd(t), Ed(e, n)) : xd(t) : e || n ? Ed(e, n) : _d;\n        }(y, v, _), e);\n        var t = e(g, d);\n        return n = p - t[0] * h, r = f + t[1] * h, M();\n      }\n      function M() {\n        return l = c = null, N;\n      }\n      return N.stream = function (t) {\n        return l && c === t ? l : l = Qd(x(i, I(b(c = t))));\n      }, N.clipAngle = function (t) {\n        return arguments.length ? (x = +t ? Yd(m = t * Jg, 6 * Jg) : (m = null, Xd), M()) : m * Wg;\n      }, N.clipExtent = function (t) {\n        return arguments.length ? (b = null == t ? (E = s = a = u = null, Fd) : Ad(E = +t[0][0], s = +t[0][1], a = +t[1][0], u = +t[1][1]), M()) : null == E ? null : [[E, s], [a, u]];\n      }, N.scale = function (t) {\n        return arguments.length ? (h = +t, P()) : h;\n      }, N.translate = function (t) {\n        return arguments.length ? (p = +t[0], f = +t[1], P()) : [p, f];\n      }, N.center = function (t) {\n        return arguments.length ? (g = t[0] % 360 * Jg, d = t[1] % 360 * Jg, P()) : [g * Wg, d * Wg];\n      }, N.rotate = function (t) {\n        return arguments.length ? (y = t[0] % 360 * Jg, v = t[1] % 360 * Jg, _ = t.length > 2 ? t[2] % 360 * Jg : 0, P()) : [y * Wg, v * Wg, _ * Wg];\n      }, N.precision = function (t) {\n        return arguments.length ? (I = Kd(C, w = t * t), M()) : ed(w);\n      }, N.fitExtent = function (t, e) {\n        return Jd(N, t, e);\n      }, N.fitSize = function (t, e) {\n        return function (t, e, n) {\n          return Jd(t, [[0, 0], e], n);\n        }(N, t, e);\n      }, function () {\n        return e = t.apply(this, arguments), N.invert = e.invert && S, P();\n      };\n    }(function () {\n      return t;\n    })();\n  }\n  var ty = function (t) {\n    return function (e, n) {\n      var r = $g(e),\n        i = $g(n),\n        o = t(r * i);\n      return [o * i * td(e), o * td(n)];\n    };\n  }(function (t) {\n    return (t = nd(t)) && t / td(t);\n  });\n  function ey() {\n    return $d(ty).scale(79.4188).clipAngle(179.999);\n  }\n  function ny(t, n, r, i) {\n    var s = t.properties || {},\n      a = \"Feature\" === t.type ? t.geometry : t;\n    if (\"GeometryCollection\" === a.type) {\n      var u = [];\n      return q(t, function (t) {\n        var e = ny(t, n, r, i);\n        e && u.push(e);\n      }), f(u);\n    }\n    var l = function (t) {\n        var n = xn(t).geometry.coordinates,\n          r = [-n[0], -n[1]];\n        return ey().rotate(r).scale(e);\n      }(a),\n      c = {\n        type: a.type,\n        coordinates: iy(a.coordinates, l)\n      },\n      h = new Ih().read(c),\n      p = m(x(n, r), \"meters\"),\n      g = _f.bufferOp(h, p, i);\n    if (!ry((g = new Nh().write(g)).coordinates)) return o({\n      type: g.type,\n      coordinates: oy(g.coordinates, l)\n    }, s);\n  }\n  function ry(t) {\n    return Array.isArray(t[0]) ? ry(t[0]) : isNaN(t[0]);\n  }\n  function iy(t, e) {\n    return \"object\" != typeof t[0] ? e(t) : t.map(function (t) {\n      return iy(t, e);\n    });\n  }\n  function oy(t, e) {\n    return \"object\" != typeof t[0] ? e.invert(t) : t.map(function (t) {\n      return oy(t, e);\n    });\n  }\n  function sy(t, e, n) {\n    void 0 === n && (n = {});\n    var r = rt(t),\n      i = rt(e),\n      o = $u.intersection(r.coordinates, i.coordinates);\n    return 0 === o.length ? null : 1 === o.length ? l(o[0], n.properties) : y(o, n.properties);\n  }\n  function ay(t, e, n) {\n    void 0 === n && (n = {});\n    var r = JSON.stringify(n.properties || {}),\n      i = t[0],\n      o = t[1],\n      s = t[2],\n      a = t[3],\n      u = (o + a) / 2,\n      l = (i + s) / 2,\n      c = 2 * e / me([i, u], [s, u], n) * (s - i),\n      h = 2 * e / me([l, o], [l, a], n) * (a - o),\n      p = c / 2,\n      g = 2 * p,\n      d = Math.sqrt(3) / 2 * h,\n      y = s - i,\n      v = a - o,\n      _ = 3 / 4 * g,\n      m = d,\n      x = (y - g) / (g - p / 2),\n      E = Math.floor(x),\n      b = (E * _ - p / 2 - y) / 2 - p / 2 + _ / 2,\n      w = Math.floor((v - d) / d),\n      I = (v - w * d) / 2,\n      N = w * d - v > d / 2;\n    N && (I -= d / 4);\n    for (var S = [], C = [], P = 0; P < 6; P++) {\n      var M = 2 * Math.PI / 6 * P;\n      S.push(Math.cos(M)), C.push(Math.sin(M));\n    }\n    for (var L = [], O = 0; O <= E; O++) for (var R = 0; R <= w; R++) {\n      var T = O % 2 == 1;\n      if ((0 !== R || !T) && (0 !== R || !N)) {\n        var A = O * _ + i - b,\n          D = R * m + o + I;\n        if (T && (D -= d / 2), !0 === n.triangles) ly([A, D], c / 2, h / 2, JSON.parse(r), S, C).forEach(function (t) {\n          n.mask ? sy(n.mask, t) && L.push(t) : L.push(t);\n        });else {\n          var F = uy([A, D], c / 2, h / 2, JSON.parse(r), S, C);\n          n.mask ? sy(n.mask, F) && L.push(F) : L.push(F);\n        }\n      }\n    }\n    return f(L);\n  }\n  function uy(t, e, n, r, i, o) {\n    for (var s = [], a = 0; a < 6; a++) {\n      var u = t[0] + e * i[a],\n        c = t[1] + n * o[a];\n      s.push([u, c]);\n    }\n    return s.push(s[0].slice()), l([s], r);\n  }\n  function ly(t, e, n, r, i, o) {\n    for (var s = [], a = 0; a < 6; a++) {\n      var u = [];\n      u.push(t), u.push([t[0] + e * i[a], t[1] + n * o[a]]), u.push([t[0] + e * i[(a + 1) % 6], t[1] + n * o[(a + 1) % 6]]), u.push(t), s.push(l([u], r));\n    }\n    return s;\n  }\n  function cy(t) {\n    return y(t);\n  }\n  function hy(t) {\n    return l(t && t.geometry.coordinates || [[[180, 90], [-180, 90], [-180, -90], [180, -90], [180, 90]]]);\n  }\n  function py(t, e, n) {\n    return void 0 === n && (n = {}), function (t, e, n, r) {\n      void 0 === r && (r = {});\n      for (var i = [], o = t[0], s = t[1], a = t[2], u = t[3], c = e / me([o, s], [a, s], r) * (a - o), h = n / me([o, s], [o, u], r) * (u - s), p = a - o, g = u - s, d = Math.floor(p / c), y = Math.floor(g / h), v = (g - y * h) / 2, _ = o + (p - d * c) / 2, m = 0; m < d; m++) {\n        for (var x = s + v, E = 0; E < y; E++) {\n          var b = l([[[_, x], [_, x + h], [_ + c, x + h], [_ + c, x], [_, x]]], r.properties);\n          r.mask ? Ps(r.mask, b) && i.push(b) : i.push(b), x += h;\n        }\n        _ += c;\n      }\n      return f(i);\n    }(t, e, e, n);\n  }\n  function fy(t, e, n) {\n    void 0 === n && (n = {});\n    for (var r = [], i = e / me([t[0], t[1]], [t[2], t[1]], n) * (t[2] - t[0]), o = e / me([t[0], t[1]], [t[0], t[3]], n) * (t[3] - t[1]), s = 0, a = t[0]; a <= t[2];) {\n      for (var u = 0, c = t[1]; c <= t[3];) {\n        var h = null,\n          p = null;\n        s % 2 == 0 && u % 2 == 0 ? (h = l([[[a, c], [a, c + o], [a + i, c], [a, c]]], n.properties), p = l([[[a, c + o], [a + i, c + o], [a + i, c], [a, c + o]]], n.properties)) : s % 2 == 0 && u % 2 == 1 ? (h = l([[[a, c], [a + i, c + o], [a + i, c], [a, c]]], n.properties), p = l([[[a, c], [a, c + o], [a + i, c + o], [a, c]]], n.properties)) : u % 2 == 0 && s % 2 == 1 ? (h = l([[[a, c], [a, c + o], [a + i, c + o], [a, c]]], n.properties), p = l([[[a, c], [a + i, c + o], [a + i, c], [a, c]]], n.properties)) : u % 2 == 1 && s % 2 == 1 && (h = l([[[a, c], [a, c + o], [a + i, c], [a, c]]], n.properties), p = l([[[a, c + o], [a + i, c + o], [a + i, c], [a, c + o]]], n.properties)), n.mask ? (sy(n.mask, h) && r.push(h), sy(n.mask, p) && r.push(p)) : (r.push(h), r.push(p)), c += o, u++;\n      }\n      s++, a += i;\n    }\n    return f(r);\n  }\n  ty.invert = function (t) {\n    return function (e, n) {\n      var r = ed(e * e + n * n),\n        i = t(r),\n        o = td(i),\n        s = $g(i);\n      return [Qg(e * o, r * s), rd(r && n * o / r)];\n    };\n  }(function (t) {\n    return t;\n  }), t.along = function (t, e, n) {\n    void 0 === n && (n = {});\n    for (var r = rt(t).coordinates, i = 0, o = 0; o < r.length && !(e >= i && o === r.length - 1); o++) {\n      if (i >= e) {\n        var s = e - i;\n        if (s) {\n          var u = mn(r[o], r[o - 1]) - 180;\n          return vn(r[o], s, u, n);\n        }\n        return a(r[o]);\n      }\n      i += me(r[o], r[o + 1], n);\n    }\n    return a(r[r.length - 1]);\n  }, t.angle = function (t, e, n, r) {\n    if (void 0 === r && (r = {}), !P(r)) throw new Error(\"options is invalid\");\n    if (!t) throw new Error(\"startPoint is required\");\n    if (!e) throw new Error(\"midPoint is required\");\n    if (!n) throw new Error(\"endPoint is required\");\n    var i = t,\n      o = e,\n      s = n,\n      a = b(!0 !== r.mercator ? mn(i, o) : Bi(i, o)),\n      u = b(!0 !== r.mercator ? mn(s, o) : Bi(s, o)),\n      l = Math.abs(a - u);\n    return !0 === r.explementary ? 360 - l : l;\n  }, t.applyFilter = uu, t.area = jr, t.areaFactors = i, t.bbox = Z, t.bboxClip = function (t, e) {\n    var n = rt(t),\n      r = n.type,\n      i = \"Feature\" === t.type ? t.properties : {},\n      o = n.coordinates;\n    switch (r) {\n      case \"LineString\":\n      case \"MultiLineString\":\n        var s = [];\n        return \"LineString\" === r && (o = [o]), o.forEach(function (t) {\n          !function (t, e, n) {\n            var r,\n              i,\n              o,\n              s,\n              a,\n              u = t.length,\n              l = Ri(t[0], e),\n              c = [];\n            for (n || (n = []), r = 1; r < u; r++) {\n              for (s = t[r - 1], i = o = Ri(a = t[r], e);;) {\n                if (!(l | i)) {\n                  c.push(s), i !== o ? (c.push(a), r < u - 1 && (n.push(c), c = [])) : r === u - 1 && c.push(a);\n                  break;\n                }\n                if (l & i) break;\n                l ? l = Ri(s = Oi(s, a, l, e), e) : i = Ri(a = Oi(s, a, i, e), e);\n              }\n              l = o;\n            }\n            c.length && n.push(c);\n          }(t, e, s);\n        }), 1 === s.length ? h(s[0], i) : g(s, i);\n      case \"Polygon\":\n        return l(Ti(o, e), i);\n      case \"MultiPolygon\":\n        return y(o.map(function (t) {\n          return Ti(t, e);\n        }), i);\n      default:\n        throw new Error(\"geometry \" + r + \" not supported\");\n    }\n  }, t.bboxPolygon = gn, t.bearing = mn, t.bearingToAngle = b, t.bearingToAzimuth = b, t.bezier = fn, t.bezierSpline = fn, t.booleanClockwise = Yi, t.booleanContains = function (t, e) {\n    var n = rt(t),\n      r = rt(e),\n      i = n.type,\n      o = r.type,\n      s = n.coordinates,\n      a = r.coordinates;\n    switch (i) {\n      case \"Point\":\n        switch (o) {\n          case \"Point\":\n            return vs(s, a);\n          default:\n            throw new Error(\"feature2 \" + o + \" geometry not supported\");\n        }\n      case \"MultiPoint\":\n        switch (o) {\n          case \"Point\":\n            return function (t, e) {\n              var n,\n                r = !1;\n              for (n = 0; n < t.coordinates.length; n++) if (vs(t.coordinates[n], e.coordinates)) {\n                r = !0;\n                break;\n              }\n              return r;\n            }(n, r);\n          case \"MultiPoint\":\n            return function (t, e) {\n              for (var n = 0, r = e.coordinates; n < r.length; n++) {\n                for (var i = r[n], o = !1, s = 0, a = t.coordinates; s < a.length; s++) {\n                  if (vs(i, a[s])) {\n                    o = !0;\n                    break;\n                  }\n                }\n                if (!o) return !1;\n              }\n              return !0;\n            }(n, r);\n          default:\n            throw new Error(\"feature2 \" + o + \" geometry not supported\");\n        }\n      case \"LineString\":\n        switch (o) {\n          case \"Point\":\n            return Wr(r, n, {\n              ignoreEndVertices: !0\n            });\n          case \"LineString\":\n            return function (t, e) {\n              for (var n = !1, r = 0, i = e.coordinates; r < i.length; r++) {\n                var o = i[r];\n                if (Wr({\n                  type: \"Point\",\n                  coordinates: o\n                }, t, {\n                  ignoreEndVertices: !0\n                }) && (n = !0), !Wr({\n                  type: \"Point\",\n                  coordinates: o\n                }, t, {\n                  ignoreEndVertices: !1\n                })) return !1;\n              }\n              return n;\n            }(n, r);\n          case \"MultiPoint\":\n            return function (t, e) {\n              for (var n = !1, r = 0, i = e.coordinates; r < i.length; r++) {\n                var o = i[r];\n                if (Wr(o, t, {\n                  ignoreEndVertices: !0\n                }) && (n = !0), !Wr(o, t)) return !1;\n              }\n              if (n) return !0;\n              return !1;\n            }(n, r);\n          default:\n            throw new Error(\"feature2 \" + o + \" geometry not supported\");\n        }\n      case \"Polygon\":\n        switch (o) {\n          case \"Point\":\n            return ye(r, n, {\n              ignoreBoundary: !0\n            });\n          case \"LineString\":\n            return function (t, e) {\n              var n = !1,\n                r = 0,\n                i = Z(t),\n                o = Z(e);\n              if (!ys(i, o)) return !1;\n              for (; r < e.coordinates.length - 1; r++) {\n                if (ye({\n                  type: \"Point\",\n                  coordinates: _s(e.coordinates[r], e.coordinates[r + 1])\n                }, t, {\n                  ignoreBoundary: !0\n                })) {\n                  n = !0;\n                  break;\n                }\n              }\n              return n;\n            }(n, r);\n          case \"Polygon\":\n            return function (t, e) {\n              if (\"Feature\" === t.type && null === t.geometry) return !1;\n              if (\"Feature\" === e.type && null === e.geometry) return !1;\n              var n = Z(t),\n                r = Z(e);\n              if (!ys(n, r)) return !1;\n              for (var i = rt(e).coordinates, o = 0, s = i; o < s.length; o++) for (var a = 0, u = s[o]; a < u.length; a++) {\n                if (!ye(u[a], t)) return !1;\n              }\n              return !0;\n            }(n, r);\n          case \"MultiPoint\":\n            return function (t, e) {\n              for (var n = 0, r = e.coordinates; n < r.length; n++) {\n                if (!ye(r[n], t, {\n                  ignoreBoundary: !0\n                })) return !1;\n              }\n              return !0;\n            }(n, r);\n          default:\n            throw new Error(\"feature2 \" + o + \" geometry not supported\");\n        }\n      default:\n        throw new Error(\"feature1 \" + i + \" geometry not supported\");\n    }\n  }, t.booleanCrosses = function (t, e) {\n    var n = rt(t),\n      r = rt(e),\n      i = n.type,\n      o = r.type;\n    switch (i) {\n      case \"MultiPoint\":\n        switch (o) {\n          case \"LineString\":\n            return ms(n, r);\n          case \"Polygon\":\n            return Es(n, r);\n          default:\n            throw new Error(\"feature2 \" + o + \" geometry not supported\");\n        }\n      case \"LineString\":\n        switch (o) {\n          case \"MultiPoint\":\n            return ms(r, n);\n          case \"LineString\":\n            return function (t, e) {\n              if (Or(t, e).features.length > 0) for (var n = 0; n < t.coordinates.length - 1; n++) for (var r = 0; r < e.coordinates.length - 1; r++) {\n                var i = !0;\n                if (0 !== r && r !== e.coordinates.length - 2 || (i = !1), bs(t.coordinates[n], t.coordinates[n + 1], e.coordinates[r], i)) return !0;\n              }\n              return !1;\n            }(n, r);\n          case \"Polygon\":\n            return xs(n, r);\n          default:\n            throw new Error(\"feature2 \" + o + \" geometry not supported\");\n        }\n      case \"Polygon\":\n        switch (o) {\n          case \"MultiPoint\":\n            return Es(r, n);\n          case \"LineString\":\n            return xs(r, n);\n          default:\n            throw new Error(\"feature2 \" + o + \" geometry not supported\");\n        }\n      default:\n        throw new Error(\"feature1 \" + i + \" geometry not supported\");\n    }\n  }, t.booleanDisjoint = ps, t.booleanEqual = function (t, e) {\n    return rt(t).type === rt(e).type && new Cs({\n      precision: 6\n    }).compare(tn(t), tn(e));\n  }, t.booleanIntersects = Ps, t.booleanOverlap = function (t, e) {\n    var n = rt(t),\n      r = rt(e),\n      i = n.type,\n      o = r.type;\n    if (\"MultiPoint\" === i && \"MultiPoint\" !== o || (\"LineString\" === i || \"MultiLineString\" === i) && \"LineString\" !== o && \"MultiLineString\" !== o || (\"Polygon\" === i || \"MultiPolygon\" === i) && \"Polygon\" !== o && \"MultiPolygon\" !== o) throw new Error(\"features must be of the same type\");\n    if (\"Point\" === i) throw new Error(\"Point geometry not supported\");\n    if (new Cs({\n      precision: 6\n    }).compare(t, e)) return !1;\n    var s = 0;\n    switch (i) {\n      case \"MultiPoint\":\n        for (var a = 0; a < n.coordinates.length; a++) for (var u = 0; u < r.coordinates.length; u++) {\n          var l = n.coordinates[a],\n            c = r.coordinates[u];\n          if (l[0] === c[0] && l[1] === c[1]) return !0;\n        }\n        return !1;\n      case \"LineString\":\n      case \"MultiLineString\":\n        U(t, function (t) {\n          U(e, function (e) {\n            ki(t, e).features.length && s++;\n          });\n        });\n        break;\n      case \"Polygon\":\n      case \"MultiPolygon\":\n        U(t, function (t) {\n          U(e, function (e) {\n            Or(t, e).features.length && s++;\n          });\n        });\n    }\n    return s > 0;\n  }, t.booleanParallel = function (t, e) {\n    if (!t) throw new Error(\"line1 is required\");\n    if (!e) throw new Error(\"line2 is required\");\n    if (\"LineString\" !== Us(t, \"line1\")) throw new Error(\"line1 must be a LineString\");\n    if (\"LineString\" !== Us(e, \"line2\")) throw new Error(\"line2 must be a LineString\");\n    for (var n = Zn(tn(t)).features, r = Zn(tn(e)).features, i = 0; i < n.length; i++) {\n      var o = n[i].geometry.coordinates;\n      if (!r[i]) break;\n      if (!js(o, r[i].geometry.coordinates)) return !1;\n    }\n    return !0;\n  }, t.booleanPointInPolygon = ye, t.booleanPointOnLine = Wr, t.booleanWithin = Zr, t.buffer = function (t, e, n) {\n    var r = (n = n || {}).units || \"kilometers\",\n      i = n.steps || 8;\n    if (!t) throw new Error(\"geojson is required\");\n    if (\"object\" != typeof n) throw new Error(\"options must be an object\");\n    if (\"number\" != typeof i) throw new Error(\"steps must be an number\");\n    if (void 0 === e) throw new Error(\"radius is required\");\n    if (i <= 0) throw new Error(\"steps must be greater than 0\");\n    var o = [];\n    switch (t.type) {\n      case \"GeometryCollection\":\n        return q(t, function (t) {\n          var n = ny(t, e, r, i);\n          n && o.push(n);\n        }), f(o);\n      case \"FeatureCollection\":\n        return F(t, function (t) {\n          var n = ny(t, e, r, i);\n          n && F(n, function (t) {\n            t && o.push(t);\n          });\n        }), f(o);\n    }\n    return ny(t, e, r, i);\n  }, t.center = xn, t.centerMean = Fa, t.centerMedian = function (t, e) {\n    if (void 0 === e && (e = {}), !P(e = e || {})) throw new Error(\"options is invalid\");\n    var n = e.counter || 10;\n    if (!C(n)) throw new Error(\"counter must be a number\");\n    var r = e.weight,\n      i = Fa(t, {\n        weight: e.weight\n      }),\n      o = f([]);\n    F(t, function (t) {\n      var e;\n      o.features.push(En(t, {\n        properties: {\n          weight: null === (e = t.properties) || void 0 === e ? void 0 : e[r]\n        }\n      }));\n    });\n    var s = {\n      tolerance: e.tolerance,\n      medianCandidates: []\n    };\n    return ka(i.geometry.coordinates, [0, 0], o, s, n);\n  }, t.centerOfMass = function t(e, n) {\n    switch (void 0 === n && (n = {}), it(e)) {\n      case \"Point\":\n        return a(K(e), n.properties);\n      case \"Polygon\":\n        var r = [];\n        R(e, function (t) {\n          r.push(t);\n        });\n        var i,\n          o,\n          s,\n          u,\n          l,\n          c,\n          h,\n          p,\n          f = En(e, {\n            properties: n.properties\n          }),\n          g = f.geometry.coordinates,\n          d = 0,\n          y = 0,\n          v = 0,\n          _ = r.map(function (t) {\n            return [t[0] - g[0], t[1] - g[1]];\n          });\n        for (i = 0; i < r.length - 1; i++) u = (o = _[i])[0], c = o[1], l = (s = _[i + 1])[0], v += p = u * (h = s[1]) - l * c, d += (u + l) * p, y += (c + h) * p;\n        if (0 === v) return f;\n        var m = 1 / (6 * (.5 * v));\n        return a([g[0] + m * d, g[1] + m * y], n.properties);\n      default:\n        var x = de(e);\n        return x ? t(x, {\n          properties: n.properties\n        }) : En(e, {\n          properties: n.properties\n        });\n    }\n  }, t.centroid = En, t.circle = _n, t.cleanCoords = tn, t.clone = Ie, t.clusterEach = ou, t.clusterReduce = su, t.clusters = hu, t.clustersDbscan = function (t, e, n) {\n    void 0 === n && (n = {}), !0 !== n.mutate && (t = Ie(t)), n.minPoints = n.minPoints || 3;\n    var r = new Ts.DBSCAN(),\n      i = r.run(G(t), N(e, n.units), n.minPoints, me),\n      o = -1;\n    return i.forEach(function (e) {\n      o++, e.forEach(function (e) {\n        var n = t.features[e];\n        n.properties || (n.properties = {}), n.properties.cluster = o, n.properties.dbscan = \"core\";\n      });\n    }), r.noise.forEach(function (e) {\n      var n = t.features[e];\n      n.properties || (n.properties = {}), n.properties.cluster ? n.properties.dbscan = \"edge\" : n.properties.dbscan = \"noise\";\n    }), t;\n  }, t.clustersKmeans = function (t, e) {\n    void 0 === e && (e = {});\n    var n = t.features.length;\n    e.numberOfClusters = e.numberOfClusters || Math.round(Math.sqrt(n / 2)), e.numberOfClusters > n && (e.numberOfClusters = n), !0 !== e.mutate && (t = Ie(t));\n    var r = G(t),\n      i = r.slice(0, e.numberOfClusters),\n      o = zs(r, e.numberOfClusters, i),\n      s = {};\n    return o.centroids.forEach(function (t, e) {\n      s[e] = t;\n    }), F(t, function (t, e) {\n      var n = o.idxs[e];\n      t.properties.cluster = n, t.properties.centroid = s[n];\n    }), t;\n  }, t.collect = function (t, e, n, r) {\n    var i = Nt(6),\n      o = e.features.map(function (t) {\n        var e;\n        return {\n          minX: t.geometry.coordinates[0],\n          minY: t.geometry.coordinates[1],\n          maxX: t.geometry.coordinates[0],\n          maxY: t.geometry.coordinates[1],\n          property: null === (e = t.properties) || void 0 === e ? void 0 : e[n]\n        };\n      });\n    return i.load(o), t.features.forEach(function (t) {\n      t.properties || (t.properties = {});\n      var e = Z(t),\n        n = i.search({\n          minX: e[0],\n          minY: e[1],\n          maxX: e[2],\n          maxY: e[3]\n        }),\n        o = [];\n      n.forEach(function (e) {\n        ye([e.minX, e.minY], t) && o.push(e.property);\n      }), t.properties[r] = o;\n    }), t;\n  }, t.collectionOf = nt, t.combine = function (t) {\n    var e = {\n      MultiPoint: {\n        coordinates: [],\n        properties: []\n      },\n      MultiLineString: {\n        coordinates: [],\n        properties: []\n      },\n      MultiPolygon: {\n        coordinates: [],\n        properties: []\n      }\n    };\n    return F(t, function (t) {\n      var n, r, i, o;\n      switch (null === (o = t.geometry) || void 0 === o ? void 0 : o.type) {\n        case \"Point\":\n          e.MultiPoint.coordinates.push(t.geometry.coordinates), e.MultiPoint.properties.push(t.properties);\n          break;\n        case \"MultiPoint\":\n          (n = e.MultiPoint.coordinates).push.apply(n, t.geometry.coordinates), e.MultiPoint.properties.push(t.properties);\n          break;\n        case \"LineString\":\n          e.MultiLineString.coordinates.push(t.geometry.coordinates), e.MultiLineString.properties.push(t.properties);\n          break;\n        case \"MultiLineString\":\n          (r = e.MultiLineString.coordinates).push.apply(r, t.geometry.coordinates), e.MultiLineString.properties.push(t.properties);\n          break;\n        case \"Polygon\":\n          e.MultiPolygon.coordinates.push(t.geometry.coordinates), e.MultiPolygon.properties.push(t.properties);\n          break;\n        case \"MultiPolygon\":\n          (i = e.MultiPolygon.coordinates).push.apply(i, t.geometry.coordinates), e.MultiPolygon.properties.push(t.properties);\n      }\n    }), f(Object.keys(e).filter(function (t) {\n      return e[t].coordinates.length;\n    }).sort().map(function (t) {\n      return o({\n        type: t,\n        coordinates: e[t].coordinates\n      }, {\n        collectedProperties: e[t].properties\n      });\n    }));\n  }, t.concave = function (t, e) {\n    void 0 === e && (e = {});\n    var n = e.maxEdge || 1 / 0,\n      r = xe(function (t) {\n        var e = [],\n          n = {};\n        return F(t, function (t) {\n          if (t.geometry) {\n            var r = t.geometry.coordinates.join(\"-\");\n            Object.prototype.hasOwnProperty.call(n, r) || (e.push(t), n[r] = !0);\n          }\n        }), f(e);\n      }(t));\n    if (r.features = r.features.filter(function (t) {\n      var r = t.geometry.coordinates[0][0],\n        i = t.geometry.coordinates[0][1],\n        o = t.geometry.coordinates[0][2],\n        s = me(r, i, e),\n        a = me(i, o, e),\n        u = me(r, o, e);\n      return s <= n && a <= n && u <= n;\n    }), r.features.length < 1) return null;\n    var i = $e(r);\n    return 1 === i.coordinates.length && (i.coordinates = i.coordinates[0], i.type = \"Polygon\"), o(i);\n  }, t.containsNumber = $, t.convertArea = S, t.convertDistance = N, t.convertLength = N, t.convex = de, t.coordAll = G, t.coordEach = R, t.coordReduce = T, t.createBins = au, t.degrees2radians = I, t.degreesToRadians = I, t.destination = vn, t.difference = function (t, e) {\n    var n = rt(t),\n      r = rt(e),\n      i = t.properties || {},\n      o = $u.difference(n.coordinates, r.coordinates);\n    return 0 === o.length ? null : 1 === o.length ? l(o[0], i) : y(o, i);\n  }, t.dissolve = function (t, e) {\n    if (!P(e = e || {})) throw new Error(\"options is invalid\");\n    var n = e.propertyName;\n    nt(t, \"Polygon\", \"dissolve\");\n    var r = [];\n    if (!e.propertyName) return ni(y($u.union.apply(null, t.features.map(function (t) {\n      return t.geometry.coordinates;\n    }))));\n    var i = {};\n    F(t, function (t) {\n      Object.prototype.hasOwnProperty.call(i, t.properties[n]) || (i[t.properties[n]] = []), i[t.properties[n]].push(t);\n    });\n    for (var o = Object.keys(i), s = 0; s < o.length; s++) {\n      var a = y($u.union.apply(null, i[o[s]].map(function (t) {\n        return t.geometry.coordinates;\n      })));\n      a.properties[n] = o[s], r.push(a);\n    }\n    return ni(f(r));\n  }, t.distance = me, t.distanceToDegrees = E, t.distanceToRadians = x, t.distanceWeight = ja, t.earthRadius = e, t.ellipse = Aa, t.envelope = dn, t.explode = bn, t.factors = n, t.feature = o, t.featureCollection = f, t.featureEach = F, t.featureOf = et, t.featureReduce = k, t.filterProperties = cu, t.findPoint = W, t.findSegment = H, t.flatten = ni, t.flattenEach = z, t.flattenReduce = j, t.flip = function (t, e) {\n    if (!P(e = e || {})) throw new Error(\"options is invalid\");\n    var n = e.mutate;\n    if (!t) throw new Error(\"geojson is required\");\n    return !1 !== n && void 0 !== n || (t = Ie(t)), R(t, function (t) {\n      var e = t[0],\n        n = t[1];\n      t[0] = n, t[1] = e;\n    }), t;\n  }, t.geojsonType = tt, t.geomEach = q, t.geomReduce = B, t.geometry = s, t.geometryCollection = v, t.getCluster = iu, t.getCoord = K, t.getCoords = Q, t.getGeom = rt, t.getType = it, t.greatCircle = function (t, e, n) {\n    if (\"object\" != typeof (n = n || {})) throw new Error(\"options is invalid\");\n    var r = n.properties,\n      i = n.npoints,\n      o = n.offset;\n    return t = K(t), e = K(e), r = r || {}, i = i || 100, o = o || 10, new vi({\n      x: t[0],\n      y: t[1]\n    }, {\n      x: e[0],\n      y: e[1]\n    }, r).Arc(i, {\n      offset: o\n    }).json();\n  }, t.helpers = O, t.hexGrid = ay, t.inside = ye, t.interpolate = function (t, e, n) {\n    if (\"object\" != typeof (n = n || {})) throw new Error(\"options is invalid\");\n    var r = n.gridType,\n      i = n.property,\n      o = n.weight;\n    if (!t) throw new Error(\"points is required\");\n    if (nt(t, \"Point\", \"input must contain Points\"), !e) throw new Error(\"cellSize is required\");\n    if (void 0 !== o && \"number\" != typeof o) throw new Error(\"weight must be a number\");\n    i = i || \"elevation\", r = r || \"square\", o = o || 1;\n    var s,\n      a = Z(t);\n    switch (r) {\n      case \"point\":\n      case \"points\":\n        s = ti(a, e, n);\n        break;\n      case \"square\":\n      case \"squares\":\n        s = py(a, e, n);\n        break;\n      case \"hex\":\n      case \"hexes\":\n        s = ay(a, e, n);\n        break;\n      case \"triangle\":\n      case \"triangles\":\n        s = fy(a, e, n);\n        break;\n      default:\n        throw new Error(\"invalid gridType\");\n    }\n    var u = [];\n    return F(s, function (e) {\n      var s = 0,\n        a = 0;\n      F(t, function (t) {\n        var u,\n          l = me(\"point\" === r ? e : En(e), t, n);\n        if (void 0 !== i && (u = t.properties[i]), void 0 === u && (u = t.geometry.coordinates[2]), void 0 === u) throw new Error(\"zValue is missing\");\n        0 === l && (s = u);\n        var c = 1 / Math.pow(l, o);\n        a += c, s += c * u;\n      });\n      var l = Ie(e);\n      l.properties[i] = s / a, u.push(l);\n    }), f(u);\n  }, t.intersect = sy, t.invariant = ot, t.isNumber = C, t.isObject = P, t.isobands = function (t, e, n) {\n    if (!P(n = n || {})) throw new Error(\"options is invalid\");\n    var r = n.zProperty || \"elevation\",\n      i = n.commonProperties || {},\n      o = n.breaksProperties || [];\n    if (nt(t, \"Point\", \"Input must contain Points\"), !e) throw new Error(\"breaks is required\");\n    if (!Array.isArray(e)) throw new Error(\"breaks is not an Array\");\n    if (!P(i)) throw new Error(\"commonProperties is not an Object\");\n    if (!Array.isArray(o)) throw new Error(\"breaksProperties is not an Array\");\n    var s = Zi(t, {\n        zProperty: r,\n        flip: !0\n      }),\n      a = function (t, e, n) {\n        for (var r = [], i = 1; i < e.length; i++) {\n          var o = +e[i - 1],\n            s = +e[i],\n            a = Zo(Jo($i(t, o, s - o))),\n            u = {};\n          u.groupedRings = a, u[n] = o + \"-\" + s, r.push(u);\n        }\n        return r;\n      }(s, e, r);\n    return f((a = function (t, e, n) {\n      var r = Z(n),\n        i = r[2] - r[0],\n        o = r[3] - r[1],\n        s = r[0],\n        a = r[1],\n        u = e[0].length - 1,\n        l = e.length - 1,\n        c = i / u,\n        h = o / l,\n        p = function p(t) {\n          t[0] = t[0] * c + s, t[1] = t[1] * h + a;\n        };\n      return t.forEach(function (t) {\n        t.groupedRings.forEach(function (t) {\n          t.forEach(function (t) {\n            t.forEach(p);\n          });\n        });\n      }), t;\n    }(a, s, t)).map(function (t, e) {\n      if (o[e] && !P(o[e])) throw new Error(\"Each mappedProperty is required to be an Object\");\n      var n = ct({}, i, o[e]);\n      return n[r] = t[r], y(t.groupedRings, n);\n    }));\n  }, t.isolines = function (t, e, n) {\n    if (!P(n = n || {})) throw new Error(\"options is invalid\");\n    var r = n.zProperty || \"elevation\",\n      i = n.commonProperties || {},\n      o = n.breaksProperties || [];\n    if (nt(t, \"Point\", \"Input must contain Points\"), !e) throw new Error(\"breaks is required\");\n    if (!Array.isArray(e)) throw new Error(\"breaks must be an Array\");\n    if (!P(i)) throw new Error(\"commonProperties must be an Object\");\n    if (!Array.isArray(o)) throw new Error(\"breaksProperties must be an Array\");\n    var s = _t(t, {\n      zProperty: r,\n      flip: !0\n    });\n    return f(function (t, e, n) {\n      var r = Z(n),\n        i = r[2] - r[0],\n        o = r[3] - r[1],\n        s = r[0],\n        a = r[1],\n        u = e[0].length - 1,\n        l = e.length - 1,\n        c = i / u,\n        h = o / l,\n        p = function p(t) {\n          t[0] = t[0] * c + s, t[1] = t[1] * h + a;\n        };\n      return t.forEach(function (t) {\n        R(t, p);\n      }), t;\n    }(function (t, e, n, r, i) {\n      for (var o = [], s = 1; s < e.length; s++) {\n        var a = +e[s],\n          u = ct({}, r, i[s]);\n        u[n] = a;\n        var l = g(ft(t, a), u);\n        o.push(l);\n      }\n      return o;\n    }(s, e, r, i, o), s, t));\n  }, t.kinks = function (t) {\n    var e,\n      n,\n      r = {\n        type: \"FeatureCollection\",\n        features: []\n      };\n    if (\"LineString\" === (n = \"Feature\" === t.type ? t.geometry : t).type) e = [n.coordinates];else if (\"MultiLineString\" === n.type) e = n.coordinates;else if (\"MultiPolygon\" === n.type) e = [].concat.apply([], n.coordinates);else {\n      if (\"Polygon\" !== n.type) throw new Error(\"Input must be a LineString, MultiLineString, Polygon, or MultiPolygon Feature or Geometry\");\n      e = n.coordinates;\n    }\n    return e.forEach(function (t) {\n      e.forEach(function (e) {\n        for (var n = 0; n < t.length - 1; n++) for (var i = n; i < e.length - 1; i++) {\n          if (t === e) {\n            if (1 === Math.abs(n - i)) continue;\n            if (0 === n && i === t.length - 2 && t[n][0] === t[t.length - 1][0] && t[n][1] === t[t.length - 1][1]) continue;\n          }\n          var o = Gr(t[n][0], t[n][1], t[n + 1][0], t[n + 1][1], e[i][0], e[i][1], e[i + 1][0], e[i + 1][1]);\n          o && r.features.push(a([o[0], o[1]]));\n        }\n      });\n    }), r;\n  }, t.length = Yr, t.lengthToDegrees = E, t.lengthToRadians = x, t.lineArc = bi, t.lineChunk = function (t, e, n) {\n    if (!P(n = n || {})) throw new Error(\"options is invalid\");\n    var r = n.units,\n      i = n.reverse;\n    if (!t) throw new Error(\"geojson is required\");\n    if (e <= 0) throw new Error(\"segmentLength must be greater than 0\");\n    var o = [];\n    return z(t, function (t) {\n      i && (t.geometry.coordinates = t.geometry.coordinates.reverse()), function (t, e, n, r) {\n        var i = Yr(t, {\n          units: n\n        });\n        if (i <= e) return r(t);\n        var o = i / e;\n        Number.isInteger(o) || (o = Math.floor(o) + 1);\n        for (var s = 0; s < o; s++) {\n          r(Hr(t, e * s, e * (s + 1), {\n            units: n\n          }), s);\n        }\n      }(t, e, r, function (t) {\n        o.push(t);\n      });\n    }), f(o);\n  }, t.lineDistance = Yr, t.lineEach = X, t.lineIntersect = Or, t.lineOffset = function (t, e, n) {\n    if (!P(n = n || {})) throw new Error(\"options is invalid\");\n    var r = n.units;\n    if (!t) throw new Error(\"geojson is required\");\n    if (null == e || isNaN(e)) throw new Error(\"distance is required\");\n    var i = it(t),\n      o = t.properties;\n    switch (i) {\n      case \"LineString\":\n        return os(t, e, r);\n      case \"MultiLineString\":\n        var s = [];\n        return z(t, function (t) {\n          s.push(os(t, e, r).geometry.coordinates);\n        }), g(s, o);\n      default:\n        throw new Error(\"geometry \" + i + \" is not supported\");\n    }\n  }, t.lineOverlap = ki, t.lineReduce = Y, t.lineSegment = Zn, t.lineSlice = function (t, e, n) {\n    var r = Q(n);\n    if (\"LineString\" !== it(n)) throw new Error(\"line must be a LineString\");\n    for (var i, o = Tr(n, t), s = Tr(n, e), a = [(i = o.properties.index <= s.properties.index ? [o, s] : [s, o])[0].geometry.coordinates], u = i[0].properties.index + 1; u < i[1].properties.index + 1; u++) a.push(r[u]);\n    return a.push(i[1].geometry.coordinates), h(a, n.properties);\n  }, t.lineSliceAlong = Hr, t.lineSplit = function (t, e) {\n    if (!t) throw new Error(\"line is required\");\n    if (!e) throw new Error(\"splitter is required\");\n    var n = it(t),\n      r = it(e);\n    if (\"LineString\" !== n) throw new Error(\"line must be LineString\");\n    if (\"FeatureCollection\" === r) throw new Error(\"splitter cannot be a FeatureCollection\");\n    if (\"GeometryCollection\" === r) throw new Error(\"splitter cannot be a GeometryCollection\");\n    var i = ei(e, {\n      precision: 7\n    });\n    switch (r) {\n      case \"Point\":\n        return mi(t, i);\n      case \"MultiPoint\":\n        return _i(t, i);\n      case \"LineString\":\n      case \"MultiLineString\":\n      case \"Polygon\":\n      case \"MultiPolygon\":\n        return _i(t, Or(t, i));\n    }\n  }, t.lineString = h, t.lineStringToPolygon = Ci, t.lineStrings = p, t.lineToPolygon = Ci, t.mask = function (t, e) {\n    var n,\n      r = hy(e),\n      i = null;\n    return \"FeatureCollection\" === t.type ? i = cy(2 === (n = t).features.length ? $u.union(n.features[0].geometry.coordinates, n.features[1].geometry.coordinates) : $u.union.apply($u, n.features.map(function (t) {\n      return t.geometry.coordinates;\n    }))) : i = cy($u.union(t.geometry.coordinates)), i.geometry.coordinates.forEach(function (t) {\n      r.geometry.coordinates.push(t[0]);\n    }), r;\n  }, t.meta = J, t.midpoint = function (t, e) {\n    return vn(t, me(t, e) / 2, mn(t, e));\n  }, t.moranIndex = function (t, e) {\n    var n = e.inputField,\n      r = e.threshold || 1e5,\n      i = e.p || 2,\n      o = e.binary || !1,\n      s = ja(t, {\n        alpha: e.alpha || -1,\n        binary: o,\n        p: i,\n        standardization: e.standardization || !0,\n        threshold: r\n      }),\n      a = [];\n    F(t, function (t) {\n      var e = t.properties || {};\n      a.push(e[n]);\n    });\n    for (var u = Ua(a), l = function (t) {\n        for (var e = Ua(t), n = 0, r = 0, i = t; r < i.length; r++) {\n          var o = i[r];\n          n += Math.pow(o - e, 2);\n        }\n        return n / t.length;\n      }(a), c = 0, h = 0, p = 0, f = 0, g = s.length, d = 0; d < g; d++) {\n      for (var y = 0, v = 0; v < g; v++) c += s[d][v] * (a[d] - u) * (a[v] - u), h += s[d][v], p += Math.pow(s[d][v] + s[v][d], 2), y += s[d][v] + s[v][d];\n      f += Math.pow(y, 2);\n    }\n    var _ = c / h / l,\n      m = -1 / (g - 1),\n      x = (g * g * (p *= .5) - g * f + h * h * 3) / ((g - 1) * (g + 1) * (h * h)) - m * m,\n      E = Math.sqrt(x);\n    return {\n      expectedMoranIndex: m,\n      moranIndex: _,\n      stdNorm: E,\n      zNorm: (_ - m) / E\n    };\n  }, t.multiLineString = g, t.multiPoint = d, t.multiPolygon = y, t.nearest = Jn, t.nearestPoint = Jn, t.nearestPointOnLine = Tr, t.nearestPointToLine = function (t, e, n) {\n    void 0 === n && (n = {});\n    var r = n.units,\n      i = n.properties || {},\n      o = function (t) {\n        var e = [];\n        switch (t.geometry ? t.geometry.type : t.type) {\n          case \"GeometryCollection\":\n            return q(t, function (t) {\n              \"Point\" === t.type && e.push({\n                type: \"Feature\",\n                properties: {},\n                geometry: t\n              });\n            }), {\n              type: \"FeatureCollection\",\n              features: e\n            };\n          case \"FeatureCollection\":\n            return t.features = t.features.filter(function (t) {\n              return \"Point\" === t.geometry.type;\n            }), t;\n          default:\n            throw new Error(\"points must be a Point Collection\");\n        }\n      }(t);\n    if (!o.features.length) throw new Error(\"points must contain features\");\n    if (!e) throw new Error(\"line is required\");\n    if (\"LineString\" !== it(e)) throw new Error(\"line must be a LineString\");\n    var s = 1 / 0,\n      a = null;\n    return F(o, function (t) {\n      var n = Dr(t, e, {\n        units: r\n      });\n      n < s && (s = n, a = t);\n    }), a && (a.properties = ct({\n      dist: s\n    }, a.properties, i)), a;\n  }, t.planepoint = function (t, e) {\n    var n = K(t),\n      r = rt(e).coordinates[0];\n    if (r.length < 4) throw new Error(\"OuterRing of a Polygon must have 4 or more Positions.\");\n    var i = e.properties || {},\n      o = i.a,\n      s = i.b,\n      a = i.c,\n      u = n[0],\n      l = n[1],\n      c = r[0][0],\n      h = r[0][1],\n      p = void 0 !== o ? o : r[0][2],\n      f = r[1][0],\n      g = r[1][1],\n      d = void 0 !== s ? s : r[1][2],\n      y = r[2][0],\n      v = r[2][1],\n      _ = void 0 !== a ? a : r[2][2];\n    return (_ * (u - c) * (l - g) + p * (u - f) * (l - v) + d * (u - y) * (l - h) - d * (u - c) * (l - v) - _ * (u - f) * (l - h) - p * (u - y) * (l - g)) / ((u - c) * (l - g) + (u - f) * (l - v) + (u - y) * (l - h) - (u - c) * (l - v) - (u - f) * (l - h) - (u - y) * (l - g));\n  }, t.point = a, t.pointGrid = ti, t.pointOnFeature = qr, t.pointOnLine = Tr, t.pointOnSurface = qr, t.pointToLineDistance = Dr, t.points = u, t.pointsWithinPolygon = _e, t.polygon = l, t.polygonSmooth = function (t, e) {\n    var n = [],\n      r = e.iterations || 1;\n    if (!t) throw new Error(\"inputPolys is required\");\n    return q(t, function (t, e, i) {\n      var o, s, a;\n      switch (t.type) {\n        case \"Polygon\":\n          o = [[]];\n          for (var u = 0; u < r; u++) a = [[]], s = t, u > 0 && (s = l(o).geometry), qa(s, a), o = a.slice(0);\n          n.push(l(o, i));\n          break;\n        case \"MultiPolygon\":\n          o = [[[]]];\n          for (var c = 0; c < r; c++) a = [[[]]], s = t, c > 0 && (s = y(o).geometry), Ba(s, a), o = a.slice(0);\n          n.push(y(o, i));\n          break;\n        default:\n          throw new Error(\"geometry is invalid, must be Polygon or MultiPolygon\");\n      }\n    }), f(n);\n  }, t.polygonTangents = function (t, e) {\n    var n,\n      r,\n      i,\n      o,\n      s = Q(t),\n      u = Q(e),\n      l = Z(e),\n      c = 0,\n      h = null;\n    switch (s[0] > l[0] && s[0] < l[2] && s[1] > l[1] && s[1] < l[3] && (c = (h = Jn(t, bn(e))).properties.featureIndex), it(e)) {\n      case \"Polygon\":\n        n = u[0][c], r = u[0][0], null !== h && h.geometry.coordinates[1] < s[1] && (r = u[0][c]), o = Xi(u[0][0], u[0][u[0].length - 1], s);\n        var p = Ui(u[0], s, o, i, n, r);\n        n = p[0], r = p[1];\n        break;\n      case \"MultiPolygon\":\n        for (var g = 0, d = 0, y = 0, v = 0; v < u[0].length; v++) {\n          g = v;\n          for (var _ = !1, m = 0; m < u[0][v].length; m++) {\n            if (d = m, y === c) {\n              _ = !0;\n              break;\n            }\n            y++;\n          }\n          if (_) break;\n        }\n        n = u[0][g][d], r = u[0][g][d], o = Xi(u[0][0][0], u[0][0][u[0][0].length - 1], s), u.forEach(function (t) {\n          var e = Ui(t[0], s, o, i, n, r);\n          n = e[0], r = e[1];\n        });\n    }\n    return f([a(n), a(r)]);\n  }, t.polygonToLine = Ii, t.polygonToLineString = Ii, t.polygonize = function (t) {\n    var e = hs.fromGeoJson(t);\n    e.deleteDangles(), e.deleteCutEdges();\n    var n = [],\n      r = [];\n    return e.getEdgeRings().filter(function (t) {\n      return t.isValid();\n    }).forEach(function (t) {\n      t.isHole() ? n.push(t) : r.push(t);\n    }), n.forEach(function (t) {\n      cs.findEdgeRingContaining(t, r) && r.push(t);\n    }), f(r.map(function (t) {\n      return t.toPolygon();\n    }));\n  }, t.polygons = c, t.projection = Ja, t.propEach = A, t.propReduce = D, t.propertiesContainsFilter = lu, t.radians2degrees = w, t.radiansToDegrees = w, t.radiansToDistance = m, t.radiansToLength = m, t.random = ru, t.randomLineString = tu, t.randomPoint = Qa, t.randomPolygon = $a, t.randomPosition = Ka, t.rewind = function (t, e) {\n    if (!P(e = e || {})) throw new Error(\"options is invalid\");\n    var n = e.reverse || !1,\n      r = e.mutate || !1;\n    if (!t) throw new Error(\"<geojson> is required\");\n    if (\"boolean\" != typeof n) throw new Error(\"<reverse> must be a boolean\");\n    if (\"boolean\" != typeof r) throw new Error(\"<mutate> must be a boolean\");\n    !1 === r && (t = Ie(t));\n    var i = [];\n    switch (t.type) {\n      case \"GeometryCollection\":\n        return q(t, function (t) {\n          Hi(t, n);\n        }), t;\n      case \"FeatureCollection\":\n        return F(t, function (t) {\n          F(Hi(t, n), function (t) {\n            i.push(t);\n          });\n        }), f(i);\n    }\n    return Hi(t, n);\n  }, t.rhumbBearing = Bi, t.rhumbDestination = ji, t.rhumbDistance = Ar, t.round = _, t.sample = function (t, e) {\n    if (!t) throw new Error(\"featurecollection is required\");\n    if (null == e) throw new Error(\"num is required\");\n    if (\"number\" != typeof e) throw new Error(\"num must be a number\");\n    return f(function (t, e) {\n      var n,\n        r,\n        i = t.slice(0),\n        o = t.length,\n        s = o - e;\n      for (; o-- > s;) n = i[r = Math.floor((o + 1) * Math.random())], i[r] = i[o], i[o] = n;\n      return i.slice(s);\n    }(t.features, e));\n  }, t.sector = function (t, e, n, r, i) {\n    if (!P(i = i || {})) throw new Error(\"options is invalid\");\n    var o = i.properties;\n    if (!t) throw new Error(\"center is required\");\n    if (null == n) throw new Error(\"bearing1 is required\");\n    if (null == r) throw new Error(\"bearing2 is required\");\n    if (!e) throw new Error(\"radius is required\");\n    if (\"object\" != typeof i) throw new Error(\"options must be an object\");\n    if (qi(n) === qi(r)) return _n(t, e, i);\n    var s = Q(t),\n      a = bi(t, e, n, r, i),\n      u = [[s]];\n    return R(a, function (t) {\n      u[0].push(t);\n    }), u[0].push(s), l(u, o);\n  }, t.segmentEach = U, t.segmentReduce = V, t.shortestPath = function (t, e, n) {\n    if (!P(n = n || {})) throw new Error(\"options is invalid\");\n    var r = n.resolution,\n      i = n.minDistance,\n      s = n.obstacles || f([]);\n    if (!t) throw new Error(\"start is required\");\n    if (!e) throw new Error(\"end is required\");\n    if (r && !C(r) || r <= 0) throw new Error(\"options.resolution must be a number, greater than 0\");\n    if (i) throw new Error(\"options.minDistance is not yet implemented\");\n    var u = K(t),\n      l = K(e);\n    switch (t = a(u), e = a(l), it(s)) {\n      case \"FeatureCollection\":\n        if (0 === s.features.length) return h([u, l]);\n        break;\n      case \"Polygon\":\n        s = f([o(rt(s))]);\n        break;\n      default:\n        throw new Error(\"invalid obstacles\");\n    }\n    var c = s;\n    c.features.push(t), c.features.push(e);\n    var p = Z(ts(gn(Z(c)), 1.15));\n    r || (r = me([p[0], p[1]], [p[2], p[1]], n) / 100), c.features.pop(), c.features.pop();\n    for (var g = p[0], d = p[1], y = p[2], v = p[3], _ = r / me([g, d], [y, d], n) * (y - g), m = r / me([g, d], [g, v], n) * (v - d), x = y - g, E = v - d, b = Math.floor(x / _), w = Math.floor(E / m), I = (x - b * _) / 2, N = [], S = [], M = [], L = [], O = 1 / 0, R = 1 / 0, T = v - (E - w * m) / 2, A = 0; T >= d;) {\n      for (var D = [], F = [], k = g + I, G = 0; k <= y;) {\n        var q = a([k, T]),\n          B = Js(q, s);\n        D.push(B ? 0 : 1), F.push(k + \"|\" + T);\n        var z = me(q, t);\n        !B && z < O && (O = z, M = {\n          x: G,\n          y: A\n        });\n        var j = me(q, e);\n        !B && j < R && (R = j, L = {\n          x: G,\n          y: A\n        }), k += _, G++;\n      }\n      S.push(D), N.push(F), T -= m, A++;\n    }\n    var U = new Ys(S, {\n        diagonal: !0\n      }),\n      V = U.grid[M.y][M.x],\n      X = U.grid[L.y][L.x],\n      Y = Xs.search(U, V, X),\n      H = [u];\n    return Y.forEach(function (t) {\n      var e = N[t.x][t.y].split(\"|\");\n      H.push([+e[0], +e[1]]);\n    }), H.push(l), tn(h(H));\n  }, t.simplify = function (t, e) {\n    if (!P(e = e || {})) throw new Error(\"options is invalid\");\n    var n = void 0 !== e.tolerance ? e.tolerance : 1,\n      r = e.highQuality || !1,\n      i = e.mutate || !1;\n    if (!t) throw new Error(\"geojson is required\");\n    if (n && n < 0) throw new Error(\"invalid tolerance\");\n    return !0 !== i && (t = Ie(t)), q(t, function (t) {\n      !function (t, e, n) {\n        var r = t.type;\n        if (\"Point\" === r || \"MultiPoint\" === r) return t;\n        tn(t, !0);\n        var i = t.coordinates;\n        switch (r) {\n          case \"LineString\":\n            t.coordinates = ln(i, e, n);\n            break;\n          case \"MultiLineString\":\n            t.coordinates = i.map(function (t) {\n              return ln(t, e, n);\n            });\n            break;\n          case \"Polygon\":\n            t.coordinates = cn(i, e, n);\n            break;\n          case \"MultiPolygon\":\n            t.coordinates = i.map(function (t) {\n              return cn(t, e, n);\n            });\n        }\n      }(t, n, r);\n    }), t;\n  }, t.square = yn, t.squareGrid = py, t.standardDeviationalEllipse = function (t, e) {\n    if (!P(e = e || {})) throw new Error(\"options is invalid\");\n    var n = e.steps || 64,\n      r = e.weight,\n      i = e.properties || {};\n    if (!C(n)) throw new Error(\"steps must be a number\");\n    if (!P(i)) throw new Error(\"properties must be a number\");\n    var o = G(t).length,\n      s = Fa(t, {\n        weight: r\n      }),\n      a = 0,\n      u = 0,\n      l = 0;\n    F(t, function (t) {\n      var e = t.properties[r] || 1,\n        n = Ga(Q(t), Q(s));\n      a += Math.pow(n.x, 2) * e, u += Math.pow(n.y, 2) * e, l += n.x * n.y * e;\n    });\n    var c = a - u,\n      h = Math.sqrt(Math.pow(c, 2) + 4 * Math.pow(l, 2)),\n      p = 2 * l,\n      g = Math.atan((c + h) / p),\n      d = 180 * g / Math.PI,\n      y = 0,\n      v = 0,\n      _ = 0;\n    F(t, function (t) {\n      var e = t.properties[r] || 1,\n        n = Ga(Q(t), Q(s));\n      y += Math.pow(n.x * Math.cos(g) - n.y * Math.sin(g), 2) * e, v += Math.pow(n.x * Math.sin(g) + n.y * Math.cos(g), 2) * e, _ += e;\n    });\n    var m = Math.sqrt(2 * y / _),\n      x = Math.sqrt(2 * v / _),\n      E = Aa(s, m, x, {\n        units: \"degrees\",\n        angle: d,\n        steps: n,\n        properties: i\n      }),\n      b = _e(t, f([E])),\n      w = {\n        meanCenterCoordinates: Q(s),\n        semiMajorAxis: m,\n        semiMinorAxis: x,\n        numberOfFeatures: o,\n        angle: d,\n        percentageWithinEllipse: 100 * G(b).length / o\n      };\n    return E.properties.standardDeviationalEllipse = w, E;\n  }, t.tag = function (t, e, n, r) {\n    return t = Ie(t), e = Ie(e), F(t, function (t) {\n      t.properties || (t.properties = {}), F(e, function (e) {\n        void 0 === t.properties[r] && ye(t, e) && (t.properties[r] = e.properties[n]);\n      });\n    }), t;\n  }, t.tesselate = function (t) {\n    if (!t.geometry || \"Polygon\" !== t.geometry.type && \"MultiPolygon\" !== t.geometry.type) throw new Error(\"input must be a Polygon or MultiPolygon\");\n    var e = {\n      type: \"FeatureCollection\",\n      features: []\n    };\n    return \"Polygon\" === t.geometry.type ? e.features = Wn(t.geometry.coordinates) : t.geometry.coordinates.forEach(function (t) {\n      e.features = e.features.concat(Wn(t));\n    }), e;\n  }, t.tin = xe, t.toMercator = Va, t.toWgs84 = Xa, t.transformRotate = $o, t.transformScale = ts, t.transformTranslate = function (t, e, n, r) {\n    if (!P(r = r || {})) throw new Error(\"options is invalid\");\n    var i = r.units,\n      o = r.zTranslation,\n      s = r.mutate;\n    if (!t) throw new Error(\"geojson is required\");\n    if (null == e || isNaN(e)) throw new Error(\"distance is required\");\n    if (o && \"number\" != typeof o && isNaN(o)) throw new Error(\"zTranslation is not a number\");\n    if (o = void 0 !== o ? o : 0, 0 === e && 0 === o) return t;\n    if (null == n || isNaN(n)) throw new Error(\"direction is required\");\n    return e < 0 && (e = -e, n += 180), !1 !== s && void 0 !== s || (t = Ie(t)), R(t, function (t) {\n      var r = Q(ji(t, e, n, {\n        units: i\n      }));\n      t[0] = r[0], t[1] = r[1], o && 3 === t.length && (t[2] += o);\n    }), t;\n  }, t.triangleGrid = fy, t.truncate = ei, t.union = function (t, e, n) {\n    void 0 === n && (n = {});\n    var r = rt(t),\n      i = rt(e),\n      o = $u.union(r.coordinates, i.coordinates);\n    return 0 === o.length ? null : 1 === o.length ? l(o[0], n.properties) : y(o, n.properties);\n  }, t.unitsFactors = r, t.unkinkPolygon = function (t) {\n    var e = [];\n    return z(t, function (t) {\n      \"Polygon\" === t.geometry.type && F(oi(t), function (n) {\n        e.push(l(n.geometry.coordinates, t.properties));\n      });\n    }), f(e);\n  }, t.validateBBox = M, t.validateId = L, t.voronoi = function (t, e) {\n    if (!P(e = e || {})) throw new Error(\"options is invalid\");\n    var n = e.bbox || [-180, -85, 180, 85];\n    if (!t) throw new Error(\"points is required\");\n    if (!Array.isArray(n)) throw new Error(\"bbox is invalid\");\n    return nt(t, \"Point\", \"points\"), f(function () {\n      var t = Ks,\n        e = Qs,\n        n = null;\n      function r(r) {\n        return new Ra(r.map(function (n, i) {\n          var o = [Math.round(t(n, i, r) / Ma) * Ma, Math.round(e(n, i, r) / Ma) * Ma];\n          return o.index = i, o.data = n, o;\n        }), n);\n      }\n      return r.polygons = function (t) {\n        return r(t).polygons();\n      }, r.links = function (t) {\n        return r(t).links();\n      }, r.triangles = function (t) {\n        return r(t).triangles();\n      }, r.x = function (e) {\n        return arguments.length ? (t = \"function\" == typeof e ? e : Zs(+e), r) : t;\n      }, r.y = function (t) {\n        return arguments.length ? (e = \"function\" == typeof t ? t : Zs(+t), r) : e;\n      }, r.extent = function (t) {\n        return arguments.length ? (n = null == t ? null : [[+t[0][0], +t[0][1]], [+t[1][0], +t[1][1]]], r) : n && [[n[0][0], n[0][1]], [n[1][0], n[1][1]]];\n      }, r.size = function (t) {\n        return arguments.length ? (n = null == t ? null : [[0, 0], [+t[0], +t[1]]], r) : n && [n[1][0] - n[0][0], n[1][1] - n[0][1]];\n      }, r;\n    }().x(function (t) {\n      return t.geometry.coordinates[0];\n    }).y(function (t) {\n      return t.geometry.coordinates[1];\n    }).extent([[n[0], n[1]], [n[2], n[3]]]).polygons(t.features).map(Ta));\n  }, t.within = _e, Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n});","map":null,"metadata":{},"sourceType":"script"}